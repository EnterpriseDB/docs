---
title: EDB*Loader
---


EDB\*Loader is a high-performance bulk data loader that provides an interface compatible with Oracle databases for Advanced Server. The EDB\*Loader command line utility loads data from an input source, typically a file, into one or more tables using a subset of the parameters offered by Oracle SQL\*Loader.

EDB\*Loader features include:
 - Support for the Oracle SQL\*Loader data loading methods - conventional path load, direct path load, and parallel direct path load
 - Syntax for control file directives compatible with Oracle SQL\*Loader
 - Input data with delimiter-separated or fixed-width fields
 - Bad file for collecting rejected records
 - Loading of multiple target tables
 - Discard file for collecting records that do not meet the selection criteria of any target table
 - Log file for recording the EDB\*Loader session and any error messages
 - Data loading from standard input and remote loading, particularly useful for large data sources on remote hosts

These features are explained in detail in the following sections.

**Note:** The following are important version compatibility restrictions between the EDB\*Loader client and the database server.
 - Invoking EDB\*Loader is done using a client program called edbldr, which is used to pass parameters and directive information to the database server. **It is strongly recommended that the EDB\*Loader client supplied with Advanced Server 10 be used to load data only into version 10 of the database server. In general, the EDB\*Loader client and database server should be the same version.**
 - It is possible to use a version 10 EDB\*Loader client to load data into a 10 database server, but the new EDB\*Loader features may not be available under those circumstances.
 - Use of a version 10, 9.6, 9.5, 9.4 or 9.3 EDB\*Loader client is not supported for database servers version 9.2 or earlier.

## Data Loading Methods

As with Oracle SQL\*Loader, EDB\*Loader supports three data loading methods:
 - Conventional path load
 - Direct path load
 - Parallel direct path load

Conventional path load is the default method used by EDB\*Loader. Basic insert processing is used to add rows to the table.

The advantage of a conventional path load over the other methods is that table constraints and database objects defined on the table such as primary keys, not null constraints, check constraints, unique indexes, foreign key constraints, and triggers are enforced during a conventional path load.

One exception is that the Advanced Server *rules* defined on the table are not enforced. EDB\*Loader can load tables on which rules are defined, but the rules are not executed. As a consequence, partitioned tables implemented using rules cannot be loaded using EDB\*Loader.

**Note:** Advanced Server rules are created by the CREATE RULE command. Advanced Server rules are not the same database objects as rules and rule sets used in Oracle.

EDB\*Loader also supports direct path loads. A direct path load is faster than a conventional path load, but requires the removal of most types of constraints and triggers from the table. See Section <span class="underline">2.5</span> for information on direct path loads.

Finally, EDB\*Loader supports parallel direct path loads. A parallel direct path load provides even greater performance improvement by permitting multiple EDB\*Loader sessions to run simultaneously to load a single table. See Section <span class="underline">2.5.1</span> for information on parallel direct path loads.

## General Usage

EDB\*Loader can load data files with either delimiter-separated or fixed-width fields, in single-byte or multi-byte character sets. The delimiter can be a string consisting of one or more single-byte or multi-byte characters. Data file encoding and the database encoding may be different. Character set conversion of the data file to the database encoding is supported.

Each EDB\*Loader session runs as a single, independent transaction. If an error should occur during the EDB\*Loader session that aborts the transaction, all changes made during the session are rolled back.

Generally, formatting errors in the data file do not result in an aborted transaction. Instead, the badly formatted records are written to a text file called the *bad file*. The reason for the error is recorded in the *log file*.

Records causing database integrity errors do result in an aborted transaction and rollback. As with formatting errors, the record causing the error is written to the bad file and the reason is recorded in the log file.

**Note:** EDB\*Loader differs from Oracle SQL\*Loader in that a database integrity error results in a rollback in EDB\*Loader. In Oracle SQL\*Loader, only the record causing the error is rejected. Records that were previously inserted into the table are retained and loading continues after the rejected record.

The following are examples of types of formatting errors that do not abort the transaction:
 - Attempt to load non-numeric value into a numeric column
 - Numeric value is too large for a numeric column
 - Character value is too long for the maximum length of a character column
 - Attempt to load improperly formatted date value into a date column

The following are examples of types of database errors that abort the transaction and result in the rollback of all changes made in the EDB\*Loader session:
 - Violation of a unique constraint such as a primary key or unique index
 - Violation of a referential integrity constraint
 - Violation of a check constraint
 - Error thrown by a trigger fired as a result of inserting rows

## Building the EDB\*Loader Control File

When you invoke EDB\*Loader, the list of arguments provided must include the name of a control file. The control file includes the instructions that EDB\*Loader uses to load the table (or tables) from the input data file. The control file includes information such as:
 - The name of the input data file containing the data to be loaded.
 - The name of the table or tables to be loaded from the data file.
 - Names of the columns within the table or tables and their corresponding field placement in the data file.
 - Specification of whether the data file uses a delimiter string to separate the fields, or if the fields occupy fixed column positions.
 - Optional selection criteria to choose which records from the data file to load into a given table.
 - The name of the file that will collect illegally formatted records.
 - The name of the discard file that will collect records that do not meet the selection criteria of any table.

The syntax for the EDB\*Loader control file is as follows:

\[ OPTIONS (*param*=*value* \[, *param*=*value* \] ...) \]

LOAD DATA

\[ CHARACTERSET *charset* \]

\[ INFILE '{ *data\_file* | stdin }' \]

\[ BADFILE '*bad\_file*' \]

\[ DISCARDFILE '*discard\_file*' \]

\[ { DISCARDMAX | DISCARDS } *max\_discard\_recs* \]

\[ INSERT | APPEND | REPLACE | TRUNCATE \]

\[ PRESERVE BLANKS \]

{ INTO TABLE *target\_table*

\[ WHEN *field\_condition* \[ AND *field\_condition* \] ...\]

\[ FIELDS TERMINATED BY '*termstring*'

\[ OPTIONALLY ENCLOSED BY '*enclstring*' \] \]

\[ RECORDS DELIMITED BY '*delimstring*' \]

\[ TRAILING NULLCOLS \]

(*field\_def* \[, *field\_def* \] ...)

} ...

where *field\_def* defines a field in the specified *data\_file* that describes the location, data format, or value of the data to be inserted into *column\_name* of the *target\_table*. The syntax of *field\_def* is the following:

*column\_name* {

CONSTANT *val* |

FILLER \[ POSITION (*start*:*end*) \] \[ *fieldtype* \] |

BOUNDFILLER \[ POSITION (*start*:*end*) \] \[ *fieldtype* \] |

\[ POSITION (*start*:*end*) \] \[ *fieldtype* \]

\[ NULLIF *field\_condition* \[ AND *field\_condition* \] ...\]

\[ PRESERVE BLANKS \] \[ "*expr*" \]

}

where *fieldtype* is one of:

CHAR \[(*length*)\] | DATE \[(*length*)\] \[ "*datemask*" \] |

INTEGER EXTERNAL \[(*length*)\] |
FLOAT EXTERNAL \[(*length*)\] | DECIMAL EXTERNAL \[(*length*)\] |

ZONED EXTERNAL \[(*length*)\] | ZONED \[(*precision*\[,*scale*\])\]

Description

The specification of *data\_file*, *bad\_file*, and *discard\_file* may include the full directory path or a relative directory path to the file name. If the file name is specified alone or with a relative directory path, the file is then assumed to exist (in the case of *data\_file*), or is created (in the case of *bad\_file* or *discard\_file*), relative to the current working directory from which edbldr is invoked.

You can include references to environment variables within the EDB\*Loader control file when referring to a directory path and/or file name. Environment variable references are formatted differently on Windows systems than on Linux systems:
 - On Linux, the format is $*ENV\_VARIABLE* or ${*ENV\_VARIABLE*}
 - On Windows, the format is %*ENV\_VARIABLE*%

Where *ENV\_VARIABLE* is the environment variable that is set to the directory path and/or file name.

The EDBLDR\_ENV\_STYLE environment variable instructs Advanced Server to interpret environment variable references as Windows-styled references or Linux-styled references irregardless of the operating system on which EDB\*Loader resides. You can use this environment variable to create portable control files for EDB\*Loader.
 - On a Windows system, set EDBLDR\_ENV\_STYLE to linux or unix to instruct Advanced Server to recognize Linux-style references within the control file.
 - On a Linux system, set EDBLDR\_ENV\_STYLE to windows to instruct Advanced Server to recognize Windows-style references within the control file.

The operating system account enterprisedb must have read permission on the directory and file specified by *data\_file*.

The operating system account enterprisedb must have write permission on the directories where *bad\_file* and *discard\_file* are to be written.

**Note:** It is suggested that the file names for *data\_file*, *bad\_file*, and *discard\_file* include extensions of .dat, .bad, and .dsc, respectively. If the provided file name does not contain an extension, EDB\*Loader assumes the actual file name includes the appropriate aforementioned extension.

If an EDB\*Loader session results in data format errors and the BADFILE clause is not specified, nor is the BAD parameter given on the command line when edbldr is invoked, a bad file is created with the name *control\_file\_base*.bad in the current working directory from which edbldr is invoked. *control\_file\_base* is the base name of the control file (that is, the file name without any extension) used in the edbldr session.

If all of the following conditions are true, the discard file is not created even if the EDB\*Loader session results in discarded records:
 - The DISCARDFILE clause for specifying the discard file is not included in the control file.
 - The DISCARD parameter for specifying the discard file is not included on the command line.
 - The DISCARDMAX clause for specifying the maximum number of discarded records is not included in the control file.
 - The DISCARDS clause for specifying the maximum number of discarded records is not included in the control file.
 - The DISCARDMAX parameter for specifying the maximum number of discarded records is not included on the command line.

If neither the DISCARDFILE clause nor the DISCARD parameter for explicitly specifying the discard file name are specified, but DISCARDMAX or DISCARDS is specified, then the EDB\*Loader session creates a discard file using the data file name with an extension of .dsc.

**Note:** There is a distinction between keywords DISCARD and DISCARDS. DISCARD is an EDB\*Loader command line parameter used to specify the discard file name (see Section <span class="underline"> </span> <span class="underline">2.2</span>). DISCARDS is a clause of the LOAD DATA directive that may only appear in the control file. Keywords DISCARDS and DISCARDMAX provide the same functionality of specifying the maximum number of discarded records allowed before terminating the EDB\*Loader session. Records loaded into the database before termination of the EDB\*Loader session due to exceeding the DISCARDS or DISCARDMAX settings are kept in the database and are not rolled back.

If one of INSERT, APPEND, REPLACE, or TRUNCATE is specified, it establishes the default action of how rows are to be added to target tables. If omitted, the default action is as if INSERT had been specified.

If the FIELDS TERMINATED BY clause is specified, then the POSITION (*start*:*end*) clause may not be specified for any *field\_def*. Alternatively if the FIELDS TERMINATED BY clause is not specified, then every *field\_def* must contain either the POSITION (*start*:*end*) clause, the *fieldtype*(*length*) clause, or the CONSTANT clause.

Parameters

OPTIONS *param*=*value*

Use the OPTIONS clause to specify *param*=*value* pairs that represent an EDB\*Loader directive. If a parameter is specified in both the OPTIONS clause and on the command line when edbldr is invoked, the command line setting is used.

Specify one or more of the following parameter/value pairs:

> DIRECT= { FALSE | TRUE }
>
> If DIRECT is set to TRUE EDB\*Loader performs a direct path load instead of a conventional path load. The default value of DIRECT is FALSE.
>
> See Section <span class="underline">2.5</span> for information on direct path loads.

ERRORS=*error\_count*

> *error\_count* specifies the number of errors permitted before aborting the EDB\*Loader session. The default is 50.
>
> FREEZE= { FALSE | TRUE }
>
> Set FREEZE to TRUE to indicate that the data should be copied with the rows *frozen*. A tuple guaranteed to be visible to all current and future transactions is marked as frozen to prevent transaction ID wrap-around. For more information about frozen tuples, see the PostgreSQL core documentation at:
>
> <https://www.postgresql.org/docs/10/static/routine-vacuuming.html>
>
> You must specify a data-loading type of TRUNCATE in the control file when using the FREEZE option. FREEZE is not supported for direct loading.
>
> By default, FREEZE is FALSE.
>
> PARALLEL= { FALSE | TRUE }
>
> Set PARALLEL to TRUE to indicate that this EDB\*Loader session is one of a number of concurrent EDB\*Loader sessions participating in a parallel direct path load. The default value of PARALLEL is FALSE.
>
> When PARALLEL is TRUE, the DIRECT parameter must also be set to TRUE . See Section <span class="underline">2.5.1</span> for more information about parallel direct path loads.

ROWS=*n*

> *n* specifies the number of rows that EDB\*Loader will commit before loading the next set of *n* rows.
>
> If EDB\*Loader encounters an invalid row during a load (in which the ROWS parameter is specified), those rows committed prior to encountering the error will remain in the destination table.

SKIP=*skip*\_*count*

> *skip\_count* specifies the number of records at the beginning of the input data file that should be skipped before loading begins. The default is 0.

SKIP\_INDEX\_MAINTENANCE={ FALSE | TRUE }

> If SKIP\_INDEX\_MAINTENANCE is TRUE, index maintenance is not performed as part of a direct path load, and indexes on the loaded table are marked as invalid. The default value of SKIP\_INDEX\_MAINTENANCE is FALSE.
>
> Please note: During a parallel direct path load, target table indexes are not updated, and are marked as invalid after the load is complete.
>
> You can use the REINDEX command to rebuild an index. For more information about the REINDEX command, see the PostgreSQL core documentation available at:
>
> <https://www.postgresql.org/docs/10/static/sql-reindex.html>

*charset*

Use the CHARACTERSET clause to identify the character set encoding of *data\_file* where *charset* is the character set name. This clause is required if the data file encoding differs from the control file encoding. (The control file encoding must always be in the encoding of the client where edbldr is invoked.)

Examples of *charset* settings are UTF8, SQL\_ASCII, and SJIS.

For more information about client to database character set conversion, see the PostgreSQL core documentation available at:

<https://www.postgresql.org/docs/10/static/multibyte.html>

*data\_file*

File containing the data to be loaded into *target\_table*. Each record in the data file corresponds to a row to be inserted into *target\_table*.

If an extension is not provided in the file name, EDB\*Loader assumes the file has an extension of .dat, for example, mydatafile.dat.

**Note:** If the DATA parameter is specified on the command line when edbldr is invoked, the file given by the command line DATA parameter is used instead.

If the INFILE clause is omitted as well as the command line DATA parameter, then the data file name is assumed to be identical to the control file name, but with an extension of .dat.

stdin

Specify stdin (all lowercase letters) if you want to use standard input to pipe the data to be loaded directly to EDB\*Loader. This is useful for data sources generating a large number of records to be loaded.

*bad\_file*

File that receives *data\_file* records that cannot be loaded due to errors.

If an extension is not provided in the file name, EDB\*Loader assumes the file has an extension of .bad, for example, mybadfile.bad.

**Note:** If the BAD parameter is specified on the command line when edbldr is invoked, the file given by the command line BAD parameter is used instead.

*discard\_file*

File that receives input data records that are not loaded into any table because none of the selection criteria are met for tables with the WHEN clause, and there are no tables without a WHEN clause. (All records meet the selection criteria of a table without a WHEN clause.)

If an extension is not provided in the file name, EDB\*Loader assumes the file has an extension of .dsc, for example, mydiscardfile.dsc.

**Note:** If the DISCARD parameter is specified on the command line when edbldr is invoked, the file given by the command line DISCARD parameter is used instead.

{ DISCARDMAX | DISCARDS } *max\_discard\_recs*

Maximum number of discarded records that may be encountered from the input data records before terminating the EDB\*Loader session. (A discarded record is described in the preceding description of the *discard\_file* parameter.) Either keyword DISCARDMAX or DISCARDS may be used preceding the integer value specified by *max\_discard\_recs*.

For example, if *max\_discard\_recs* is 0, then the EDB\*Loader session is terminated if and when a first discarded record is encountered. If *max\_discard\_recs* is 1, then the EDB\*Loader session is terminated if and when a second discarded record is encountered.

When the EDB\*Loader session is terminated due to exceeding *max\_discard\_recs*, prior input data records that have been loaded into the database are retained. They are not rolled back.

INSERT | APPEND | REPLACE | TRUNCATE

Specifies how data is to be loaded into the target tables. If one of INSERT, APPEND, REPLACE, or TRUNCATE is specified, it establishes the default action for all tables, overriding the default of INSERT.

INSERT

> Data is to be loaded into an empty table. EDB\*Loader throws an exception and does not load any data if the table is not initially empty.
>
> **Note:** If the table contains rows, the TRUNCATE command must be used to empty the table prior to invoking EDB\*Loader. EDB\*Loader throws an exception if the DELETE command is used to empty the table instead of the TRUNCATE command. Oracle SQL\*Loader allows the table to be emptied by using either the DELETE or TRUNCATE command.

APPEND

> Data is to be added to any existing rows in the table. The table may be initially empty as well.

REPLACE

> The REPLACE keyword and TRUNCATE keywords are functionally identical. The table is truncated by EDB\*Loader prior to loading the new data.
>
> **Note:** Delete triggers on the table are not fired as a result of the REPLACE operation.

TRUNCATE

> The table is truncated by EDB\*Loader prior to loading the new data. Delete triggers on the table are not fired as a result of the truncate operation.

PRESERVE BLANKS

For all target tables, retains leading white space when the optional enclosure delimiters are not present and leaves trailing white space intact when fields are specified with a predetermined size. When omitted, the default behavior is to trim leading and trailing white space.

*target\_table*

Name of the table into which data is to be loaded. The table name may be schema-qualified (for example, enterprisedb.emp). The specified target must not be a view.

*field\_condition*

Conditional clause taking the following form:

\[ ( \] { (*start*:*end*) | *column\_name* } { = | \!= | \<\> }

'*val*' \[ ) \]

This conditional clause is used for the WHEN clause, which is part of the INTO TABLE *target\_table* clause, and the NULLIF clause, which is part of the field definition denoted as *field\_def* in the syntax diagram.

*start* and *end* are positive integers specifying the column positions in *data\_file* that mark the beginning and end of a field that is to be compared with the constant *val*. The first character in each record begins with a *start* value of 1.

*column\_name* specifies the name assigned to a field definition of the data file as defined by *field\_def* in the syntax diagram.

Use of either (*start*:*end*) or *column\_name* defines the portion of the record in *data\_file* that is to be compared with the value specified by '*val*' to evaluate as either true or false.

All characters used in the *field\_condition* text (particularly in the *val* string) must be valid in the database encoding. (For performing data conversion, EDB\*Loader first converts the characters in *val* string to the database encoding and then to the data file encoding.)

In the WHEN *field\_condition* \[ AND *field\_condition* \] clause, if all such conditions evaluate to TRUE for a given record, then EDB\*Loader attempts to insert that record into *target\_table*. If the insert operation fails, the record is written to *bad\_file*.

If for a given record, none of the WHEN clauses evaluate to TRUE for all INTO TABLE clauses, the record is written to *discard\_file*, if a discard file was specified for the EDB\*Loader session.

See the description of the NULLIF clause in this Parameters list for the effect of *field\_condition* on this clause.

*termstring*

String of one or more characters that separates each field in *data\_file*. The characters may be single-byte or multi-byte as long as they are valid in the database encoding. Two consecutive appearances of *termstring* with no intervening character results in the corresponding column set to null.

*enclstring*

String of one or more characters used to enclose a field value in *data\_file*. The characters may be single-byte or multi-byte as long as they are valid in the database encoding. Use *enclstring* on fields where *termstring* appears as part of the data.

*delimstring*

String of one or more characters that separates each record in *data\_file*. The characters may be single-byte or multi-byte as long as they are valid in the database encoding. Two consecutive appearances of *delimstring* with no intervening character results in no corresponding row loaded into the table. The last record (in other words, the end of the data file) must also be terminated by the *delimstring* characters, otherwise the final record is not loaded into the table.

**Note:** The RECORDS DELIMITED BY '*delimstring*' clause is not compatible with Oracle databases.

TRAILING NULLCOLS

If TRAILING NULLCOLS is specified, then the columns in the column list for which there is no data in *data\_file* for a given record, are set to null when the row is inserted. This applies only to one or more consecutive columns at the end of the column list.

If fields are omitted at the end of a record and TRAILING NULLCOLS is not specified, EDB\*Loader assumes the record contains formatting errors and writes it to the bad file.

*column\_name*

Name of a column in *target\_table* into which a field value defined by *field\_def* is to be inserted. If the field definition includes the FILLER or BOUNDFILLER clause, then *column\_name* is not required to be the name of a column in the table. It can be any identifier name since the FILLER and BOUNDFILLER clauses prevent the loading of the field data into a table column.

CONSTANT *val*

Specifies a constant that is type-compatible with the column data type to which it is assigned in a field definition. Single or double quotes may enclose *val*. If *val* contains white space, then enclosing quotation marks must be used.

The use of the CONSTANT clause completely determines the value to be assigned to a column in each inserted row. No other clause may appear in the same field definition.

If the TERMINATED BY clause is used to delimit the fields in *data\_file*, there must be no delimited field in *data\_file* corresponding to any field definition with a CONSTANT clause. In other words, EDB\*Loader assumes there is no field in *data\_file* for any field definition with a CONSTANT clause.

FILLER

Specifies that the data in the field defined by the field definition is not to be loaded into the associated column if the identifier of the field definition is an actual column name in the table. In such case, the column is set to null. Use of the FILLER or BOUNDFILLER clause is the only circumstance in which the field definition does not have to be identified by an actual column name.

Unlike the BOUNDFILLER clause, an identifier defined with the FILLER clause must not be referenced in a SQL expression. See the discussion of the *expr* parameter.

BOUNDFILLER

Specifies that the data in the field defined by the field definition is not to be loaded into the associated column if the identifier of the field definition is an actual column name in the table. In such case, the column is set to null. Use of the FILLER or BOUNDFILLER clause is the only circumstance in which the field definition does not have to be identified by an actual column name.

Unlike the FILLER clause, an identifier defined with the BOUNDFILLER clause may be referenced in a SQL expression. See the discussion of the *expr* parameter.

POSITION (*start*:*end*)

Defines the location of the field in a record in a fixed-width field data file. *start* and *end* are positive integers. The first character in the record has a start value of 1.

CHAR \[(*length*)\] | DATE \[(*length*)\] \[ "*datemask*" \] |

INTEGER EXTERNAL \[(*length*)\] |
FLOAT EXTERNAL \[(*length*)\] | DECIMAL EXTERNAL \[(*length*)\] |

ZONED EXTERNAL \[(*length*)\] | ZONED \[(*precision*\[,*scale*\])\]

Field type that describes the format of the data field in *data\_file*.

Note: Specification of a field type is optional (for descriptive purposes only) and has no effect on whether or not EDB\*Loader successfully inserts the data in the field into the table column. Successful loading depends upon the compatibility of the column data type and the field value. For example, a column with data type NUMBER(7,2) successfully accepts a field containing 2600, but if the field contains a value such as 26XX, the insertion fails and the record is written to *bad\_file*.

Please note that ZONED data is not human-readable; ZONED data is stored in an internal format where each digit is encoded in a separate nibble/nybble/4-bit field. In each ZONED value, the last byte contains a single digit (in the high-order 4 bits) and the sign (in the low-order 4 bits).

*length*

Specifies the length of the value to be loaded into the associated column.

If the POSITION (*start*:*end*) clause is specified along with a *fieldtype*(*length*) clause, then the ending position of the field is overridden by the specified *length* value. That is, the length of the value to be loaded into the column is determined by the *length* value beginning at the *start* position, and not by the *end* position of the POSITION (*start*:*end*) clause. Thus, the value to be loaded into the column may be shorter than the field defined by POSITION (*start*:*end*), or it may go beyond the *end* position depending upon the specified *length* size.

If the FIELDS TERMINATED BY '*termstring*' clause is specified as part of the INTO TABLE clause, and a field definition contains the *fieldtype*(*length*) clause, then a record is accepted as long as the specified *length* values are greater than or equal to the field lengths as determined by the *termstring* characters enclosing all such fields of the record. If the specified *length* value is less than a field length as determined by the enclosing *termstring* characters for any such field, then the record is rejected.

If the FIELDS TERMINATED BY '*termstring*' clause is not specified, and the POSITION (*start*:*end*) clause is not included with a field containing the *fieldtype*(*length*) clause, then the starting position of this field begins with the next character following the ending position of the preceding field. The ending position of the preceding field is either the end of its *length* value if the preceding field contains the *fieldtype*(*length*) clause, or by its *end* parameter if the field contains the POSITION (*start*:*end*) clause without the *fieldtype*(*length*) clause.

*precision*

> Use *precision* to specify the length of the ZONED value.
>
> If the *precision* value specified for ZONED conflicts with the length calculated by the server based on information provided with the POSITION clause, EDB\*Loader will use the value specified for *precision*.

*scale*

> *scale* specifies the number of digits to the right of the decimal point in a ZONED value*.*

*datemask*

Specifies the ordering and abbreviation of the day, month, and year components of a date field.

**Note:** If the DATE field type is specified along with a SQL expression for the column, then *datemask* must be specified after DATE and before the SQL expression. See the following discussion of the *expr* parameter.

NULLIF *field\_condition* \[ AND *field\_condition* \] ...

**Note:** See the description of *field\_condition* previously listed in this Parameters section for the syntax of *field\_condition*.

If all field conditions evaluate to TRUE, then the column identified by *column\_name* in the field definition is set to null. If any field condition evaluates to FALSE, then the column is set to the appropriate value as would normally occur according to the field definition.

PRESERVE BLANKS

For the column on which this option appears, retains leading white space when the optional enclosure delimiters are not present and leaves trailing white space intact when fields are specified with a predetermined size. When omitted, the default behavior is to trim leading and trailing white space.

*expr*

A SQL expression returning a scalar value that is type-compatible with the column data type to which it is assigned in a field definition. Double quotes must enclose *expr*. *expr* may contain a reference to any column in the field list (except for fields with the FILLER clause) by prefixing the column name by a colon character (:).

*expr* may also consist of a SQL SELECT statement. If a SELECT statement is used then the following rules must apply: 1) The SELECT statement must be enclosed within parentheses (SELECT ...). 2) The select list must consist of exactly one expression following the SELECT keyword. 3) The result set must not return more than one row. If no rows are returned, then the returned value of the resulting expression is null. The following is the syntax for use of the SELECT statement:

"(SELECT *expr* \[ FROM *table\_list* \[ WHERE *condition* \] \])"

**Note:** Omitting the FROM *table\_list* clause is not compatible with Oracle databases. If no tables need to be specified, use of the FROM DUAL clause is compatible with Oracle databases.

Examples

The following are some examples of control files and their corresponding data files.

***Delimiter-Separated Field Data File***

The following control file uses a delimiter-separated data file that appends rows to the emp table:

LOAD DATA

INFILE 'emp.dat'

BADFILE 'emp.bad'

APPEND

INTO TABLE emp

FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'

TRAILING NULLCOLS

(

empno,

ename,

job,

mgr,

hiredate,

sal,

deptno,

comm

)

In the preceding control file, the APPEND clause is used to allow the insertion of additional rows into the emp table.

The following is the corresponding delimiter-separated data file:

9101,ROGERS,CLERK,7902,17-DEC-10,1980.00,20

9102,PETERSON,SALESMAN,7698,20-DEC-10,2600.00,30,2300.00

9103,WARREN,SALESMAN,7698,22-DEC-10,5250.00,30,2500.00

9104,"JONES, JR.",MANAGER,7839,02-APR-09,7975.00,20

The use of the TRAILING NULLCOLS clause allows the last field supplying the comm column to be omitted from the first and last records. The comm column is set to null for the rows inserted from these records.

The double quotation mark enclosure character surrounds the value JONES, JR. in the last record since the comma delimiter character is part of the field value.

The following query displays the rows added to the table after the EDB\*Loader session:

SELECT \* FROM emp WHERE empno \> 9100;

empno | ename | job | mgr | hiredate | sal | comm | deptno

\-------+------------+----------+------+--------------------+---------+---------+--------

9101 | ROGERS | CLERK | 7902 | 17-DEC-10 00:00:00 | 1980.00 | | 20

9102 | PETERSON | SALESMAN | 7698 | 20-DEC-10 00:00:00 | 2600.00 | 2300.00 | 30

9103 | WARREN | SALESMAN | 7698 | 22-DEC-10 00:00:00 | 5250.00 | 2500.00 | 30

9104 | JONES, JR. | MANAGER | 7839 | 02-APR-09 00:00:00 | 7975.00 | | 20

(4 rows)

***Fixed-Width Field Data File***

The following example is a control file that loads the same rows into the emp table, but uses a data file containing fixed-width fields:

LOAD DATA

INFILE 'emp\_fixed.dat'

BADFILE 'emp\_fixed.bad'

APPEND

INTO TABLE emp

TRAILING NULLCOLS

(

empno POSITION (1:4),

ename POSITION (5:14),

job POSITION (15:23),

mgr POSITION (24:27),

hiredate POSITION (28:38),

sal POSITION (39:46),

deptno POSITION (47:48),

comm POSITION (49:56)

)

In the preceding control file, the FIELDS TERMINATED BY and OPTIONALLY ENCLOSED BY clauses are absent. Instead, each field now includes the POSITION clause.

The following is the corresponding data file containing fixed-width fields:

9101ROGERS CLERK 790217-DEC-10 1980.0020

9102PETERSON SALESMAN 769820-DEC-10 2600.0030 2300.00

9103WARREN SALESMAN 769822-DEC-10 5250.0030 2500.00

9104JONES, JR.MANAGER 783902-APR-09 7975.0020

***Single Physical Record Data File – RECORDS DELIMITED BY Clause***

The following example is a control file that loads the same rows into the emp table, but uses a data file with one physical record. Each individual record that is to be loaded as a row in the table is terminated by the semicolon character (;) specified by the RECORDS DELIMITED BY clause.

LOAD DATA

INFILE 'emp\_recdelim.dat'

BADFILE 'emp\_recdelim.bad'

APPEND

INTO TABLE emp

FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'

RECORDS DELIMITED BY ';'

TRAILING NULLCOLS

(

empno,

ename,

job,

mgr,

hiredate,

sal,

deptno,

comm

)

The following is the corresponding data file. The content is a single, physical record in the data file. The record delimiter character is included following the last record (that is, at the end of the file).

9101,ROGERS,CLERK,7902,17-DEC-10,1980.00,20,;9102,PETERSON,SALESMAN,7698,20-DEC-10,2600.00,30,2300.00;9103,WARREN,SALESMAN,7698,22-DEC-10,5250.00,30,2500.00;9104,"JONES, JR.",MANAGER,7839,02-APR-09,7975.00,20,;

***FILLER Clause***

The following control file illustrates the use of the FILLER clause in the data fields for the sal and comm columns. EDB\*Loader ignores the values in these fields and sets the corresponding columns to null.

LOAD DATA

INFILE 'emp\_fixed.dat'

BADFILE 'emp\_fixed.bad'

APPEND

INTO TABLE emp

TRAILING NULLCOLS

(

empno POSITION (1:4),

ename POSITION (5:14),

job POSITION (15:23),

mgr POSITION (24:27),

hiredate POSITION (28:38),

sal FILLER POSITION (39:46),

deptno POSITION (47:48),

comm FILLER POSITION (49:56)

)

Using the same fixed-width data file as in the prior fixed-width field example, the resulting rows in the table appear as follows:

SELECT \* FROM emp WHERE empno \> 9100;

empno | ename | job | mgr | hiredate | sal | comm | deptno

\-------+------------------+----------+------+--------------------+-----+------+--------

9101 | ROGERS | CLERK | 7902 | 17-DEC-10 00:00:00 | | | 20

9102 | PETERSON | SALESMAN | 7698 | 20-DEC-10 00:00:00 | | | 30

9103 | WARREN | SALESMAN | 7698 | 22-DEC-10 00:00:00 | | | 30

9104 | JONES, JR. | MANAGER | 7839 | 02-APR-09 00:00:00 | | | 20

(4 rows)

***BOUNDFILLER Clause***

The following control file illustrates the use of the BOUNDFILLER clause in the data fields for the job and mgr columns. EDB\*Loader ignores the values in these fields and sets the corresponding columns to null in the same manner as the FILLER clause. However, unlike columns with the FILLER clause, columns with the BOUNDFILLER clause are permitted to be used in an expression as shown for column jobdesc.

LOAD DATA

INFILE 'emp.dat'

BADFILE 'emp.bad'

APPEND

INTO TABLE empjob

FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'

TRAILING NULLCOLS

(

empno,

ename,

job BOUNDFILLER,

mgr BOUNDFILLER,

hiredate FILLER,

sal FILLER,

deptno FILLER,

comm FILLER,

jobdesc ":job || ' for manager ' || :mgr"

)

The following is the delimiter-separated data file used in this example.

9101,ROGERS,CLERK,7902,17-DEC-10,1980.00,20

9102,PETERSON,SALESMAN,7698,20-DEC-10,2600.00,30,2300.00

9103,WARREN,SALESMAN,7698,22-DEC-10,5250.00,30,2500.00

9104,"JONES, JR.",MANAGER,7839,02-APR-09,7975.00,20

The following table is loaded using the preceding control file and data file.

CREATE TABLE empjob (

empno NUMBER(4) NOT NULL CONSTRAINT empjob\_pk PRIMARY KEY,

ename VARCHAR2(10),

job VARCHAR2(9),

mgr NUMBER(4),

jobdesc VARCHAR2(25)

);

The resulting rows in the table appear as follows:

SELECT \* FROM empjob;

empno | ename | job | mgr | jobdesc

\-------+------------+-----+-----+---------------------------

9101 | ROGERS | | | CLERK for manager 7902

9102 | PETERSON | | | SALESMAN for manager 7698

9103 | WARREN | | | SALESMAN for manager 7698

9104 | JONES, JR. | | | MANAGER for manager 7839

(4 rows)

***Field Types with Length Specification***

The following example is a control file that contains the field type clauses with the length specification:

LOAD DATA

INFILE 'emp\_fixed.dat'

BADFILE 'emp\_fixed.bad'

APPEND

INTO TABLE emp

TRAILING NULLCOLS

(

empno CHAR(4),

ename CHAR(10),

job POSITION (15:23) CHAR(9),

mgr INTEGER EXTERNAL(4),

hiredate DATE(11) "DD-MON-YY",

sal DECIMAL EXTERNAL(8),

deptno POSITION (47:48),

comm POSITION (49:56) DECIMAL EXTERNAL(8)

)

Note that the POSITION clause and the *fieldtype*(*length*) clause can be used individually or in combination as long as each field definition contains at least one of the two clauses.

The following is the corresponding data file containing fixed-width fields:

9101ROGERS CLERK 790217-DEC-10 1980.0020

9102PETERSON SALESMAN 769820-DEC-10 2600.0030 2300.00

9103WARREN SALESMAN 769822-DEC-10 5250.0030 2500.00

9104JONES, JR.MANAGER 783902-APR-09 7975.0020

The resulting rows in the table appear as follows:

SELECT \* FROM emp WHERE empno \> 9100;

empno | ename | job | mgr | hiredate | sal | comm | deptno

\-------+------------+----------+------+--------------------+---------+---------+--------

9101 | ROGERS | CLERK | 7902 | 17-DEC-10 00:00:00 | 1980.00 | | 20

9102 | PETERSON | SALESMAN | 7698 | 20-DEC-10 00:00:00 | 2600.00 | 2300.00 | 30

9103 | WARREN | SALESMAN | 7698 | 22-DEC-10 00:00:00 | 5250.00 | 2500.00 | 30

9104 | JONES, JR. | MANAGER | 7839 | 02-APR-09 00:00:00 | 7975.00 | | 20

(4 rows)

***NULLIF Clause***

The following example uses the NULLIF clause on the sal column to set it to null for employees of job MANAGER as well as on the comm column to set it to null if the employee is not a SALESMAN and is not in department 30. In other words, a comm value is accepted if the employee is a SALESMAN or is a member of department 30.

The following is the control file:

LOAD DATA

INFILE 'emp\_fixed\_2.dat'

BADFILE 'emp\_fixed\_2.bad'

APPEND

INTO TABLE emp

TRAILING NULLCOLS

(

empno POSITION (1:4),

ename POSITION (5:14),

job POSITION (15:23),

mgr POSITION (24:27),

hiredate POSITION (28:38),

sal POSITION (39:46) NULLIF job = 'MANAGER',

deptno POSITION (47:48),

comm POSITION (49:56) NULLIF job \<\> 'SALESMAN' AND deptno \<\> '30'

)

The following is the corresponding data file:

9101ROGERS CLERK 790217-DEC-10 1980.0020

9102PETERSON SALESMAN 769820-DEC-10 2600.0030 2300.00

9103WARREN SALESMAN 769822-DEC-10 5250.0030 2500.00

9104JONES, JR.MANAGER 783902-APR-09 7975.0020

9105ARNOLDS CLERK 778213-SEP-10 3750.0030 800.00

9106JACKSON ANALYST 756603-JAN-11 4500.0040 2000.00

9107MAXWELL SALESMAN 769820-DEC-10 2600.0010 1600.00

The resulting rows in the table appear as follows:

SELECT empno, ename, job, NVL(TO\_CHAR(sal),'--null--') "sal",

NVL(TO\_CHAR(comm),'--null--') "comm", deptno FROM emp WHERE empno \> 9100;

empno | ename | job | sal | comm | deptno

\-------+------------+----------+----------+----------+--------

9101 | ROGERS | CLERK | 1980.00 | --null-- | 20

9102 | PETERSON | SALESMAN | 2600.00 | 2300.00 | 30

9103 | WARREN | SALESMAN | 5250.00 | 2500.00 | 30

9104 | JONES, JR. | MANAGER | --null-- | --null-- | 20

9105 | ARNOLDS | CLERK | 3750.00 | 800.00 | 30

9106 | JACKSON | ANALYST | 4500.00 | --null-- | 40

9107 | MAXWELL | SALESMAN | 2600.00 | 1600.00 | 10

(7 rows)

Note that the sal column for employee JONES, JR. is null since the job is MANAGER.

The comm values from the data file for employees PETERSON, WARREN, ARNOLDS, and MAXWELL are all loaded into the comm column of the emp table since these employees are either SALESMAN or members of department 30.

The comm value of 2000.00 in the data file for employee JACKSON is ignored and the comm column of the emp table set to null since this employee is neither a SALESMAN nor is a member of department 30.

***SELECT Statement in a Field Expression***

The following example uses a SELECT statement in the expression of the field definition to return the value to be loaded into the column.

LOAD DATA

INFILE 'emp\_fixed.dat'

BADFILE 'emp\_fixed.bad'

APPEND

INTO TABLE emp

TRAILING NULLCOLS

(

empno POSITION (1:4),

ename POSITION (5:14),

job POSITION (15:23) "(SELECT dname FROM dept WHERE deptno = :deptno)",

mgr POSITION (24:27),

hiredate POSITION (28:38),

sal POSITION (39:46),

deptno POSITION (47:48),

comm POSITION (49:56)

)

The content of the dept table used in the SELECT statement is the following:

SELECT \* FROM dept;

deptno | dname | loc

\--------+------------+----------

10 | ACCOUNTING | NEW YORK

20 | RESEARCH | DALLAS

30 | SALES | CHICAGO

40 | OPERATIONS | BOSTON

(4 rows)

The following is the corresponding data file:

9101ROGERS CLERK 790217-DEC-10 1980.0020

9102PETERSON SALESMAN 769820-DEC-10 2600.0030 2300.00

9103WARREN SALESMAN 769822-DEC-10 5250.0030 2500.00

9104JONES, JR.MANAGER 783902-APR-09 7975.0020

The resulting rows in the table appear as follows:

SELECT \* FROM emp WHERE empno \> 9100;

empno | ename | job | mgr | hiredate | sal | comm | deptno

\-------+------------+----------+------+--------------------+---------+---------+--------

9101 | ROGERS | RESEARCH | 7902 | 17-DEC-10 00:00:00 | 1980.00 | | 20

9102 | PETERSON | SALES | 7698 | 20-DEC-10 00:00:00 | 2600.00 | 2300.00 | 30

9103 | WARREN | SALES | 7698 | 22-DEC-10 00:00:00 | 5250.00 | 2500.00 | 30

9104 | JONES, JR. | RESEARCH | 7839 | 02-APR-09 00:00:00 | 7975.00 | | 20

(4 rows)

Note that the job column contains the value from the dname column of the dept table returned by the SELECT statement instead of the job name from the data file.

***Multiple INTO TABLE Clauses***

The following example illustrates the use of multiple INTO TABLE clauses. For this example, two empty tables are created with the same data definition as the emp table. The following CREATE TABLE commands create these two empty tables, while inserting no rows from the original emp table:

CREATE TABLE emp\_research AS SELECT \* FROM emp WHERE deptno = 99;

CREATE TABLE emp\_sales AS SELECT \* FROM emp WHERE deptno = 99;

The following control file contains two INTO TABLE clauses. Also note that there is no APPEND clause so the default operation of INSERT is used, which requires that tables emp\_research and emp\_sales be empty.

LOAD DATA

INFILE 'emp\_multitbl.dat'

BADFILE 'emp\_multitbl.bad'

DISCARDFILE 'emp\_multitbl.dsc'

INTO TABLE emp\_research

WHEN (47:48) = '20'

TRAILING NULLCOLS

(

empno POSITION (1:4),

ename POSITION (5:14),

job POSITION (15:23),

mgr POSITION (24:27),

hiredate POSITION (28:38),

sal POSITION (39:46),

deptno CONSTANT '20',

comm POSITION (49:56)

)

INTO TABLE emp\_sales

WHEN (47:48) = '30'

TRAILING NULLCOLS

(

empno POSITION (1:4),

ename POSITION (5:14),

job POSITION (15:23),

mgr POSITION (24:27),

hiredate POSITION (28:38),

sal POSITION (39:46),

deptno CONSTANT '30',

comm POSITION (49:56) "ROUND(:comm + (:sal \* .25), 0)"

)

The WHEN clauses specify that when the field designated by columns 47 thru 48 contains 20, the record is inserted into the emp\_research table and when that same field contains 30, the record is inserted into the emp\_sales table. If neither condition is true, the record is written to the discard file named emp\_multitbl.dsc.

The CONSTANT clause is given for column deptno so the specified constant value is inserted into deptno for each record. When the CONSTANT clause is used, it must be the only clause in the field definition other than the column name to which the constant value is assigned.

Finally, column comm of the emp\_sales table is assigned a SQL expression. Column names may be referenced in the expression by prefixing the column name with a colon character (:).

The following is the corresponding data file:

9101ROGERS CLERK 790217-DEC-10 1980.0020

9102PETERSON SALESMAN 769820-DEC-10 2600.0030 2300.00

9103WARREN SALESMAN 769822-DEC-10 5250.0030 2500.00

9104JONES, JR.MANAGER 783902-APR-09 7975.0020

9105ARNOLDS CLERK 778213-SEP-10 3750.0010

9106JACKSON ANALYST 756603-JAN-11 4500.0040

Since the records for employees ARNOLDS and JACKSON contain 10 and 40 in columns 47 thru 48, which do not satisfy any of the WHEN clauses, EDB\*Loader writes these two records to the discard file, emp\_multitbl.dsc, whose content is shown by the following:

9105ARNOLDS CLERK 778213-SEP-10 3750.0010

9106JACKSON ANALYST 756603-JAN-11 4500.0040

The following are the rows loaded into the emp\_research and emp\_sales tables:

SELECT \* FROM emp\_research;

empno | ename | job | mgr | hiredate | sal | comm | deptno

\-------+------------+---------+------+--------------------+---------+------+--------

9101 | ROGERS | CLERK | 7902 | 17-DEC-10 00:00:00 | 1980.00 | | 20.00

9104 | JONES, JR. | MANAGER | 7839 | 02-APR-09 00:00:00 | 7975.00 | | 20.00

(2 rows)

SELECT \* FROM emp\_sales;

empno | ename | job | mgr | hiredate | sal | comm | deptno

\-------+----------+----------+------+--------------------+---------+---------+--------

9102 | PETERSON | SALESMAN | 7698 | 20-DEC-10 00:00:00 | 2600.00 | 2950.00 | 30.00

9103 | WARREN | SALESMAN | 7698 | 22-DEC-10 00:00:00 | 5250.00 | 3813.00 | 30.00

(2 rows)

## Invoking EDB\*Loader

You must have superuser privileges to run EDB\*Loader. Use the following command to invoke EDB\*Loader from the command line:

edbldr \[ -d *dbname* \] \[ -p *port* \] \[ -h *host* \]

\[ USERID={ *username*/*password* | *username*/ | *username* | / } \]

CONTROL=*control\_file*

\[ DATA=*data\_file* \]

\[ BAD=*bad\_file* \]

\[ DISCARD=*discard\_file* \]

\[ DISCARDMAX=*max\_discard\_recs* \]

\[ LOG=*log\_file* \]

\[ PARFILE=*param\_file* \]

\[ DIRECT={ FALSE | TRUE } \]

\[ FREEZE={ FALSE | TRUE } \]

\[ ERRORS=*error\_count* \]

\[ PARALLEL={ FALSE | TRUE } \]

\[ ROWS=*n* \]

\[ SKIP=*skip\_count* \]

\[ SKIP\_INDEX\_MAINTENANCE={ FALSE | TRUE } \]

\[ edb\_resource\_group=*group\_name* \]

Description

If the -d option, the -p option, or the -h option are omitted, the defaults for the database, port, and host are determined according to the same rules as other Advanced Server utility programs such as edb-psql, for example.

Any parameter listed in the preceding syntax diagram except for the -d option, -p option, -h option, and the PARFILE parameter may be specified in a *parameter file*. The parameter file is specified on the command line when edbldr is invoked using PARFILE=*param\_file*. Some parameters may be specified in the OPTIONS clause in the control file. See the description of the control file in Section <span class="underline">2.3</span>.

The specification of *control\_file*, *data\_file*, *bad\_file*, *discard\_file*, *log\_file*, and *param\_file* may include the full directory path or a relative directory path to the file name. If the file name is specified alone or with a relative directory path, the file is assumed to exist (in the case of *control\_file*, *data\_file*, or *param\_file*), or to be created (in the case of *bad\_file*, *discard\_file*, or *log\_file*) relative to the current working directory from which edbldr is invoked.

**Note:** The control file must exist in the character set encoding of the client where edbldr is invoked. If the client is in a different encoding than the database encoding, then the PGCLIENTENCODING environment variable must be set on the client to the client’s encoding prior to invoking edbldr. This must be done to ensure character set conversion is properly done between the client and the database server.

The operating system account used to invoke edbldr must have read permission on the directories and files specified by *control\_file*, *data\_file*, and *param\_file*.

The operating system account enterprisedb must have write permission on the directories where *bad\_file*, *discard\_file*, and *log\_file* are to be written.

**Note:** It is suggested that the file names for *control\_file*, *data\_file*, *bad\_file*, *discard\_file*, and *log\_file* include extensions of .ctl, .dat, .bad, .dsc, and .log, respectively. If the provided file name does not contain an extension, EDB\*Loader assumes the actual file name includes the appropriate aforementioned extension.

Parameters

*dbname*

Name of the database containing the tables to be loaded.

*port*

Port number on which the database server is accepting connections.

*host*

IP address of the host on which the database server is running.

USERID={ *username*/*password* | *username*/ | *username* | / }

EDB\*Loader connects to the database with *username*. *username* must be a superuser. *password* is the password for *username*.

If the USERID parameter is omitted, EDB\*Loader prompts for *username* and *password*. If USERID=*username*/ is specified, then EDB\*Loader 1) uses the password file specified by environment variable PGPASSFILE if PGPASSFILE is set, or 2) uses the .pgpass password file (pgpass.conf on Windows systems) if PGPASSFILE is not set. If USERID=*username* is specified, then EDB\*Loader prompts for *password*. If USERID=/ is specified, the connection is attempted using the operating system account as the user name.

**Note:** The Advanced Server connection environment variables PGUSER and PGPASSWORD are ignored by EDB\*Loader. See the PostgreSQL core documentation for information on the PGPASSFILE environment variable and the password file.

CONTROL=*control\_file*

*control\_file* specifies the name of the control file containing EDB\*Loader directives. If a file extension is not specified, an extension of .ctl is assumed. See Section <span class="underline">2.3</span> for a description of the control file.

DATA=*data\_file*

*data\_file* specifies the name of the file containing the data to be loaded into the target table. If a file extension is not specified, an extension of .dat is assumed. See Section <span class="underline">2.3</span> for a description of the *data\_file*.

**Note:** Specifying a *data\_file* on the command line overrides the INFILE clause specified in the control file.

BAD=*bad\_file*

*bad\_file* specifies the name of a file that receives input data records that cannot be loaded due to errors. See Section <span class="underline">2.3</span> for a description of the *bad\_file*.

**Note:** Specifying a *bad\_file* on the command line overrides any BADFILE clause specified in the control file.

DISCARD=*discard\_file*

*discard\_file* is the name of the file that receives input data records that do not meet any table’s selection criteria. See the description of *discard\_file* in Section <span class="underline">2.3</span>.

**Note:** Specifying a *discard\_file* using the command line DISCARD parameter overrides the DISCARDFILE clause in the control file.

DISCARDMAX=*max\_discard\_recs*

*max\_discard\_recs* is the maximum number of discarded records that may be encountered from the input data records before terminating the EDB\*Loader session. See the description of *max\_discard\_recs* in Section<span class="underline">2.3</span>.

**Note:** Specifying *max\_discard\_recs* using the command line DISCARDMAX parameter overrides the DISCARDMAX or DISCARDS clause in the control file.

LOG=*log\_file*

*log\_file* specifies the name of the file in which EDB\*Loader records the results of the EDB\*Loader session.

If the LOG parameter is omitted, EDB\*Loader creates a log file with the name *control\_file\_base*.log in the directory from which edbldr is invoked. *control\_file\_base* is the base name of the control file used in the EDB\*Loader session. The operating system account enterprisedb must have write permission on the directory where the log file is to be written.

PARFILE=*param\_file*

*param\_file* specifies the name of the file that contains command line parameters for the EDB\*Loader session. Any command line parameter listed in this section except for the -d, -p, and -h options, and the PARFILE parameter itself, can be specified in *param\_file* instead of on the command line.

Any parameter given in *param\_file* overrides the same parameter supplied on the command line before the PARFILE option. Any parameter given on the command line that appears after the PARFILE option overrides the same parameter given in *param\_file*.

**Note:** Unlike other EDB\*Loader files, there is no default file name or extension assumed for *param\_file*, though by Oracle SQL\*Loader convention, .par is typically used, but not required, as an extension.

DIRECT= { FALSE | TRUE }

If DIRECT is set to TRUE EDB\*Loader performs a direct path load instead of a conventional path load. The default value of DIRECT is FALSE.

See Section <span class="underline">2.5</span> for information on direct path loads.

FREEZE= { FALSE | TRUE }

> Set FREEZE to TRUE to indicate that the data should be copied with the rows *frozen*. A tuple guaranteed to be visible to all current and future transactions is marked as frozen to prevent transaction ID wrap-around. For more information about frozen tuples, see the PostgreSQL core documentation at:
>
> <https://www.postgresql.org/docs/10/static/routine-vacuuming.html>
>
> You must specify a data-loading type of TRUNCATE in the control file when using the FREEZE option. FREEZE is not supported for direct loading.
>
> By default, FREEZE is FALSE.

ERRORS=*error\_count*

*error\_count* specifies the number of errors permitted before aborting the EDB\*Loader session. The default is 50.

PARALLEL= { FALSE | TRUE }

Set PARALLEL to TRUE to indicate that this EDB\*Loader session is one of a number of concurrent EDB\*Loader sessions participating in a parallel direct path load. The default value of PARALLEL is FALSE.

When PARALLEL is TRUE, the DIRECT parameter must also be set to TRUE . See Section <span class="underline">2.5.1</span> for more information about parallel direct path loads.

ROWS=*n*

*n* specifies the number of rows that EDB\*Loader will commit before loading the next set of *n* rows.

SKIP=*skip\_count*

Number of records at the beginning of the input data file that should be skipped before loading begins. The default is 0.

SKIP\_INDEX\_MAINTENANCE= { FALSE | TRUE }

If set to TRUE, index maintenance is not performed as part of a direct path load, and indexes on the loaded table are marked as invalid. The default value of SKIP\_INDEX\_MAINTENANCE is FALSE.

Please note: During a parallel direct path load, target table indexes are not updated, and are marked as invalid after the load is complete.

You can use the REINDEX command to rebuild an index. For more information about the REINDEX command, see the PostgreSQL core documentation available at:

<https://www.postgresql.org/docs/10/static/sql-reindex.html>

edb\_resource\_group=*group\_name*

*group\_name* specifies the name of an EDB Resource Manager resource group to which the EDB\*Loader session is to be assigned.

Any default resource group that may have been assigned to the session (for example, a database user running the EDB\*Loader session who had been assigned a default resource group with the ALTER ROLE ... SET edb\_resource\_group command) is overridden by the resource group given by the edb\_resource\_group parameter specified on the edbldr command line.

Examples

In the following example EDB\*Loader is invoked using a control file named emp.ctl located in the current working directory to load a table in database edb:

$ /opt/edb/as10/bin/edbldr -d edb USERID=enterprisedb/password CONTROL=emp.ctl

EDB\*Loader: Copyright (c) 2007-2017, EnterpriseDB Corporation.

Successfully loaded (4) records

In the following example, EDB\*Loader prompts for the user name and password since they are omitted from the command line. In addition, the files for the bad file and log file are specified with the BAD and LOG command line parameters.

$ /opt/edb/as10/bin/edbldr -d edb CONTROL=emp.ctl BAD=/tmp/emp.bad LOG=/tmp/emp.log

Enter the user name : enterprisedb

Enter the password :

EDB\*Loader: Copyright (c) 2007-2017, EnterpriseDB Corporation.

Successfully loaded (4) records

The following example runs EDB\*Loader with the same parameters as shown in the preceding example, but using a parameter file located in the current working directory. The SKIP and ERRORS parameters are altered from their defaults in the parameter file as well. The parameter file, emp.par, contains the following:

CONTROL=emp.ctl

BAD=/tmp/emp.bad

LOG=/tmp/emp.log

SKIP=1

ERRORS=10

EDB\*Loader is invoked with the parameter file as shown by the following:

$ /opt/edb/as10/bin/edbldr -d edb PARFILE=emp.par

Enter the user name : enterprisedb

Enter the password :

EDB\*Loader: Copyright (c) 2007-2017, EnterpriseDB Corporation.

Successfully loaded (3) records

### Exit Codes

When EDB\*Loader exits, it will return one of the following codes:

| Exit Code | Description                                                                                                                                                             |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 0         | Indicates that all rows loaded successfully.                                                                                                                            |
| 1         | Indicates that EDB\*Loader encountered command line or syntax errors, or aborted the load operation due to an unrecoverable error.                                      |
| 2         | Indicates that the load completed, but some (or all) rows were rejected or discarded.                                                                                   |
| 3         | Indicates that EDB\*Loader encountered fatal errors (such as OS errors). This class of errors is equivalent to the FATAL or PANIC severity levels of PostgreSQL errors. |

## Direct Path Load

During a direct path load, EDB\*Loader writes the data directly to the database pages, which is then synchronized to disk. The insert processing associated with a conventional path load is bypassed, thereby resulting in a performance improvement.

Bypassing insert processing reduces the types of constraints that may exist on the target table. The following types of constraints are permitted on the target table of a direct path load:
 - Primary key
 - Not null constraints
 - Indexes (unique or non-unique)

The restrictions on the target table of a direct path load are the following:
 - Triggers are not permitted
 - Check constraints are not permitted
 - Foreign key constraints on the target table referencing another table are not permitted
 - Foreign key constraints on other tables referencing the target table are not permitted
 - The table must not be partitioned
 - Rules may exist on the target table, but they are not executed

**Note:** Currently, a direct path load in EDB\*Loader is more restrictive than in Oracle SQL\*Loader. The preceding restrictions do not apply to Oracle SQL\*Loader in most cases. The following restrictions apply to a control file used in a direct path load:
 - Multiple table loads are not supported. That is, only one INTO TABLE clause may be specified in the control file.
 - SQL expressions may not be used in the data field definitions of the INTO TABLE clause.
 - The FREEZE option is not supported for direct path loading.

To run a direct path load, add the DIRECT=TRUE option as shown by the following example:

$ /opt/edb/as10/bin/edbldr -d edb USERID=enterprisedb/password CONTROL=emp.ctl DIRECT=TRUE

EDB\*Loader: Copyright (c) 2007-2017, EnterpriseDB Corporation.

Successfully loaded (4) records

### Direct Loading Limitations

During a direct load, EDB\*Loader has the following limitations:
 - Direct loading only supports loading data to empty tables.
 - Direct loading into multiple tables simultaneously is also not supported currently.
 - If you are using PITR, you must take a full backup of the database when loading is complete. During a direct load EDB\*Loader bypasses any WAL file updates, making a PITR recovery after a load invalid until the full backup is updated.
 - Only unique constraints are enforced during the load; other constraints (i.e. NULL or referential integrity constraints) are not enforced.

**Note**: These limitations do not apply while using conventional loading
(i.e. direct=false).

## Parallel Direct Path Load

The performance of a direct path load can be further improved by distributing the loading process over two or more sessions running concurrently. Each session runs a direct path load into the same table.

Since the same table is loaded from multiple sessions, the input records to be loaded into the table must be divided amongst several data files so that each EDB\*Loader session uses its own data file and the same record is not loaded more than once into the table.

The target table of a parallel direct path load is under the same restrictions as a direct path load run in a single session.

The restrictions on the target table of a direct path load are the following:
 - Triggers are not permitted
 - Check constraints are not permitted
 - Foreign key constraints on the target table referencing another table are not permitted
 - Foreign key constraints on other tables referencing the target table are not permitted
 - The table must not be partitioned
 - Rules may exist on the target table, but they are not executed

In addition, the APPEND clause must be specified in the control file used by each EDB\*Loader session.

To run a parallel direct path load, run EDB\*Loader in a separate session for each participant of the parallel direct path load. Invocation of each such EDB\*Loader session must include the DIRECT=TRUE and PARALLEL=TRUE parameters.

Each EDB\*Loader session runs as an independent transaction so if one of the parallel sessions aborts and rolls back its changes, the loading done by the other parallel sessions are not affected.

**Note:** In a parallel direct path load, each EDB\*Loader session reserves a fixed number of blocks in the target table in a round-robin fashion. Some of the blocks in the last allocated chunk may not be used, and those blocks remain uninitialized. A subsequent use of the VACUUM command on the target table may show warnings regarding these uninitialized blocks such as the following:

WARNING: relation "emp" page 98264 is uninitialized --- fixing

WARNING: relation "emp" page 98265 is uninitialized --- fixing

WARNING: relation "emp" page 98266 is uninitialized --- fixing

This is an expected behavior and does not indicate data corruption.

Indexes on the target table are not updated during a parallel direct path load and are therefore marked as invalid after the load is complete. You must use the REINDEX command to rebuild the indexes.

The following example shows the use of a parallel direct path load on the emp table.

**Note:** If you attempt a parallel direct path load on the sample emp table provided with Advanced Server, you must first remove the triggers and constraints referencing the emp table. In addition the primary key column, empno, was expanded from NUMBER(4) to NUMBER in this example to allow for the insertion of a larger number of rows.

The following is the control file used in the first session:

LOAD DATA

INFILE '/home/user/loader/emp\_parallel\_1.dat'

APPEND

INTO TABLE emp

FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'

TRAILING NULLCOLS

(

empno,

ename,

job,

mgr,

hiredate,

sal,

deptno,

comm

)

The APPEND clause must be specified in the control file for a parallel direct path load.

The following shows the invocation of EDB\*Loader in the first session. The DIRECT=TRUE and PARALLEL=TRUE parameters must be specified.

$ /opt/edb/as10/bin/edbldr -d edb USERID=enterprisedb/password CONTROL=emp\_parallel\_1.ctl DIRECT=TRUE PARALLEL=TRUE

WARNING: index maintenance will be skipped with PARALLEL load

EDB\*Loader: Copyright (c) 2007-2017, EnterpriseDB Corporation.

The control file used for the second session appears as follows. Note that it is the same as the one used in the first session, but uses a different data file.

LOAD DATA

INFILE '/home/user/loader/emp\_parallel\_2.dat'

APPEND

INTO TABLE emp

FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'

TRAILING NULLCOLS

(

empno,

ename,

job,

mgr,

hiredate,

sal,

deptno,

comm

)

The preceding control file is used in a second session as shown by the following:

$ /opt/edb/as10/bin/edbldr -d edb USERID=enterprisedb/password CONTROL=emp\_parallel\_2.ctl DIRECT=TRUE PARALLEL=TRUE

WARNING: index maintenance will be skipped with PARALLEL load

EDB\*Loader: Copyright (c) 2007-2017, EnterpriseDB Corporation.

EDB\*Loader displays the following message in each session when its respective load operation completes:

Successfully loaded (10000) records

The following query shows that the index on the emp table has been marked as INVALID:

SELECT index\_name, status FROM user\_indexes WHERE table\_name = 'EMP';

index\_name | status

\------------+---------

EMP\_PK | INVALID

(1 row)

**Note:** user\_indexes is the view of indexes compatible with Oracle databases owned by the current user.

Queries on the emp table will not utilize the index unless it is rebuilt using the REINDEX command as shown by the following:

REINDEX INDEX emp\_pk;

A subsequent query on user\_indexes shows that the index is now marked as VALID:

SELECT index\_name, status FROM user\_indexes WHERE table\_name = 'EMP';

index\_name | status

\------------+--------

EMP\_PK | VALID

(1 row)

## Remote Loading

EDB\*Loader supports a feature called *remote loading*. In remote loading, the database containing the table to be loaded is running on a database server on a different host than from where EDB\*Loader is invoked with the input data source.

This feature is useful if you have a large amount of data to be loaded, and you do not want to create a large data file on the host running the database server.

In addition, you can use the standard input feature to pipe the data from the data source such as another program or script, directly to EDB\*Loader, which then loads the table in the remote database. This bypasses the process of having to create a data file on disk for EDB\*Loader.

Performing remote loading along with using standard input requires the following:
 - The edbldr program must be installed on the client host on which it is to be invoked with the data source for the EDB\*Loader session.
 - The control file must contain the clause INFILE 'stdin' so you can pipe the data directly into EDB\*Loader’s standard input. See Section <span class="underline">2.3</span> for information on the INFILE clause and the EDB\*Loader control file.
 - All files used by EDB\*Loader such as the control file, bad file, discard file, and log file must reside on, or are created on, the client host on which edbldr is invoked.
 - When invoking EDB\*Loader, use the -h option to specify the IP address of the remote database server. See Section <span class="underline">2.4</span> for information on invoking EDB\*Loader.
 - Use the operating system pipe operator (|) or input redirection operator (\<) to supply the input data to EDB\*Loader.

The following example loads a database running on a database server at 192.168.1.14 using data piped from a source named datasource.

datasource | ./edbldr -d edb -h 192.168.1.14 USERID=enterprisedb/password CONTROL=remote.ctl

The following is another example of how standard input can be used:

./edbldr -d edb -h 192.168.1.14 USERID=enterprisedb/password CONTROL=remote.ctl \< datasource

## Updating a Table with a Conventional Path Load

You can use EDB\*Loader with a conventional path load to update the rows within a table, merging new data with the existing data. When you invoke EDB\*Loader to perform an update, the server searches the table for an existing row with a matching primary key:
 - If the server locates a row with a matching key, it replaces the existing row with the new row.
 - If the server does not locate a row with a matching key, it adds the new row to the table.

To use EDB\*Loader to update a table, the table must have a primary key. Please note that you cannot use EDB\*Loader to UPDATE a partitioned table.

To perform an UPDATE, use the same steps as when performing a conventional path load:

1.  Create a data file that contains the rows you wish to UPDATE or INSERT.

2.  Define a control file that uses the INFILE keyword to specify the name of the data file. For information about building the EDB\*Loader control file, see Section <span class="underline">2.3</span>.

3.  Invoke EDB\*Loader, specifying the database name, connection information, and the name of the control file. For information about invoking EDB\*Loader, see Section <span class="underline">2.4</span>.

The following example uses the emp table that is distributed with the Advanced Server sample data. By default, the table contains:

edb=\# select \* from emp;

empno|ename | job | mgr | hiredate | sal | comm | deptno

\-----+------+---------+------+--------------------+---------+-------+--------

7369 |SMITH |CLERK | 7902 | 17-DEC-80 00:00:00 | 800.00 | | 20

7499 |ALLEN |SALESMAN | 7698 | 20-FEB-81 00:00:00 | 1600.00 |300.00 | 30

7521 |WARD |SALESMAN | 7698 | 22-FEB-81 00:00:00 | 1250.00 |500.00 | 30

7566 |JONES |MANAGER | 7839 | 02-APR-81 00:00:00 | 2975.00 | | 20

7654 |MARTIN|SALESMAN | 7698 | 28-SEP-81 00:00:00 | 1250.00 |1400.00| 30

7698 |BLAKE |MANAGER | 7839 | 01-MAY-81 00:00:00 | 2850.00 | | 30

7782 |CLARK |MANAGER | 7839 | 09-JUN-81 00:00:00 | 2450.00 | | 10

7788 |SCOTT |ANALYST | 7566 | 19-APR-87 00:00:00 | 3000.00 | | 20

7839 |KING |PRESIDENT| | 17-NOV-81 00:00:00 | 5000.00 | | 10

7844 |TURNER|SALESMAN | 7698 | 08-SEP-81 00:00:00 | 1500.00 | 0.00 | 30

7876 |ADAMS |CLERK | 7788 | 23-MAY-87 00:00:00 | 1100.00 | | 20

7900 |JAMES |CLERK | 7698 | 03-DEC-81 00:00:00 | 950.00 | | 30

7902 |FORD |ANALYST | 7566 | 03-DEC-81 00:00:00 | 3000.00 | | 20

7934 |MILLER|CLERK | 7782 | 23-JAN-82 00:00:00 | 1300.00 | | 10

(14 rows)

The following control file (emp\_update.ctl) specifies the fields in the table in a comma-delimited list. The control file performs an UPDATE on the emp table:

LOAD DATA

INFILE 'emp\_update.dat'

BADFILE 'emp\_update.bad'

DISCARDFILE 'emp\_update.dsc'

UPDATE INTO TABLE emp

FIELDS TERMINATED BY ","

(empno, ename, job, mgr, hiredate, sal, comm, deptno)

The data that is being updated or inserted is saved in the emp\_update.dat file. emp\_update.dat contains:

7521,WARD,MANAGER,7839,22-FEB-81 00:00:00,3000.00,0.00,30

7566,JONES,MANAGER,7839,02-APR-81 00:00:00,3500.00,0.00,20

7903,BAKER,SALESMAN,7521,10-JUN-13 00:00:00,1800.00,500.00,20

7904,MILLS,SALESMAN,7839,13-JUN-13 00:00:00,1800.00,500.00,20

7654,MARTIN,SALESMAN,7698,28-SEP-81 00:00:00,1500.00,400.00,30

Invoke EDB\*Loader, specifying the name of the database (edb), the name of a database superuser (and their associated password) and the name of the control file (emp\_update.ctl):

edbldr -d edb userid=*user\_name*/*password* control=emp\_update.ctl

After performing the update, the emp table contains:

edb=\# select \* from emp;

empno|ename | job | mgr | hiredate | sal | comm | deptno

\-----+------+---------+------+--------------------+---------+-------+--------

7369 |SMITH |CLERK | 7902 | 17-DEC-80 00:00:00 | 800.00 | | 20

7499 |ALLEN |SALESMAN | 7698 | 20-FEB-81 00:00:00 | 1600.00 |300.00 | 30

7521 |WARD |MANAGER | 7839 | 22-FEB-81 00:00:00 | 3000.00 |0.00 | 30

7566 |JONES |MANAGER | 7839 | 02-APR-81 00:00:00 | 3500.00 |0.00 | 20

7654 |MARTIN|SALESMAN | 7698 | 28-SEP-81 00:00:00 | 1500.00 |400.00 | 30

7698 |BLAKE |MANAGER | 7839 | 01-MAY-81 00:00:00 | 2850.00 | | 30

7782 |CLARK |MANAGER | 7839 | 09-JUN-81 00:00:00 | 2450.00 | | 10

7788 |SCOTT |ANALYST | 7566 | 19-APR-87 00:00:00 | 3000.00 | | 20

7839 |KING |PRESIDENT| | 17-NOV-81 00:00:00 | 5000.00 | | 10

7844 |TURNER|SALESMAN | 7698 | 08-SEP-81 00:00:00 | 1500.00 | 0.00 | 30

7876 |ADAMS |CLERK | 7788 | 23-MAY-87 00:00:00 | 1100.00 | | 20

7900 |JAMES |CLERK | 7698 | 03-DEC-81 00:00:00 | 950.00 | | 30

7902 |FORD |ANALYST | 7566 | 03-DEC-81 00:00:00 | 3000.00 | | 20

7903 |BAKER |SALESMAN |7521 | 10-JUN-13 00:00:00 | 1800.00 |500.00 | 20

7904 |MILLS |SALESMAN |7839 |13-JUN-13 00:00:00 |1800.00 |500.00 | 20

7934 |MILLER|CLERK | 7782 | 23-JAN-82 00:00:00 | 1300.00 | | 10

(16 rows)

The rows containing information for the three employees that are currently in the emp table are updated, while rows are added for the new employees (BAKER and MILLS)

