---
title: Object Types and Objects
---


This chapter discusses how object-oriented programming techniques can be exploited in SPL. Object-oriented programming as seen in programming languages such as Java and C++ centers on the concept of objects. An *object* is a representation of a real-world entity such as a person, place, or thing. The generic description or definition of a particular object such as a person for example, is called an *object type*. Specific people such as “Joe” or “Sally” are said to be *objects of object type*, person, or equivalently, *instances* of the object type, person, or simply, person objects.

**Note:** The terms “database objects” and “objects” that have been used in this document up to this point should not be confused with an object type and object as used in this chapter. The previous usage of these terms relates to the entities that can be created in a database such as tables, views, indexes, users, etc. Within the context of this chapter, object type and object refer to specific data structures supported by the SPL programming language to implement object-oriented concepts.

**Note:** In Oracle, the term *abstract data type* (ADT) is used to describe object types in PL/SQL. The SPL implementation of object types is intended to be compatible with Oracle abstract data types.

**Note:** Advanced Server has not yet implemented support for some features of object-oriented programming languages. This chapter documents only those features that have been implemented.

## Basic Object Concepts

An object type is a description or definition of some entity. This definition of an object type is characterized by two components:
 - *Attributes* – fields that describe particular characteristics of an object instance. For a person object, examples might be name, address, gender, date of birth, height, weight, eye color, occupation, etc.
 - *Methods* – programs that perform some type of function or operation on, or related to an object. For a person object, examples might be calculating the person’s age, displaying the person’s attributes, changing the values assigned to the person’s attributes, etc.

The following sections elaborate on some basic object concepts.

### Attributes

Every object type must contain at least one attribute. The data type of an attribute can be any of the following:
 - A base data type such as NUMBER, VARCHAR2, etc.
 - Another object type
 - A globally defined collection type (created by the CREATE TYPE command) such as a nested table or varray

An attribute gets its initial value (which may be null) when an object instance is initially created. Each object instance has its own set of attribute values.

### Methods

Methods are SPL procedures or functions defined within an object type. Methods can be categorized into three general types:
 - *Member Methods* – procedures or functions that operate within the context of an object instance. Member methods have access to, and can change the attributes of the object instance on which they are operating.
 - *Static Methods* – procedures or functions that operate independently of any particular object instance. Static methods do not have access to, and cannot change the attributes of an object instance.
 - *Constructor Methods* – functions used to create an instance of an object type. A default constructor method is always provided when an object type is defined.

### Overloading Methods

In an object type it is permissible to define two or more identically named methods of the same type (this is, either a procedure or function), but with different signatures. Such methods are referred to as *overloaded* methods.

A method’s signature consists of the number of formal parameters, the data types of its formal parameters, and their order.

## Object Type Components

Object types are created and stored in the database by using the following two constructs of the SPL language:
 - The *object type specification* - This is the public interface specifying the attributes and method signatures of the object type.
 - The *object type body* - This contains the implementation of the methods specified in the object type specification.

The following sections describe the commands used to create the object type specification and the object type body.

### Object Type Specification Syntax

The following is the syntax of the object type specification:

CREATE \[ OR REPLACE \] TYPE *name*

\[ AUTHID { DEFINER | CURRENT\_USER } \]

{ IS | AS } OBJECT

( { *attribute* { *datatype* | *objtype* | *collecttype* } }

\[, ...\]

\[ *method\_spec* \] \[, ...\]

\[ *constructor* \] \[, ...\]

) \[ \[ NOT \] { FINAL | INSTANTIABLE } \] ...;

where *method\_spec* is the following:

\[ \[ NOT \] { FINAL | INSTANTIABLE } \] ...

\[ OVERRIDING \]

*subprogram\_spec*

where *subprogram\_spec* is the following:

{ MEMBER | STATIC }

{ PROCEDURE *proc\_name*

\[ ( \[ SELF \[ IN | IN OUT \] *name* \]

\[, *parm1* \[ IN | IN OUT | OUT \] *datatype1*

\[ DEFAULT *value1* \] \]

\[, *parm2* \[ IN | IN OUT | OUT \] *datatype2*

\[ DEFAULT *value2* \]

\] ...)

\]

|

FUNCTION *func\_name*

\[ ( \[ SELF \[ IN | IN OUT \] *name* \]

\[, *parm1* \[ IN | IN OUT | OUT \] *datatype1*

\[ DEFAULT *value1* \] \]

\[, *parm2* \[ IN | IN OUT | OUT \] *datatype2*

\[ DEFAULT *value2* \]

\] ...)

\]

RETURN *return\_type*

}

where *constructor* is the following:

CONSTRUCTOR *func\_name*

\[ ( \[ SELF \[ IN | IN OUT \] *name* \]

\[, *parm1* \[ IN | IN OUT | OUT \] *datatype1*

\[ DEFAULT *value1* \] \]

\[, *parm2* \[ IN | IN OUT | OUT \] *datatype2*

\[ DEFAULT *value2* \]

\] ...)

\]

RETURN self AS RESULT

**Note:** The OR REPLACE option cannot be currently used to add, delete, or modify the attributes of an existing object type. Use the DROP TYPE command to first delete the existing object type. The OR REPLACE option can be used to add, delete, or modify the methods in an existing object type.

**Note:** The PostgreSQL form of the ALTER TYPE ALTER ATTRIBUTE command can be used to change the data type of an attribute in an existing object type. However, the ALTER TYPE command cannot add or delete attributes in the object type.

*name* is an identifier (optionally schema-qualified) assigned to the object type.

If the AUTHID clause is omitted or DEFINER is specified, the rights of the object type owner are used to determine access privileges to database objects. If CURRENT\_USER is specified, the rights of the current user executing a method in the object are used to determine access privileges.

*attribute* is an identifier assigned to an attribute of the object type.

*datatype* is a base data type.

*objtype* is a previously defined object type.

*collecttype* is a previously defined collection type.

Following the closing parenthesis of the CREATE TYPE definition, \[ NOT \] FINAL specifies whether or not a subtype can be derived from this object type. FINAL, which is the default, means that no subtypes can be derived from this object type. Specify NOT FINAL if you want to allow subtypes to be defined under this object type.

**Note:** Even though the specification of NOT FINAL is accepted in the CREATE TYPE command, SPL does not currently support the creation of subtypes.

Following the closing parenthesis of the CREATE TYPE definition, \[ NOT \] INSTANTIABLE specifies whether or not an object instance can be created of this object type. INSTANTIABLE, which is the default, means that an instance of this object type can be created. Specify NOT INSTANTIABLE if this object type is to be used only as a parent “template” from which other specialized subtypes are to be defined. If NOT INSTANTIABLE is specified, then NOT FINAL must be specified as well. If any method in the object type contains the NOT INSTANTIABLE qualifier, then the object type, itself, must be defined with NOT INSTANTIABLE and NOT FINAL.

**Note:** Even though the specification of NOT INSTANTIABLE is accepted in the CREATE TYPE command, SPL does not currently support the creation of subtypes.

*method\_spec* denotes the specification of a member method or static method.

Prior to the definition of a method, \[ NOT \] FINAL specifies whether or not the method can be overridden in a subtype. NOT FINAL is the default meaning the method can be overridden in a subtype.

Prior to the definition of a method specify OVERRIDING if the method overrides an identically named method in a supertype. The overriding method must have the same number of identically named method parameters with the same data types and parameter modes, in the same order, and the same return type (if the method is a function) as defined in the supertype.

Prior to the definition of a method, \[ NOT \] INSTANTIABLE specifies whether or not the object type definition provides an implementation for the method. If INSTANTIABLE is specified, then the CREATE TYPE BODY command for the object type must specify the implementation of the method. If NOT INSTANTIABLE is specified, then the CREATE TYPE BODY command for the object type must not contain the implementation of the method. In this latter case, it is assumed a subtype contains the implementation of the method, overriding the method in this object type. If there are any NOT INSTANTIABLE methods in the object type, then the object type definition itself, must specify NOT INSTANTIABLE and NOT FINAL following the closing parenthesis of the object type specification. The default is INSTANTIABLE.

*subprogram\_spec* denotes the specification of a procedure or function and begins with the specification of either MEMBER or STATIC. A member subprogram must be invoked with respect to a particular object instance while a static subprogram is not invoked with respect to any object instance.

*proc\_name* is an identifier of a procedure. If the SELF parameter is specified, *name* is the object type name given in the CREATE TYPE command. If specified, *parm1*, *parm2*, … are the formal parameters of the procedure. *datatype1*, *datatype2*, … are the data types of *parm1*, *parm2*, … respectively. IN, IN OUT, and OUT are the possible parameter modes for each formal parameter. If none are specified, the default is IN. *value1*, *value2*, … are default values that may be specified for IN parameters.

Include the CONSTRUCTOR keyword and function definition to define a constructor function.

*func\_name* is an identifier of a function. If the SELF parameter is specified, *name* is the object type name given in the CREATE TYPE command. If specified, *parm1*, *parm2*, … are the formal parameters of the function. *datatype1*, *datatype2*, … are the data types of *parm1*, *parm2*, … respectively. IN, IN OUT, and OUT are the possible parameter modes for each formal parameter. If none are specified, the default is IN. *value1*, *value2*, … are default values that may be specified for IN parameters. *return\_type* is the data type of the value the function returns.

The following points should be noted about an object type specification:
 - There must be at least one attribute defined in the object type.
 - There may be none, one, or more methods defined in the object type.
 - For each member method there is an implicit, built-in parameter named SELF, whose data type is that of the object type being defined.

> SELF refers to the object instance that is currently invoking the method. SELF can be explicitly declared as an IN or IN OUT parameter in the parameter list (for example as MEMBER FUNCTION (SELF IN OUT *object\_type* ...)).
>
> If SELF is explicitly declared, SELF must be the first parameter in the parameter list. If SELF is not explicitly declared, its parameter mode defaults to IN OUT for member procedures and IN for member functions.
 - A static method cannot be overridden (OVERRIDING and STATIC cannot be specified together in *method\_spec*).
 - A static method must be instantiable (NOT INSTANTIABLE and STATIC cannot be specified together in *method\_spec*).

### Object Type Body Syntax

The following is the syntax of the object type body:

CREATE \[ OR REPLACE \] TYPE BODY *name*

{ IS | AS }

*method\_spec* \[...\]

\[*constructor*\] \[...\]

END;

where *method\_spec* is the following:

*subprogram\_spec*

and *subprogram\_spec* is the following:

{ MEMBER | STATIC }

{ PROCEDURE *proc\_name*

\[ ( \[ SELF \[ IN | IN OUT \] *name* \]

\[, *parm1* \[ IN | IN OUT | OUT \] *datatype1*

\[ DEFAULT *value1* \] \]

\[, *parm2* \[ IN | IN OUT | OUT \] *datatype2*

\[ DEFAULT *value2* \]

\] ...)

\]

{ IS | AS }

\[ *declarations* \]

BEGIN

*statement*; ...

\[ EXCEPTION

WHEN ... THEN

*statement*; ...\]

END;

|

FUNCTION *func\_name*

\[ ( \[ SELF \[ IN | IN OUT \] *name* \]

\[, *parm1* \[ IN | IN OUT | OUT \] *datatype1*

\[ DEFAULT *value1* \] \]

\[, *parm2* \[ IN | IN OUT | OUT \] *datatype2*

\[ DEFAULT *value2* \]

\] ...)

\]

RETURN *return\_type*

{ IS | AS }

\[ *declarations* \]

BEGIN

*statement*; ...

\[ EXCEPTION

WHEN ... THEN

*statement*; ...\]

END;

where *constructor* is:

CONSTRUCTOR *func\_name*

\[ ( \[ SELF \[ IN | IN OUT \] *name* \]

\[, *parm1* \[ IN | IN OUT | OUT \] *datatype1*

\[ DEFAULT *value1* \] \]

\[, *parm2* \[ IN | IN OUT | OUT \] *datatype2*

\[ DEFAULT *value2* \]

\] ...)

\]

RETURN self AS RESULT

{ IS | AS }

\[ *declarations* \]

BEGIN

*statement*; ...

\[ EXCEPTION

WHEN ... THEN

*statement*; ...\]

END;

*name* is an identifier (optionally schema-qualified) assigned to the object type.

*method\_spec* denotes the implementation of an instantiable method that was specified in the CREATE TYPE command.

If INSTANTIABLE was specified or omitted in *method\_spec* of the CREATE TYPE command, then there must be a *method\_spec* for this method in the CREATE TYPE BODY command.

If NOT INSTANTIABLE was specified in *method\_spec* of the CREATE TYPE command, then there must be no *method\_spec* for this method in the CREATE TYPE BODY command.

*subprogram\_spec* denotes the specification of a procedure or function and begins with the specification of either MEMBER or STATIC. The same qualifier must be used as was specified in *subprogram\_spec* of the CREATE TYPE command.

*proc\_name* is an identifier of a procedure specified in the CREATE TYPE command. The parameter declarations have the same meaning as described for the CREATE TYPE command, and must be specified in the CREATE TYPE BODY command in the same manner as specified in the CREATE TYPE command.

Include the CONSTRUCTOR keyword and function definition to define a constructor function.

*func\_name* is an identifier of a function specified in the CREATE TYPE command. The parameter declarations have the same meaning as described for the CREATE TYPE command, and must be specified in the CREATE TYPE BODY command in the same manner as specified in the CREATE TYPE command. *return\_type* is the data type of the value the function returns and must match *return\_type* given in the CREATE TYPE command.

*declarations* are variable, cursor, type, or subprogram declarations. If subprogram declarations are included, they must be declared after all other variable, cursor, and type declarations.

*statement* is an SPL program statement.

## Creating Object Types

You can use the CREATE TYPE command to create an object type specification, and the CREATE TYPE BODY command to create an object type body. This section provides some examples using the CREATE TYPE and CREATE TYPE BODY commands.

The first example creates the addr\_object\_type object type that contains only attributes and no methods:

CREATE OR REPLACE TYPE addr\_object\_type AS OBJECT
(

street VARCHAR2(30),

city VARCHAR2(20),

state CHAR(2),

zip NUMBER(5)

);

Since there are no methods in this object type, an object type body is not required. This example creates a composite type, which allows you to treat related objects as a single attribute.

### Member Methods

A member method is a function or procedure that is defined within an object type and can only be invoked through an instance of that type. Member methods have access to, and can change the attributes of, the object instance on which they are operating.

The following object type specification creates the emp\_obj\_typ object type:

CREATE OR REPLACE TYPE emp\_obj\_typ AS OBJECT
(

empno NUMBER(4),

ename VARCHAR2(20),

addr ADDR\_OBJ\_TYP,

MEMBER PROCEDURE display\_emp(SELF IN OUT emp\_obj\_typ)

);

Object type emp\_obj\_typ contains a member method named display\_emp. display\_emp uses a SELF parameter, which passes the object instance on which the method is invoked.

A SELF parameter is a parameter whose data type is that of the object type being defined. SELF always refers to the instance that is invoking the method. A SELF parameter is the first parameter in a member procedure or function *regardless* of whether it is explicitly declared in the parameter list.

The following code snippet defines an object type body for emp\_obj\_typ:

CREATE OR REPLACE TYPE BODY emp\_obj\_typ AS

MEMBER PROCEDURE display\_emp (SELF IN OUT emp\_obj\_typ)

IS

BEGIN

DBMS\_OUTPUT.PUT\_LINE('Employee No  : ' || empno);

DBMS\_OUTPUT.PUT\_LINE('Name          : ' || ename);

DBMS\_OUTPUT.PUT\_LINE('Street        : ' || addr.street);

DBMS\_OUTPUT.PUT\_LINE('City/State/Zip: ' || addr.city || ', ' ||

addr.state || ' ' || LPAD(addr.zip,5,'0'));

END;

END;

You can also use the SELF parameter in an object type body. To illustrate how the SELF parameter would be used in the CREATE TYPE BODY command, the preceding object type body could be written as follows:

CREATE OR REPLACE TYPE BODY emp\_obj\_typ AS

MEMBER PROCEDURE display\_emp (SELF IN OUT emp\_obj\_typ)

IS

BEGIN

DBMS\_OUTPUT.PUT\_LINE('Employee No  : ' || SELF.empno);

DBMS\_OUTPUT.PUT\_LINE('Name          : ' || SELF.ename);

DBMS\_OUTPUT.PUT\_LINE('Street        : ' || SELF.addr.street);

DBMS\_OUTPUT.PUT\_LINE('City/State/Zip: ' || SELF.addr.city || ', ' ||

SELF.addr.state || ' ' || LPAD(SELF.addr.zip,5,'0'));

END;

END;

Both versions of the emp\_obj\_typ body are completely equivalent.

### Static Methods

Like a member method, a static method belongs to a type. A static method, however, is invoked not by an *instance* of the type, but by using the *name* of the type. For example, to invoke a static function named get\_count, defined within the emp\_obj\_type type, you would write:

> emp\_obj\_type.get\_count();

A static method does not have access to, and cannot change the attributes of an object instance, and does not typically work with an instance of the type.

The following object type specification includes a static function get\_dname and a member procedure display\_dept:

CREATE OR REPLACE TYPE dept\_obj\_typ AS OBJECT (

deptno NUMBER(2),

STATIC FUNCTION get\_dname(p\_deptno IN NUMBER) RETURN VARCHAR2,

MEMBER PROCEDURE display\_dept

);

The object type body for dept\_obj\_typ defines a static function named get\_dname and a member procedure named display\_dept:

CREATE OR REPLACE TYPE BODY dept\_obj\_typ AS

STATIC FUNCTION get\_dname(p\_deptno IN NUMBER) RETURN VARCHAR2

IS

v\_dname VARCHAR2(14);

BEGIN

CASE p\_deptno

WHEN 10 THEN v\_dname := 'ACCOUNTING';

WHEN 20 THEN v\_dname := 'RESEARCH';

WHEN 30 THEN v\_dname := 'SALES';

WHEN 40 THEN v\_dname := 'OPERATIONS';

ELSE v\_dname := 'UNKNOWN';

END CASE;

RETURN v\_dname;

END;

MEMBER PROCEDURE display\_dept

IS

BEGIN

DBMS\_OUTPUT.PUT\_LINE('Dept No : ' || SELF.deptno);

DBMS\_OUTPUT.PUT\_LINE('Dept Name : ' ||

dept\_obj\_typ.get\_dname(SELF.deptno));

END;

END;

Within the static function get\_dname, there can be no references to SELF. Since a static function is invoked independently of any object instance, it has no implicit access to any object attribute.

Member procedure display\_dept can access the deptno attribute of the object instance passed in the SELF parameter. It is not necessary to explicitly declare the SELF parameter in the display\_dept parameter list.

The last DBMS\_OUTPUT.PUT\_LINE statement in the display\_dept procedure includes a call to the static function get\_dname (qualified by its object type name dept\_obj\_typ).

### Constructor Methods

A constructor method is a function that creates an instance of an object type, typically by assigning values to the members of the object. An object type may define several constructors to accomplish different tasks. A constructor method is a member function (invoked with a SELF parameter) whose name matches the name of the type.

For example, if you define a type named address, each constructor is named address. You may overload a constructor by creating one or more different constructor functions with the same name, but with different argument types.

The SPL compiler will provide a default constructor for each object type. The default constructor is a member function whose name matches the name of the type and whose argument list matches the type members (in order). For example, given an object type such as:

CREATE TYPE address AS OBJECT
(
street\_address VARCHAR2(40),
postal\_code VARCHAR2(10),
city VARCHAR2(40),
state VARCHAR2(2)
)

The SPL compiler will provide a default constructor with the following signature:

CONSTRUCTOR FUNCTION address
(
street\_address VARCHAR2(40),
postal\_code VARCHAR2(10),
city VARCHAR2(40),
state VARCHAR2(2)
)

The body of the default constructor simply sets each member to NULL.

To create a custom constructor, declare the constructor function (using the keyword constructor) in the CREATE TYPE command and define the construction function in the CREATE TYPE BODY command. For example, you may wish to create a custom constructor for the address type which computes the city and state given a street\_address and postal\_code:

CREATE TYPE address AS OBJECT
(
street\_address VARCHAR2(40),
postal\_code VARCHAR2(10),
city VARCHAR2(40),
state VARCHAR2(2),

CONSTRUCTOR FUNCTION address
(
street\_address VARCHAR2,
postal\_code VARCHAR2
) RETURN self AS RESULT
)

CREATE TYPE BODY address AS
CONSTRUCTOR FUNCTION address
(
street\_address VARCHAR2,
postal\_code VARCHAR2
) RETURN self AS RESULT
IS
BEGIN
self.street\_address := street\_address;
self.postal\_code := postal\_code;
self.city := postal\_code\_to\_city(postal\_code);
self.state := postal\_code\_to\_state(postal\_code);
RETURN;
END;
END;

To create an instance of an object type, you invoke one of the constructor methods for that type. For example:

DECLARE
cust\_addr address := address('100 Main Street', 02203');
BEGIN
DBMS\_OUTPUT.PUT\_LINE(cust\_addr.city); -- displays Boston
DBMS\_OUTPUT.PUT\_LINE(cust\_addr.state); -- displays MA
END;

Custom constructor functions are typically used to compute member values when given incomplete information. The preceding example computes the values for city and state when given a postal code.

Custom constructor functions are also used to enforce business rules that restrict the state of an object. For example, if you define an object type to represent a payment, you can use a custom constructor to ensure that no object of type payment can be created with an amount that is NULL, negative, or zero. The default constructor would set payment.amount to NULL so you must create a custom constructor (whose signature matches the default constructor) to prohibit NULL amounts.

## Creating Object Instances

To create an instance of an object type, you must first declare a variable of the object type, and then initialize the declared object variable. The syntax for declaring an object variable is:

*object* *obj\_type*

*object* is an identifier assigned to the object variable.

*obj\_type* is the identifier of a previously defined object type.

After declaring the object variable, you must invoke a *constructor* *method* to initialize the object with values. Use the following syntax to invoke the constructor method:

> \[NEW\] *obj\_type* ({expr1 | NULL} \[, {expr2 | NULL} \] \[, ...\])

*obj\_type* is the identifier of the object type’s constructor method; the constructor method has the same name as the previously declared object type.

*expr1*, *expr2*, … are expressions that are type-compatible with the first attribute of the object type, the second attribute of the object type, etc. If an attribute is of an object type, then the corresponding expression can be NULL, an object initialization expression, or any expression that returns that object type.

The following anonymous block declares and initializes a variable:

DECLARE

v\_emp EMP\_OBJ\_TYP;

BEGIN

v\_emp := emp\_obj\_typ (9001,'JONES',

addr\_obj\_typ('123 MAIN STREET','EDISON','NJ',08817));

END;

The variable (v\_emp) is declared with a previously defined object type named EMP\_OBJ\_TYPE. The body of the block initializes the variable using the emp\_obj\_typ and addr\_obj\_type constructors.

You can include the NEW keyword when creating a new instance of an object in the body of a block. The NEW keyword invokes the object constructor whose signature matches the arguments provided.

The following example declares two variables, named mgr and emp. The variables are both of EMP\_OBJ\_TYPE. The mgr object is initialized in the declaration, while the emp object is initialized to NULL in the declaration, and assigned a value in the body.

DECLARE

mgr EMP\_OBJ\_TYPE := (9002,'SMITH');

emp EMP\_OBJ\_TYPE;

BEGIN

emp := NEW EMP\_OBJ\_TYPE (9003,'RAY');

END;

**Note:** In Advanced Server, the following alternate syntax can be used in place of the constructor method.

\[ ROW \] ({ *expr1* | NULL } \[, { *expr2* | NULL } \] \[, ...\])

ROW is an optional keyword if two or more terms are specified within the parenthesis-enclosed, comma-delimited list. If only one term is specified, then specification of the ROW keyword is mandatory.

## Referencing an Object

Once an object variable is created and initialized, individual attributes can be referenced using dot notation of the form:

*object*.*attribute*

*object* is the identifier assigned to the object variable. *attribute* is the identifier of an object type attribute.

If *attribute*, itself, is of an object type, then the reference must take the form:

*object*.*attribute.attribute\_inner*

*attribute\_inner* is an identifier belonging to the object type to which *attribute* references in its definition of *object*.

The following example expands upon the previous anonymous block to display the values assigned to the emp\_obj\_typ object.

DECLARE

v\_emp EMP\_OBJ\_TYP;

BEGIN

v\_emp := emp\_obj\_typ(9001,'JONES',

addr\_obj\_typ('123 MAIN STREET','EDISON','NJ',08817));

DBMS\_OUTPUT.PUT\_LINE('Employee No  : ' || v\_emp.empno);

DBMS\_OUTPUT.PUT\_LINE('Name          : ' || v\_emp.ename);

DBMS\_OUTPUT.PUT\_LINE('Street        : ' || v\_emp.addr.street);

DBMS\_OUTPUT.PUT\_LINE('City/State/Zip: ' || v\_emp.addr.city || ', ' ||

v\_emp.addr.state || ' ' || LPAD(v\_emp.addr.zip,5,'0'));

END;

The following is the output from this anonymous block.

Employee No : 9001

Name : JONES

Street : 123 MAIN STREET

City/State/Zip: EDISON, NJ 08817

Methods are called in a similar manner as attributes.

Once an object variable is created and initialized, member procedures or functions are called using dot notation of the form:

*object*.*prog\_name*

*object* is the identifier assigned to the object variable. *prog\_name* is the identifier of the procedure or function.

Static procedures or functions are not called utilizing an object variable. Instead the procedure or function is called utilizing the object type name:

*object\_type*.*prog\_name*

*object\_type* is the identifier assigned to the object type. *prog\_name* is the identifier of the procedure or function.

The results of the previous anonymous block can be duplicated by calling the member procedure display\_emp:

DECLARE

v\_emp EMP\_OBJ\_TYP;

BEGIN

v\_emp := emp\_obj\_typ(9001,'JONES',

addr\_obj\_typ('123 MAIN STREET','EDISON','NJ',08817));

v\_emp.display\_emp;

END;

The following is the output from this anonymous block.

Employee No : 9001

Name : JONES

Street : 123 MAIN STREET

City/State/Zip: EDISON, NJ 08817

The following anonymous block creates an instance of dept\_obj\_typ and calls the member procedure display\_dept:

DECLARE

v\_dept DEPT\_OBJ\_TYP := dept\_obj\_typ (20);

BEGIN

v\_dept.display\_dept;

END;

The following is the output from this anonymous block.

Dept No : 20

Dept Name : RESEARCH

The static function defined in dept\_obj\_typ can be called directly by qualifying it by the object type name as follows:

BEGIN

DBMS\_OUTPUT.PUT\_LINE(dept\_obj\_typ.get\_dname(20));

END;

RESEARCH

## Dropping an Object Type

The syntax for deleting an object type is as follows.

DROP TYPE *objtype*;

*objtype* is the identifier of the object type to be dropped. If the definition of *objtype* contains attributes that are themselves object types or collection types, these nested object types or collection types must be dropped last.

If an object type body is defined for the object type, the DROP TYPE command deletes the object type body as well as the object type specification. In order to recreate the complete object type, both the CREATE TYPE and CREATE TYPE BODY commands must be reissued.

The following example drops the emp\_obj\_typ and the addr\_obj\_typ object types created earlier in this chapter. emp\_obj\_typ must be dropped first since it contains addr\_obj\_typ within its definition as an attribute.

DROP TYPE emp\_obj\_typ;

DROP TYPE addr\_obj\_typ;

The syntax for deleting an object type body, but not the object type specification is as follows.

DROP TYPE BODY *objtype*;

The object type body can be recreated by issuing the CREATE TYPE BODY command.

The following example drops only the object type body of the dept\_obj\_typ.

DROP TYPE BODY dept\_obj\_typ;

