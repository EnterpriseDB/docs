---
title: Stored Procedure Language
---


This chapter describes the Stored Procedure Language (SPL). SPL is a highly productive, procedural programming language for writing custom procedures, functions, triggers, and packages for Advanced Server that provides:
 - full procedural programming functionality to complement the SQL language
 - a single, common language to create stored procedures, functions, triggers, and packages for the Advanced Server database
 - a seamless development and testing environment
 - the use of reusable code
 - ease of use

This chapter describes the basic elements of an SPL program, before providing an overview of the organization of an SPL program and how it is used to create a procedure or a function. Triggers, while still utilizing SPL, are sufficiently different to warrant a separate discussion (see Section <span class="underline">4</span> for information about triggers). Packages are discussed in the *Database Compatibility for Oracle Developers Built-in Package Guide* available at:

<http://www.enterprisedb.com/products-services-training/products/documentation>

The remaining sections of this chapter delve into the details of the SPL language and provide examples of its application.

## Basic SPL Elements

This section discusses the basic programming elements of an SPL program.

### Character Set

SPL programs are written using the following set of characters:
 - Uppercase letters A thru Z and lowercase letters a thru z
 - Digits 0 thru 9
 - Symbols ( ) + - \* / \< \> = \! \~ ^ ; : . ' @ % , " \# $ & \_ | { } ? \[ \]
 - White space characters tabs, spaces, and carriage returns

Identifiers, expressions, statements, control structures, etc. that comprise the SPL language are written using these characters.

**Note:** The data that can be manipulated by an SPL program is determined by the character set supported by the database encoding.

### Case Sensitivity

Keywords and user-defined identifiers that are used in an SPL program are case insensitive. So for example, the statement DBMS\_OUTPUT.PUT\_LINE('Hello World'); is interpreted to mean the same thing as dbms\_output.put\_line('Hello World'); or Dbms\_Output.Put\_Line('Hello World'); or DBMS\_output.Put\_line('Hello World');.

Character and string constants, however, are case sensitive as well as any data retrieved from the Advanced Server database or data obtained from other external sources. The statement DBMS\_OUTPUT.PUT\_LINE('Hello World\!'); produces the following output:

Hello World\!

However the statement DBMS\_OUTPUT.PUT\_LINE('HELLO WORLD\!'); produces the output:

HELLO WORLD\!

### Identifiers

*Identifiers* are user-defined names that are used to identify various elements of an SPL program including variables, cursors, labels, programs, and parameters. The syntax rules for valid identifiers are the same as for identifiers in the SQL language.

An identifier must not be the same as an SPL keyword or a keyword of the SQL language. The following are some examples of valid identifiers:

x

last\_\_\_name

a\_$\_Sign

Many$$$$$$$$signs\_\_\_\_\_

THIS\_IS\_AN\_EXTREMELY\_LONG\_NAME

A1

### Qualifiers

A *qualifier* is a name that specifies the owner or context of an entity that is the object of the qualification. A qualified object is specified as the qualifier name followed by a dot with no intervening white space, followed by the name of the object being qualified with no intervening white space. This syntax is called *dot notation*.

The following is the syntax of a qualified object.

*qualifier*. \[ *qualifier*. \]... *object*

*qualifier* is the name of the owner of the object. *object* is the name of the entity belonging to *qualifier*. It is possible to have a chain of qualifications where the preceding qualifier owns the entity identified by the subsequent qualifier(s) and object.

Almost any identifier can be qualified. What an identifier is qualified by depends upon what the identifier represents and the context of its usage.

Some examples of qualification follow:
 - Procedure and function names qualified by the schema to which they belong - e.g., *schema\_name*.*procedure\_name*(...)
 - Trigger names qualified by the schema to which they belong - e.g., *schema\_name*.*trigger\_name*
 - Column names qualified by the table to which they belong - e.g., emp.empno
 - Table names qualified by the schema to which they belong - e.g., public.emp
 - Column names qualified by table and schema - e.g., public.emp.empno

As a general rule, wherever a name appears in the syntax of an SPL statement, its qualified name can be used as well. Typically a qualified name would only be used if there is some ambiguity associated with the name. For example, if two procedures with the same name belonging to two different schemas are invoked from within a program or if the same name is used for a table column and SPL variable within the same program.

You should avoid using qualified names if at all possible. In this chapter, the following conventions are adopted to avoid naming conflicts:
 - All variables declared in the declaration section of an SPL program are prefixed by v\_. E.g., v\_empno
 - All formal parameters declared in a procedure or function definition are prefixed by p\_. E.g., p\_empno
 - Column names and table names do not have any special prefix conventions. E.g., column empno in table emp

### Constants

*Constants* or *literals* are fixed values that can be used in SPL programs to represent values of various types - e.g., numbers, strings, dates, etc. Constants come in the following types:
 - Numeric (Integer and Real)
 - Character and String
 - Date/time

>

### User-Defined PL/SQL Subtypes

Advanced Server supports user-defined PL/SQL subtypes and (subtype) aliases. A subtype is a data type with an optional set of constraints that restrict the values that can be stored in a column of that type. The rules that apply to the type on which the subtype is based are still enforced, but you can use additional constraints to place limits on the precision or scale of values stored in the type.

You can define a subtype in the declaration of a PL function, procedure, anonymous block or package. The syntax is:

> SUBTYPE *subtype*\_*name* IS *type*\_*name*\[(*constraint*)\] \[NOT NULL\]

Where *constraint* is:

> {*precision* \[, *scale*\]} | *length*

Where:

*subtype*\_*name*

> *subtype*\_*name* specifies the name of the subtype.

*type*\_*name*

> *type*\_*name* specifies the name of the original type on which the subtype is based. *type\_name* may be:
 - The name of any of the type supported by Advanced Server.
 - The name of any composite type.
 - A column anchored by a %TYPE operator.
 - The name of another subtype.

Include the *constraint* clause to define restrictions for types that support precision or scale.

*precision*

> *precision* specifies the total number of digits permitted in a value of the subtype.

*scale*

> *scale* specifies the number of fractional digits permitted in a value of the subtype.

*length*

> *length* specifies the total length permitted in a value of CHARACTER, VARCHAR, or TEXT base types

Include the NOT NULL clause to specify that NULL values may not be stored in a column of the specified subtype.

Note that a subtype that is based on a column will inherit the column size constraints, but the subtype will not inherit NOT NULL or CHECK constraints.

**Unconstrained Subtypes**

To create an unconstrained subtype, use the SUBTYPE command to specify the new subtype name and the name of the type on which the subtype is based. For example, the following command creates a subtype named address that has all of the attributes of the type, CHAR:

> SUBTYPE address IS CHAR;

You can also create a subtype (constrained or unconstrained) that is a subtype of another subtype:

> SUBTYPE cust\_address IS address NOT NULL;

This command creates a subtype named cust\_address that shares all of the attributes of the address subtype. Include the NOT NULL clause to specify that a value of the cust\_address may not be NULL.

**Constrained Subtypes**

Include a *length* value when creating a subtype that is based on a character type to define the maximum length of the subtype. For example:

> SUBTYPE acct\_name IS VARCHAR (15);

This example creates a subtype named acct\_name that is based on a VARCHAR data type, but is limited to 15 characters in length.

Include values for *precision* (to specify the maximum number of digits in a value of the subtype) and optionally, *scale* (to specify the number of digits to the right of the decimal point) when constraining a numeric base type. For example:

> SUBTYPE acct\_balance IS NUMBER (5, 2);

This example creates a subtype named acct\_balance that shares all of the attributes of a NUMBER type, but that may not exceed 3 digits to the left of the decimal point and 2 digits to the right of the decimal.

An argument declaration (in a function or procedure header) is a *formal* *argument*. The value passed to a function or procedure is an *actual* *argument*. When invoking a function or procedure, the caller provides (0 or more) actual arguments. Each actual argument is assigned to a formal argument that holds the value within the body of the function or procedure.

If a formal argument is declared as a constrained subtype:
 - Advanced Server does not enforce subtype constraints when assigning an actual argument to a formal argument when invoking a function.
 - Advanced Server enforces subtype constraints when assigning an actual argument to a formal argument when invoking a procedure.

**Using the %TYPE Operator**

You can use %TYPE notation to declare a subtype anchored to a column. For example:

> SUBTYPE emp\_type IS emp.empno%TYPE

This command creates a subtype named emp\_type whose base type matches the type of the empno column in the emp table. A subtype that is based on a column will share the column size constraints; NOT NULL and CHECK constraints are not inherited.

**Subtype Conversion**

Unconstrained subtypes are aliases for the type on which they are based. Any variable of type subtype (unconstrained) is interchangeable with a variable of the base type without conversion, and vice versa.

A variable of a constrained subtype may be interchanged with a variable of the base type without conversion, but a variable of the base type may only be interchanged with a constrained subtype if it complies with the constraints of the subtype. A variable of a constrained subtype may be implicitly converted to another subtype if it is based on the same subtype, and the constraint values are within the values of the subtype to which it is being converted.

## SPL Programs

SPL is a procedural, block-structured language. There are four different types of programs that can be created using SPL, namely *procedures*, *functions*, *triggers*, and *packages*.

In addition, SPL is used to create subprograms. A *subprogram* refers to a *subprocedure* or a *subfunction*, which are nearly identical in appearance to procedures and functions, but differ in that procedures and functions are *standalone programs*, which are individually stored in the database and can be invoked by other SPL programs or from PSQL. Subprograms can only be invoked from within the standalone program within which they have been created.

### SPL Block Structure

Regardless of whether the program is a procedure, function, subprogram, or trigger, an SPL program has the same *block* structure. A block consists of up to three sections - an optional declaration section, a mandatory executable section, and an optional exception section. Minimally, a block has an executable section that consists of one or more SPL statements within the keywords, BEGIN and END.

The optional declaration section is used to declare variables, cursors, types, and subprograms that are used by the statements within the executable and exception sections. Declarations appear just prior to the BEGIN keyword of the executable section. Depending upon the context of where the block is used, the declaration section may begin with the keyword DECLARE.

You can include an exception section within the BEGIN - END block. The exception section begins with the keyword, EXCEPTION, and continues until the end of the block in which it appears. If an exception is thrown by a statement within the block, program control goes to the exception section where the thrown exception may or may not be handled depending upon the exception and the contents of the exception section.

The following is the general structure of a block:

\[ \[ DECLARE \]

*declarations* \]

BEGIN

*statements*

\[ EXCEPTION

WHEN *exception\_condition* THEN

*statements* \[, ...\] \]

END;

*declarations* are one or more variable, cursor, type, or subprogram declarations that are local to the block. If subprogram declarations are included, they must be declared after all other variable, cursor, and type declarations. Each declaration must be terminated by a semicolon. The use of the keyword DECLARE depends upon the context in which the block appears.

*statements* are one or more SPL statements. Each statement must be terminated by a semicolon. The end of the block denoted by the keyword END must also be terminated by a semicolon.

If present, the keyword EXCEPTION marks the beginning of the exception section. *exception\_condition* is a conditional expression testing for one or more types of exceptions. If a thrown exception matches one of the exceptions in *exception\_condition*, the *statements* following the WHEN *exception\_condition* clause are executed. There may be one or more WHEN *exception\_condition* clauses, each followed by *statements*. **Note:** A BEGIN/END block in itself, is considered a statement; thus, blocks may be nested. The exception section may also contain nested blocks.

The following is the simplest possible block consisting of the NULL statement within the executable section. The NULL statement is an executable statement that does nothing.

BEGIN

NULL;

END;

The following block contains a declaration section as well as the executable section.

DECLARE

v\_numerator NUMBER(2);

v\_denominator NUMBER(2);

v\_result NUMBER(5,2);

BEGIN

v\_numerator := 75;

v\_denominator := 14;

v\_result := v\_numerator / v\_denominator;

DBMS\_OUTPUT.PUT\_LINE(v\_numerator || ' divided by ' || v\_denominator ||

' is ' || v\_result);

END;

In this example, three numeric variables are declared of data type NUMBER. Values are assigned to two of the variables, and one number is divided by the other, storing the results in a third variable which is then displayed. If executed, the output would be:

75 divided by 14 is 5.36

The following block consists of a declaration, an executable, and an exception:

DECLARE

v\_numerator NUMBER(2);

v\_denominator NUMBER(2);

v\_result NUMBER(5,2);

BEGIN

v\_numerator := 75;

v\_denominator := 0;

v\_result := v\_numerator / v\_denominator;

DBMS\_OUTPUT.PUT\_LINE(v\_numerator || ' divided by ' || v\_denominator ||

' is ' || v\_result);

EXCEPTION

WHEN OTHERS THEN

DBMS\_OUTPUT.PUT\_LINE('An exception occurred');

END;

The following output shows that the statement within the exception section is executed as a result of the division by zero.

An exception occurred

### Anonymous Blocks

Blocks are typically written as part of a procedure, function, subprogram, or trigger. Procedure, function, and trigger programs are named and stored in the database for re-use. For quick (one-time) execution (such as testing), you can simply enter the block without providing a name or storing it in the database.

A block of this type is called an *anonymous block*. An anonymous block is unnamed and is not stored in the database. Once the block has been executed and erased from the application buffer, it cannot be re-executed unless the block code is re-entered into the application.

Typically, the same block of code will be re-executed many times. In order to run a block of code repeatedly without the necessity of re-entering the code each time, with some simple modifications, an anonymous block can be turned into a procedure or function. The following sections discuss how to create a procedure or function that can be stored in the database and invoked repeatedly by another procedure, function, or application program.

### Procedures Overview

Procedures are standalone SPL programs that are invoked or called as an individual SPL program statement. When called, procedures may optionally receive values from the caller in the form of input parameters and optionally return values to the caller in the form of output parameters.

#### Creating a Procedure

The CREATE PROCEDURE command defines and names a standalone procedure that will be stored in the database.

CREATE \[OR REPLACE\] PROCEDURE *name* \[ (*parameters*) \]
\[

> IMMUTABLE
> | STABLE
> | VOLATILE
> | DETERMINISTIC
> | \[ NOT \] LEAKPROOF
>
> | CALLED ON NULL INPUT
> | RETURNS NULL ON NULL INPUT
> | STRICT
>
> | \[ EXTERNAL \] SECURITY INVOKER
> | \[ EXTERNAL \] SECURITY DEFINER
>
> | AUTHID DEFINER
> | AUTHID CURRENT\_USER
>
> | PARALLEL { UNSAFE | RESTRICTED | SAFE }
>
> | COST *execution*\_*cost*
>
> | ROWS *result*\_*rows*
> | SET *configuration*\_*parameter*
> { TO *value* | = *value* | FROM CURRENT }
> ...\]
> { IS | AS }

\[ *declarations* \]

BEGIN

*statements*

END \[ *name* \];

**Where:**

*name*

> *name* is the identifier of the procedure. If you specify the \[OR REPLACE\] clause and a procedure with the same name already exists in the schema, the new procedure will replace the existing one. If you do not specify \[OR REPLACE\], the new procedure will not replace the existing procedure with the same name in the same schema.

*parameters*

> *parameters* is a list of formal parameters.

*declarations*

> *declarations* are variable, cursor, type, or subprogram declarations. If subprogram declarations are included, they must be declared after all other variable, cursor, and type declarations.

*statements*

> *statements* are SPL program statements (the BEGIN - END block may contain an EXCEPTION section).

IMMUTABLE

STABLE

VOLATILE

> These attributes inform the query optimizer about the behavior of the procedure; you can specify only one choice. VOLATILE is the default behavior.
>
> IMMUTABLE indicates that the procedure cannot modify the database and always reaches the same result when given the same argument values; it does not do database lookups or otherwise use information not directly present in its argument list. If you include this clause, any call of the procedure with all-constant arguments can be immediately replaced with the procedure value.
>
> STABLE indicates that the procedure cannot modify the database, and that within a single table scan, it will consistently return the same result for the same argument values, but that its result could change across SQL statements. This is the appropriate selection for procedures that depend on database lookups, parameter variables (such as the current time zone), etc.
>
> VOLATILE indicates that the procedure value can change even within a single table scan, so no optimizations can be made. Please note that any function that has side-effects must be classified volatile, even if its result is quite predictable, to prevent calls from being optimized away.

DETERMINISTIC

> DETERMINISTIC is a synonym for IMMUTABLE. A DETERMINISTIC procedure cannot modify the database and always reaches the same result when given the same argument values; it does not do database lookups or otherwise use information not directly present in its argument list. If you include this clause, any call of the procedure with all-constant arguments can be immediately replaced with the procedure value.

\[ NOT \] LEAKPROOF

> A LEAKPROOF procedure has no side effects, and reveals no information about the values used to call the procedure.

CALLED ON NULL INPUT
RETURNS NULL ON NULL INPUT
STRICT

> CALLED ON NULL INPUT (the default) indicates that the procedure will be called normally when some of its arguments are NULL. It is the author's responsibility to check for NULL values if necessary and respond appropriately.
>
> RETURNS NULL ON NULL INPUT or STRICT indicates that the procedure always returns NULL whenever any of its arguments are NULL. If these clauses are specified, the procedure is not executed when there are NULL arguments; instead a NULL result is assumed automatically.

\[ EXTERNAL \] SECURITY DEFINER

> SECURITY DEFINER specifies that the procedure will execute with the privileges of the user that created it; this is the default. The key word EXTERNAL is allowed for SQL conformance, but is optional.

\[ EXTERNAL \] SECURITY INVOKER

> The SECURITY INVOKER clause indicates that the procedure will execute with the privileges of the user that calls it. The key word EXTERNAL is allowed for SQL conformance, but is optional.

AUTHID DEFINER

AUTHID CURRENT\_USER

> The AUTHID DEFINER clause is a synonym for \[EXTERNAL\] SECURITY DEFINER. If the AUTHID clause is omitted or if AUTHID DEFINER is specified, the rights of the procedure owner are used to determine access privileges to database objects.
>
> The AUTHID CURRENT\_USER clause is a synonym for \[EXTERNAL\] SECURITY INVOKER. If AUTHID CURRENT\_USER is specified, the rights of the current user executing the procedure are used to determine access privileges.

PARALLEL { UNSAFE | RESTRICTED | SAFE }

> The PARALLEL clause enables the use of parallel sequential scans (parallel mode). A parallel sequential scan uses multiple workers to scan a relation in parallel during a query in contrast to a serial sequential scan.
>
> When set to UNSAFE, the procedure cannot be executed in parallel mode. The presence of such a procedure forces a serial execution plan. This is the default setting if the PARALLEL clause is omitted.
>
> When set to RESTRICTED, the procedure can be executed in parallel mode, but the execution is restricted to the parallel group leader. If the qualification for any particular relation has anything that is parallel restricted, that relation won't be chosen for parallelism.
>
> When set to SAFE, the procedure can be executed in parallel mode with no restriction.

COST *execution*\_*cost*

> *execution*\_*cost* is a positive number giving the estimated execution cost for the procedure, in units of cpu\_operator\_cost. If the procedure returns a set, this is the cost per returned row. Larger values cause the planner to try to avoid evaluating the function more often than necessary.

ROWS *result*\_*rows*

> *result*\_*rows* is a positive number giving the estimated number of rows that the planner should expect the procedure to return. This is only allowed when the procedure is declared to return a set. The default assumption is 1000 rows.

SET *configuration*\_*parameter* { TO *value* | = *value* | FROM CURRENT }

> The SET clause causes the specified configuration parameter to be set to the specified value when the procedure is entered, and then restored to its prior value when the procedure exits. SET FROM CURRENT saves the session's current value of the parameter as the value to be applied when the procedure is entered.
>
> If a SET clause is attached to a procedure, then the effects of a SET LOCAL command executed inside the procedure for the same variable are restricted to the procedure; the configuration parameter's prior value is restored at procedure exit. An ordinary SET command (without LOCAL) overrides the SET clause, much as it would do for a previous SET LOCAL command, with the effects of such a command persisting after procedure exit, unless the current transaction is rolled back.

Please Note: The STRICT, LEAKPROOF, PARALLEL, COST, ROWS and SET keywords provide extended functionality for Advanced Server and are not supported by Oracle.

**Example**

The following is an example of a simple procedure that takes no parameters.

CREATE OR REPLACE PROCEDURE simple\_procedure

IS

BEGIN

DBMS\_OUTPUT.PUT\_LINE('That''s all folks\!');

END simple\_procedure;

The procedure is stored in the database by entering the procedure code in Advanced Server.

The following example demonstrates using the AUTHID DEFINER and SET clauses in a procedure declaration. The update\_salary procedure conveys the privileges of the role that defined the procedure to the role that is calling the procedure (while the procedure executes):

CREATE OR REPLACE PROCEDURE update\_salary(id INT, new\_salary NUMBER)

SET SEARCH\_PATH = 'public' SET WORK\_MEM = '1MB'

AUTHID DEFINER IS

BEGIN

UPDATE emp SET salary = new\_salary WHERE emp\_id = id;

END;

Include the SET clause to set the procedure's search path to public and the work memory to 1MB. Other procedures, functions and objects will not be affected by these settings.

In this example, the AUTHID DEFINER clause temporarily grants privileges to a role that might otherwise not be allowed to execute the statements within the procedure. To instruct the server to use the privileges associated with the role invoking the procedure, replace the AUTHID DEFINER clause with the AUTHID CURRENT\_USER clause.

#### Calling a Procedure

A procedure can be invoked from another SPL program by simply specifying the procedure name followed by its parameters, if any, followed by a semicolon.

*name* \[ (\[ *parameters* \]) \];

**Where:**

> *name* is the identifier of the procedure.
>
> *parameters* is a list of actual parameters.

**Note:** If there are no actual parameters to be passed, the procedure may be called with an empty parameter list, or the opening and closing parenthesis may be omitted entirely.

**Note:** The syntax for calling a procedure is the same as in the preceding syntax diagram when executing it with the EXEC command in PSQL or EDB\*Plus. See the *Database Compatibility for Oracle Developers Tools and Utilities Guide* for information about the EXEC command.

The following is an example of calling the procedure from an anonymous block:

BEGIN

simple\_procedure;

END;

That's all folks\!

**Note**: Each application has its own unique way to call a procedure. For example, in a Java application, the application programming interface, JDBC, is used.

#### Deleting a Procedure

A procedure can be deleted from the database using the DROP PROCEDURE command.

DROP PROCEDURE *name*;

Where *name* is the name of the procedure to be dropped.

The previously created procedure is dropped in this example:

DROP PROCEDURE simple\_procedure;

### Functions Overview

Functions are standalone SPL programs that are invoked as expressions. When evaluated, a function returns a value that is substituted in the expression in which the function is embedded. Functions may optionally take values from the calling program in the form of input parameters. In addition to the fact that the function, itself, returns a value, a function may optionally return additional values to the caller in the form of output parameters. The use of output parameters in functions, however, is not an encouraged programming practice.

#### Creating a Function

The CREATE FUNCTION command defines and names a standalone function that will be stored in the database.

CREATE \[ OR REPLACE \] FUNCTION *name* \[ (*parameters*) \]

RETURN *data\_type*

\[

> IMMUTABLE
> | STABLE
> | VOLATILE
> | DETERMINISTIC
> | \[ NOT \] LEAKPROOF
>
> | CALLED ON NULL INPUT
> | RETURNS NULL ON NULL INPUT
> | STRICT
>
> | \[ EXTERNAL \] SECURITY INVOKER
> | \[ EXTERNAL \] SECURITY DEFINER
>
> | AUTHID DEFINER
> | AUTHID CURRENT\_USER
>
> | PARALLEL { UNSAFE | RESTRICTED | SAFE }
>
> | COST *execution*\_*cost*
>
> | ROWS *result*\_*rows*
> | SET *configuration*\_*parameter*
> { TO *value* | = *value* | FROM CURRENT }
> ...\]
> { IS | AS }

\[ *declarations* \]

BEGIN

*statements*

END \[ *name* \];

**Where:**

*name*

> *name* is the identifier of the function. If you specify the \[OR REPLACE\] clause and a function with the same name already exists in the schema, the new function will replace the existing one. If you do not specify \[OR REPLACE\], the new function will not replace the existing function with the same name in the same schema.

*parameters*

> *parameters* is a list of formal parameters.

*data\_type*

*data\_type* is the data type of the value returned by the function’s RETURN statement.

*declarations*

> *declarations* are variable, cursor, type, or subprogram declarations. If subprogram declarations are included, they must be declared after all other variable, cursor, and type declarations.

*statements*

> *statements* are SPL program statements (the BEGIN - END block may contain an EXCEPTION section).

IMMUTABLE

STABLE

VOLATILE

> These attributes inform the query optimizer about the behavior of the function; you can specify only one choice. VOLATILE is the default behavior.
>
> IMMUTABLE indicates that the function cannot modify the database and always reaches the same result when given the same argument values; it does not do database lookups or otherwise use information not directly present in its argument list. If you include this clause, any call of the function with all-constant arguments can be immediately replaced with the function value.
>
> STABLE indicates that the function cannot modify the database, and that within a single table scan, it will consistently return the same result for the same argument values, but that its result could change across SQL statements. This is the appropriate selection for function that depend on database lookups, parameter variables (such as the current time zone), etc.
>
> VOLATILE indicates that the function value can change even within a single table scan, so no optimizations can be made. Please note that any function that has side-effects must be classified volatile, even if its result is quite predictable, to prevent calls from being optimized away.

DETERMINISTIC

> DETERMINISTIC is a synonym for IMMUTABLE. A DETERMINISTIC function cannot modify the database and always reaches the same result when given the same argument values; it does not do database lookups or otherwise use information not directly present in its argument list. If you include this clause, any call of the function with all-constant arguments can be immediately replaced with the function value.

\[ NOT \] LEAKPROOF

> A LEAKPROOF function has no side effects, and reveals no information about the values used to call the function.

CALLED ON NULL INPUT
RETURNS NULL ON NULL INPUT
STRICT

> CALLED ON NULL INPUT (the default) indicates that the procedure will be called normally when some of its arguments are NULL. It is the author's responsibility to check for NULL values if necessary and respond appropriately.
>
> RETURNS NULL ON NULL INPUT or STRICT indicates that the procedure always returns NULL whenever any of its arguments are NULL. If these clauses are specified, the procedure is not executed when there are NULL arguments; instead a NULL result is assumed automatically.

\[ EXTERNAL \] SECURITY DEFINER

> SECURITY DEFINER specifies that the function will execute with the privileges of the user that created it; this is the default. The key word EXTERNAL is allowed for SQL conformance, but is optional.

\[ EXTERNAL \] SECURITY INVOKER

> The SECURITY INVOKER clause indicates that the function will execute with the privileges of the user that calls it. The key word EXTERNAL is allowed for SQL conformance, but is optional.

AUTHID DEFINER

AUTHID CURRENT\_USER

> The AUTHID DEFINER clause is a synonym for \[EXTERNAL\] SECURITY DEFINER. If the AUTHID clause is omitted or if AUTHID DEFINER is specified, the rights of the function owner are used to determine access privileges to database objects.
>
> The AUTHID CURRENT\_USER clause is a synonym for \[EXTERNAL\] SECURITY INVOKER. If AUTHID CURRENT\_USER is specified, the rights of the current user executing the function are used to determine access privileges.

PARALLEL { UNSAFE | RESTRICTED | SAFE }

> The PARALLEL clause enables the use of parallel sequential scans (parallel mode). A parallel sequential scan uses multiple workers to scan a relation in parallel during a query in contrast to a serial sequential scan.
>
> When set to UNSAFE, the function cannot be executed in parallel mode. The presence of such a function in a SQL statement forces a serial execution plan. This is the default setting if the PARALLEL clause is omitted.
>
> When set to RESTRICTED, the function can be executed in parallel mode, but the execution is restricted to the parallel group leader. If the qualification for any particular relation has anything that is parallel restricted, that relation won't be chosen for parallelism.
>
> When set to SAFE, the function can be executed in parallel mode with no restriction.

COST *execution*\_*cost*

> *execution*\_*cost* is a positive number giving the estimated execution cost for the function, in units of cpu\_operator\_cost. If the function returns a set, this is the cost per returned row. Larger values cause the planner to try to avoid evaluating the function more often than necessary.

ROWS *result*\_*rows*

> *result*\_*rows* is a positive number giving the estimated number of rows that the planner should expect the function to return. This is only allowed when the function is declared to return a set. The default assumption is 1000 rows.

SET *configuration*\_*parameter* { TO *value* | = *value* | FROM CURRENT }

> The SET clause causes the specified configuration parameter to be set to the specified value when the function is entered, and then restored to its prior value when the function exits. SET FROM CURRENT saves the session's current value of the parameter as the value to be applied when the function is entered.
>
> If a SET clause is attached to a function, then the effects of a SET LOCAL command executed inside the function for the same variable are restricted to the function; the configuration parameter's prior value is restored at function exit. An ordinary SET command (without LOCAL) overrides the SET clause, much as it would do for a previous SET LOCAL command, with the effects of such a command persisting after procedure exit, unless the current transaction is rolled back.

Please Note: The STRICT, LEAKPROOF, PARALLEL, COST, ROWS and SET keywords provide extended functionality for Advanced Server and are not supported by Oracle.

**Examples**

The following is an example of a simple function that takes no parameters.

CREATE OR REPLACE FUNCTION simple\_function

RETURN VARCHAR2

IS

BEGIN

RETURN 'That''s All Folks\!';

END simple\_function;

The following function takes two input parameters. Parameters are discussed in more detail in subsequent sections.

CREATE OR REPLACE FUNCTION emp\_comp (

p\_sal NUMBER,

p\_comm NUMBER

) RETURN NUMBER

IS

BEGIN

RETURN (p\_sal + NVL(p\_comm, 0)) \* 24;

END emp\_comp;

The following example demonstrates using the AUTHID CURRENT\_USER clause and STRICT keyword in a function declaration:

CREATE OR REPLACE FUNCTION dept\_salaries(dept\_id int) RETURN NUMBER

STRICT

AUTHID CURRENT\_USER

BEGIN

RETURN QUERY (SELECT sum(salary) FROM emp WHERE deptno = id);

END;

Include the STRICT keyword to instruct the server to return NULL if any input parameter passed is NULL; if a NULL value is passed, the function will not execute.

The dept\_salaries function executes with the privileges of the role that is calling the function. If the current user does not have sufficient privileges to perform the SELECT statement querying the emp table (to display employee salaries), the function will report an error. To instruct the server to use the privileges associated with the role that defined the function, replace the AUTHID CURRENT\_USER clause with the AUTHID DEFINER clause.

#### Calling a Function

A function can be used anywhere an expression can appear within an SPL statement. A function is invoked by simply specifying its name followed by its parameters enclosed in parenthesis, if any.

*name* \[ (\[ *parameters* \]) \]

*name* is the name of the function. *parameters* is a list of actual parameters.

**Note:** If there are no actual parameters to be passed, the function may be called with an empty parameter list, or the opening and closing parenthesis may be omitted entirely.

The following shows how the function can be called from another SPL program.

BEGIN

DBMS\_OUTPUT.PUT\_LINE(simple\_function);

END;

That's All Folks\!

A function is typically used within a SQL statement as shown in the following.

SELECT empno "EMPNO", ename "ENAME", sal "SAL", comm "COMM",

emp\_comp(sal, comm) "YEARLY COMPENSATION" FROM emp;

EMPNO | ENAME | SAL | COMM | YEARLY COMPENSATION

\-------+--------+---------+---------+---------------------

7369 | SMITH | 800.00 | | 19200.00

7499 | ALLEN | 1600.00 | 300.00 | 45600.00

7521 | WARD | 1250.00 | 500.00 | 42000.00

7566 | JONES | 2975.00 | | 71400.00

7654 | MARTIN | 1250.00 | 1400.00 | 63600.00

7698 | BLAKE | 2850.00 | | 68400.00

7782 | CLARK | 2450.00 | | 58800.00

7788 | SCOTT | 3000.00 | | 72000.00

7839 | KING | 5000.00 | | 120000.00

7844 | TURNER | 1500.00 | 0.00 | 36000.00

7876 | ADAMS | 1100.00 | | 26400.00

7900 | JAMES | 950.00 | | 22800.00

7902 | FORD | 3000.00 | | 72000.00

7934 | MILLER | 1300.00 | | 31200.00

(14 rows)

#### Deleting a Function

A function can be deleted from the database using the DROP FUNCTION command.

DROP FUNCTION *name* \[ (*parameters*) \];

Where *name* is the name of the function to be dropped.

**Note:** The specification of the parameter list is required in Advanced Server under certain circumstances. Oracle requires that the parameter list always be omitted.

The previously created function is dropped in this example:

DROP FUNCTION simple\_function;

### Procedure and Function Parameters

An important aspect of using procedures and functions is the capability to pass data from the calling program to the procedure or function and to receive data back from the procedure or function. This is accomplished by using *parameters*.

Parameters are declared in the procedure or function definition, enclosed within parenthesis following the procedure or function name. Parameters declared in the procedure or function definition are known as *formal parameters*. When the procedure or function is invoked, the calling program supplies the actual data that is to be used in the called program’s processing as well as the variables that are to receive the results of the called program’s processing. The data and variables supplied by the calling program when the procedure or function is called are referred to as the *actual parameters*.

The following is the general format of a formal parameter declaration.

(*name* \[ IN | OUT | IN OUT \] *data\_type* \[ DEFAULT *value* \])

*name* is an identifier assigned to the formal parameter. If specified, IN defines the parameter for receiving input data into the procedure or function. An IN parameter can also be initialized to a default value. If specified, OUT defines the parameter for returning data from the procedure or function. If specified, IN OUT allows the parameter to be used for both input and output. If all of IN, OUT, and IN OUT are omitted, then the parameter acts as if it were defined as IN by default. Whether a parameter is IN, OUT, or IN OUT is referred to as the parameter’s *mode*. *data\_type* defines the data type of the parameter. *value* is a default value assigned to an IN parameter in the called program if an actual parameter is not specified in the call.

The following is an example of a procedure that takes parameters:

CREATE OR REPLACE PROCEDURE emp\_query (

p\_deptno IN NUMBER,

p\_empno IN OUT NUMBER,

p\_ename IN OUT VARCHAR2,

p\_job OUT VARCHAR2,

p\_hiredate OUT DATE,

p\_sal OUT NUMBER

)

IS

BEGIN

SELECT empno, ename, job, hiredate, sal

INTO p\_empno, p\_ename, p\_job, p\_hiredate, p\_sal

FROM emp

WHERE deptno = p\_deptno

AND (empno = p\_empno

OR ename = UPPER(p\_ename));

END;

In this example, p\_deptno is an IN formal parameter, p\_empno and p\_ename are IN OUT formal parameters, and p\_job, p\_hiredate, and p\_sal are OUT formal parameters.

**Note:** In the previous example, no maximum length was specified on the VARCHAR2 parameters and no precision and scale were specified on the NUMBER parameters. It is illegal to specify a length, precision, scale or other constraints on parameter declarations. These constraints are automatically inherited from the actual parameters that are used when the procedure or function is called.

The emp\_query procedure can be called by another program, passing it the actual parameters. The following is an example of another SPL program that calls emp\_query.

DECLARE

v\_deptno NUMBER(2);

v\_empno NUMBER(4);

v\_ename VARCHAR2(10);

v\_job VARCHAR2(9);

v\_hiredate DATE;

v\_sal NUMBER;

BEGIN

v\_deptno := 30;

v\_empno := 7900;

v\_ename := '';

emp\_query(v\_deptno, v\_empno, v\_ename, v\_job, v\_hiredate, v\_sal);

DBMS\_OUTPUT.PUT\_LINE('Department : ' || v\_deptno);

DBMS\_OUTPUT.PUT\_LINE('Employee No: ' || v\_empno);

DBMS\_OUTPUT.PUT\_LINE('Name : ' || v\_ename);

DBMS\_OUTPUT.PUT\_LINE('Job : ' || v\_job);

DBMS\_OUTPUT.PUT\_LINE('Hire Date : ' || v\_hiredate);

DBMS\_OUTPUT.PUT\_LINE('Salary : ' || v\_sal);

END;

In this example, v\_deptno, v\_empno, v\_ename, v\_job, v\_hiredate, and v\_sal are the actual parameters.

The output from the preceding example is shown as follows:

Department : 30

Employee No: 7900

Name : JAMES

Job : CLERK

Hire Date : 03-DEC-81

Salary : 950

#### Positional vs. Named Parameter Notation

You can use either *positional* or *named* parameter notation when passing parameters to a function or procedure. If you specify parameters using positional notation, you must list the parameters in the order that they are declared; if you specify parameters with named notation, the order of the parameters is not significant.

To specify parameters using named notation, list the name of each parameter followed by an arrow (=\>) and the parameter value. Named notation is more verbose, but makes your code easier to read and maintain.

A simple example that demonstrates using positional and named parameter notation follows:

> CREATE OR REPLACE PROCEDURE emp\_info (
>
> p\_deptno IN NUMBER,
>
> p\_empno IN OUT NUMBER,
>
> p\_ename IN OUT VARCHAR2,
>
> )
>
> IS
>
> BEGIN
>
> dbms\_output.put\_line('Department Number =' || p\_deptno);
>
> dbms\_output.put\_line('Employee Number =' || p\_empno);
>
> dbms\_output.put\_line('Employee Name =' || p\_ename;
>
> END;

To call the procedure using positional notation, pass the following:

> emp\_info(30, 7455, 'Clark');

To call the procedure using named notation, pass the following:

> emp\_info(p\_ename =\>'Clark', p\_empno=\>7455, p\_deptno=\>30);

Using named notation can alleviate the need to re-arrange a procedure’s parameter list if the parameter list changes, if the parameters are reordered or if a new optional parameter is added.

In a case where you have a default value for an argument and the argument is not a trailing argument, you must use named notation to call the procedure or function. The following case demonstrates a procedure with two, leading, default arguments.

CREATE OR REPLACE PROCEDURE check\_balance (

p\_customerID IN NUMBER DEFAULT NULL,

p\_balance IN NUMBER DEFAULT NULL,

p\_amount IN NUMBER

)

IS

DECLARE

balance NUMBER;

BEGIN

IF (p\_balance IS NULL AND p\_customerID IS NULL) THEN

RAISE\_APPLICATION\_ERROR

(-20010, 'Must provide balance or customer');

ELSEIF (p\_balance IS NOT NULL AND p\_customerID IS NOT NULL) THEN

RAISE\_APPLICATION\_ERROR

(-20020,'Must provide balance or customer, not both');

ELSEIF (p\_balance IS NULL) THEN

balance := getCustomerBalance(p\_customerID);

ELSE

balance := p\_balance;

END IF;

IF (amount \> balance) THEN

RAISE\_APPLICATION\_ERROR

(-20030, 'Balance insufficient');

END IF;

END;

You can only omit non-trailing argument values (when you call this procedure) by using named notation; when using positional notation, only trailing arguments are allowed to default. You can call this procedure with the following arguments:

> check\_balance(p\_customerID =\> 10, p\_amount = 500.00)
>
> check\_balance(p\_balance =\> 1000.00, p\_amount = 500.00)

You can use a combination of positional and named notation (mixed notation) to specify parameters. A simple example that demonstrates using mixed parameter notation follows:

> CREATE OR REPLACE PROCEDURE emp\_info (
>
> p\_deptno IN NUMBER,
>
> p\_empno IN OUT NUMBER,
>
> p\_ename IN OUT VARCHAR2,
>
> )
>
> IS
>
> BEGIN
>
> dbms\_output.put\_line('Department Number =' || p\_deptno);
>
> dbms\_output.put\_line('Employee Number =' || p\_empno);
>
> dbms\_output.put\_line('Employee Name =' || p\_ename;
>
> END;

You can call the procedure using mixed notation:

> emp\_info(30, p\_ename =\>'Clark', p\_empno=\>7455);

If you do use mixed notation, remember that named arguments cannot precede positional arguments.

#### Parameter Modes

As previously discussed, a parameter has one of three possible modes - IN, OUT, or IN OUT. The following characteristics of a formal parameter are dependent upon its mode:
 - Its initial value when the procedure or function is called.
 - Whether or not the called procedure or function can modify the formal parameter.
 - How the actual parameter value is passed from the calling program to the called program.
 - What happens to the formal parameter value when an unhandled exception occurs in the called program.

The following table summarizes the behavior of parameters according to their mode.

Table 3‑1 Parameter Modes

|                                                                                 |                                                   |                                                   |                                                   |
| ------------------------------------------------------------------------------- | ------------------------------------------------- | ------------------------------------------------- | ------------------------------------------------- |
| Mode Property                                                                   | IN                                                | IN OUT                                            | OUT                                               |
| Formal parameter initialized to:                                                | Actual parameter value                            | Actual parameter value                            | Actual parameter value                            |
| Formal parameter modifiable by the called program?                              | No                                                | Yes                                               | Yes                                               |
| Actual parameter contains: (after normal called program termination)            | Original actual parameter value prior to the call | Last value of the formal parameter                | Last value of the formal parameter                |
| Actual parameter contains: (after a handled exception in the called program)    | Original actual parameter value prior to the call | Last value of the formal parameter                | Last value of the formal parameter                |
| Actual parameter contains: (after an unhandled exception in the called program) | Original actual parameter value prior to the call | Original actual parameter value prior to the call | Original actual parameter value prior to the call |

As shown by the table, an IN formal parameter is initialized to the actual parameter with which it is called unless it was explicitly initialized with a default value. The IN parameter may be referenced within the called program, however, the called program may not assign a new value to the IN parameter. After control returns to the calling program, the actual parameter always contains the same value as it was set to prior to the call.

The OUT formal parameter is initialized to the actual parameter with which it is called. The called program may reference and assign new values to the formal parameter. If the called program terminates without an exception, the actual parameter takes on the value last set in the formal parameter. If a handled exception occurs, the value of the actual parameter takes on the last value assigned to the formal parameter. If an unhandled exception occurs, the value of the actual parameter remains as it was prior to the call.

Like an IN parameter, an IN OUT formal parameter is initialized to the actual parameter with which it is called. Like an OUT parameter, an IN OUT formal parameter is modifiable by the called program and the last value in the formal parameter is passed to the calling program’s actual parameter if the called program terminates without an exception. If a handled exception occurs, the value of the actual parameter takes on the last value assigned to the formal parameter. If an unhandled exception occurs, the value of the actual parameter remains as it was prior to the call.

#### Using Default Values in Parameters

You can set a default value of a formal parameter by including the DEFAULT clause or using the assignment operator (:=) in the CREATE PROCEDURE or CREATE FUNCTION statement.

The general form of a formal parameter declaration is:

(*name* \[ IN|OUT|IN OUT \] *data\_type* \[{DEFAULT | := } *expr* \])

*name* is an identifier assigned to the parameter.

IN|OUT|IN OUT specifies the parameter mode.

*data\_type* is the data type assigned to the variable.

*expr* is the default value assigned to the parameter. If you do not include a DEFAULT clause, the caller must provide a value for the parameter.

The default value is evaluated every time the function or procedure is invoked. For example, assigning SYSDATE to a parameter of type DATE causes the parameter to have the time of the current invocation, not the time when the procedure or function was created.

The following simple procedure demonstrates using the assignment operator to set a default value of SYSDATE into the parameter, hiredate:

CREATE OR REPLACE PROCEDURE hire\_emp (

p\_empno NUMBER,

p\_ename VARCHAR2,

p\_hiredate DATE := SYSDATE

)

IS

BEGIN

INSERT INTO emp(empno, ename, hiredate)

VALUES(p\_empno, p\_ename, p\_hiredate);

DBMS\_OUTPUT.PUT\_LINE('Hired\!');

END hire\_emp;

If the parameter declaration includes a default value, you can omit the parameter from the actual parameter list when you call the procedure. Calls to the sample procedure (hire\_emp) must include two arguments: the employee number (p\_empno) and employee name (p\_empno). The third parameter (p\_hiredate) defaults to the value of SYSDATE:

hire\_emp (7575, Clark)

If you do include a value for the actual parameter when you call the procedure, that value takes precedence over the default value:

hire\_emp (7575, Clark, 15-FEB-2010)

Adds a new employee with a hiredate of February 15, 2010, regardless of the current value of SYSDATE.

You can write the same procedure by substituting the DEFAULT keyword for the assignment operator:

CREATE OR REPLACE PROCEDURE hire\_emp (

p\_empno NUMBER,

p\_ename VARCHAR2,

p\_hiredate DATE DEFAULT SYSDATE

)

IS

BEGIN

INSERT INTO emp(empno, ename, hiredate)

VALUES(p\_empno, p\_ename, p\_hiredate);

DBMS\_OUTPUT.PUT\_LINE('Hired\!');

END hire\_emp;

### Subprograms – Subprocedures and Subfunctions

The capability and functionality of SPL procedure and function programs can be used in an advantageous manner to build well-structured and maintainable programs by organizing the SPL code into subprocedures and subfunctions.

The same SPL code can be invoked multiple times from different locations within a relatively large SPL program by declaring subprocedures and subfunctions within the SPL program.

Subprocedures and subfunctions have the following characteristics:
 - The syntax, structure, and functionality of subprocedures and subfunctions are practically identical to standalone procedures and functions. The major difference is the use of the keyword PROCEDURE or FUNCTION instead of CREATE PROCEDURE or CREATE FUNCTION to declare the subprogram.
 - Subprocedures and subfunctions provide isolation for the identifiers (that is, variables, cursors, types, and other subprograms) declared within itself. That is, these identifiers cannot be accessed nor altered from the upper, parent level SPL programs or subprograms outside of the subprocedure or subfunction. This ensures that the subprocedure and subfunction results are reliable and predictable.
 - The declaration section of subprocedures and subfunctions can include its own subprocedures and subfunctions. Thus, a multi-level hierarchy of subprograms can exist in the standalone program. Within the hierarchy, a subprogram can access the identifiers of upper level parent subprograms and also invoke upper level parent subprograms. However, the same access to identifiers and invocation cannot be done for lower level child subprograms in the hierarchy.

Subprocedures and subfunctions can be declared and invoked from within any of the following types of SPL programs:
 - Standalone procedures and functions
 - Anonymous blocks
 - Triggers
 - Packages
 - Procedure and function methods of an object type body
 - Subprocedures and subfunctions declared within any of the preceding programs

The rules regarding subprocedure and subfunction structure and access are discussed in more detail in the next sections.

#### Creating a Subprocedure

The PROCEDURE clause specified in the declaration section defines and names a subprocedure local to that block.

The term *block* refers to the SPL block structure consisting of an optional declaration section, a mandatory executable section, and an optional exception section. Blocks are the structures for standalone procedures and functions, anonymous blocks, subprograms, triggers, packages, and object type methods.

The phrase *the identifier is local to the block* means that the identifier (that is, a variable, cursor, type, or subprogram) is declared within the declaration section of that block and is therefore accessible by the SPL code within the executable section and optional exception section of that block.

Subprocedures can only be declared after all other variable, cursor, and type declarations included in the declaration section. (That is, subprograms must be the last set of declarations.)

PROCEDURE *name* \[ (*parameters*) \]
{ IS | AS }

\[ *declarations* \]

BEGIN

*statements*

END \[ *name* \];

Where:

*name*

> *name* is the identifier of the subprocedure.

*parameters*

> *parameters* is a list of formal parameters.

*declarations*

> *declarations* are variable, cursor, type, or subprogram declarations. If subprogram declarations are included, they must be declared after all other variable, cursor, and type declarations.

*statements*

> *statements* are SPL program statements (the BEGIN - END block may contain an EXCEPTION section).

Examples

The following example is a subprocedure within an anonymous block.

DECLARE

PROCEDURE list\_emp

IS

v\_empno NUMBER(4);

v\_ename VARCHAR2(10);

CURSOR emp\_cur IS

SELECT empno, ename FROM emp ORDER BY empno;

BEGIN

OPEN emp\_cur;

DBMS\_OUTPUT.PUT\_LINE('Subprocedure list\_emp:');

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME');

DBMS\_OUTPUT.PUT\_LINE('----- -------');

LOOP

FETCH emp\_cur INTO v\_empno, v\_ename;

EXIT WHEN emp\_cur%NOTFOUND;

DBMS\_OUTPUT.PUT\_LINE(v\_empno || ' ' || v\_ename);

END LOOP;

CLOSE emp\_cur;

END;

BEGIN

list\_emp;

END;

Invoking this anonymous block produces the following output:

Subprocedure list\_emp:

EMPNO ENAME

\----- -------

7369 SMITH

7499 ALLEN

7521 WARD

7566 JONES

7654 MARTIN

7698 BLAKE

7782 CLARK

7788 SCOTT

7839 KING

7844 TURNER

7876 ADAMS

7900 JAMES

7902 FORD

7934 MILLER

The following example is a subprocedure within a trigger.

CREATE OR REPLACE TRIGGER dept\_audit\_trig

AFTER INSERT OR UPDATE OR DELETE ON dept

DECLARE

v\_action VARCHAR2(24);

PROCEDURE display\_action (

p\_action IN VARCHAR2

)

IS

BEGIN

DBMS\_OUTPUT.PUT\_LINE('User ' || USER || ' ' || p\_action ||

' dept on ' || TO\_CHAR(SYSDATE,'YYYY-MM-DD'));

END display\_action;

BEGIN

IF INSERTING THEN

v\_action := 'added';

ELSIF UPDATING THEN

v\_action := 'updated';

ELSIF DELETING THEN

v\_action := 'deleted';

END IF;

display\_action(v\_action);

END;

Invoking this trigger produces the following output:

INSERT INTO dept VALUES (50,'HR','DENVER');

User enterprisedb added dept on 2016-07-26

#### Creating a Subfunction

The FUNCTION clause specified in the declaration section defines and names a subfunction local to that block.

The term *block* refers to the SPL block structure consisting of an optional declaration section, a mandatory executable section, and an optional exception section. Blocks are the structures for standalone procedures and functions, anonymous blocks, subprograms, triggers, packages, and object type methods.

The phrase *the identifier is local to the block* means that the identifier (that is, a variable, cursor, type, or subprogram) is declared within the declaration section of that block and is therefore accessible by the SPL code within the executable section and optional exception section of that block.

FUNCTION *name* \[ (*parameters*) \]

RETURN *data\_type*
{ IS | AS }

\[ *declarations* \]

BEGIN

*statements*

END \[ *name* \];

Where:

*name*

> *name* is the identifier of the subfunction.

*parameters*

> *parameters* is a list of formal parameters.

*data\_type*

*data\_type* is the data type of the value returned by the function’s RETURN statement.

*declarations*

> *declarations* are variable, cursor, type, or subprogram declarations. If subprogram declarations are included, they must be declared after all other variable, cursor, and type declarations.

*statements*

> *statements* are SPL program statements (the BEGIN - END block may contain an EXCEPTION section).

Examples

The following example shows the use of a recursive subfunction:

DECLARE

FUNCTION factorial (

n BINARY\_INTEGER

) RETURN BINARY\_INTEGER

IS

BEGIN

IF n = 1 THEN

RETURN n;

ELSE

RETURN n \* factorial(n-1);

END IF;

END factorial;

BEGIN

FOR i IN 1..5 LOOP

DBMS\_OUTPUT.PUT\_LINE(i || '\! = ' || factorial(i));

END LOOP;

END;

The output from the example is the following:

1\! = 1

2\! = 2

3\! = 6

4\! = 24

5\! = 120

#### Block Relationships

This section describes the terminology of the relationship between blocks that can be declared in an SPL program. The ability to invoke subprograms and access identifiers declared within a block depends upon this relationship.

The following are the basic terms:
 - A *block* is the basic SPL structure consisting of an optional declaration section, a mandatory executable section, and an optional exception section. Blocks implement standalone procedure and function programs, anonymous blocks, triggers, packages, and subprocedures and subfunctions.
 - An identifier (variable, cursor, type, or subprogram) *local to a block* means that it is declared within the declaration section of the given block. Such local identifiers are accessible from the executable section and optional exception section of the block.
 - The *parent block* contains the declaration of another block (the *child block*).
 - *Descendent blocks* are the set of blocks forming the child relationship starting from a given parent block.
 - *Ancestor blocks* are the set of blocks forming the parental relationship starting from a given child block.
 - The set of descendent (or ancestor) blocks form a *hierarchy*.
 - The *level* is an ordinal number of a given block from the highest, ancestor block. For example, given a standalone procedure, the subprograms declared within the declaration section of this procedure are all at the same level, for example call it level 1. Additional subprograms within the declaration section of the subprograms declared in the standalone procedure are at the next level, which is level 2.
 - The *sibling blocks* are the set of blocks that have the same parent block (that is, they are all locally declared in the same block). Sibling blocks are also always at the same level relative to each other.

The following schematic of a set of procedure declaration sections provides an example of a set of blocks and their relationships to their surrounding blocks.

The two vertical lines on the left-hand side of the blocks indicate there are two pairs of sibling blocks. block\_1a and block\_1b is one pair, and block\_2a and block\_2b is the second pair.

The relationship of each block with its ancestors is shown on the right-hand side of the blocks. There are three hierarchical paths formed when progressing up the hierarchy from the lowest level child blocks. The first consists of block\_0, block\_1a, block\_2a, and block\_3. The second is block\_0, block\_1a, and block\_2b. The third is block\_0, block\_1b, and block\_2b.

CREATE PROCEDURE block\_0

IS

.

\+---- PROCEDURE block\_1a ------- Local to block\_0

| IS

| . |

| . |

| . |

| +-- PROCEDURE block\_2a ---- Local to block\_1a and descendant

| | IS of block\_0

| | . |

| | . |

| | . |

| | PROCEDURE block\_3 -- Local to block\_2a and descendant

| | IS of block\_1a, and block\_0

| Siblings . |

| | . |

| | . |

| | END block\_3; |

| | END block\_2a; |

| +-- PROCEDURE block\_2b ---- Local to block\_1a and descendant

| | IS of block\_0

Siblings | , |

| | . |

| | . |

| +-- END block\_2b; |

| |

| END block\_1a; ---------+

\+---- PROCEDURE block\_1b; ------- Local to block\_0

| IS

| . |

| . |

| . |

| PROCEDURE block\_2b ---- Local to block\_1b and descendant

| IS of block\_0

| . |

| . |

| . |

| END block\_2b; |

| |

\+---- END block\_1b; ---------+

BEGIN

.

.

.

END block\_0;

The rules for invoking subprograms based upon block location is described starting with Section <span class="underline">3.2.6.4</span>. The rules for accessing variables based upon block location is described in Section <span class="underline">3.2.6.7</span>.

#### Invoking Subprograms

A subprogram is invoked in the same manner as a standalone procedure or function by specifying its name and any actual parameters.

The subprogram may be invoked with none, one, or more qualifiers, which are the names of the parent subprograms or labeled anonymous blocks forming the ancestor hierarchy from where the subprogram has been declared.

The invocation is specified as a dot-separated list of qualifiers ending with the subprogram name and any of its arguments as shown by the following:

\[\[*qualifier\_1*.\]\[...\]*qualifier\_n*.\]*subprog* \[(*arguments*)\]

If specified, *qualifier\_n* is the subprogram in which *subprog* has been declared in its declaration section. The preceding list of qualifiers must reside in a continuous path up the hierarchy from *qualifier\_n* to *qualifier\_1*. *qualifier\_1* may be any ancestor subprogram in the path as well as any of the following:
 - Standalone procedure name containing the subprogram
 - Standalone function name containing subprogram
 - Package name containing the subprogram
 - Object type name containing the subprogram within an object type method
 - An anonymous block label included prior to the DECLARE keyword if a declaration section exists, or prior to the BEGIN keyword if there is no declaration section.

**Note:** *qualifier\_1* may not be a schema name, otherwise an error is thrown upon invocation of the subprogram. This Advanced Server restriction is not compatible with Oracle databases, which allow use of the schema name as a qualifier.

*arguments* is the list of actual parameters to be passed to the subprocedure or subfunction.

Upon invocation, the search for the subprogram occurs as follows:
 - The invoked subprogram name of its type (that is, subprocedure or subfunction) along with any qualifiers in the specified order, (referred to as the invocation list) is used to find a matching set of blocks residing in the same hierarchical order. The search begins in the block hierarchy where the lowest level is the block from where the subprogram is invoked. The declaration of the subprogram must be in the SPL code prior to the code line where it is invoked when the code is observed from top to bottom. (An exception to this requirement can be accomplished using a forward declaration. See Section <span class="underline">3.2.6.5</span> for information on forward declarations.)
 - If the invocation list does not match the hierarchy of blocks starting from the block where the subprogram is invoked, a comparison is made by matching the invocation list starting with the parent of the previous starting block. In other words, the comparison progresses up the hierarchy.
 - If there are sibling blocks of the ancestors, the invocation list comparison also includes the hierarchy of the sibling blocks, but always comparing in an upward level, never comparing the descendants of the sibling blocks.
 - This comparison process continues up the hierarchies until the first complete match is found in which case the located subprogram is invoked. Note that the formal parameter list of the matched subprogram must comply with the actual parameter list specified for the invoked subprogram, otherwise an error occurs upon invocation of the subprogram.
 - If no match is found after searching up to the standalone program, then an error is thrown upon invocation of the subprogram.

**Note:** The Advanced Server search algorithm for subprogram invocation is not quite compatible with Oracle databases. For Oracle, the search looks for the first match of the first qualifier (that is *qualifier\_1*). When such a match is found, all remaining qualifiers, the subprogram name, subprogram type, and arguments of the invocation must match the hierarchy content where the matching first qualifier is found, otherwise an error is thrown. For Advanced Server, a match is not found unless all qualifiers, the subprogram name, and the subprogram type of the invocation match the hierarchy content. If such an exact match is not initially found, Advanced Server continues the search progressing up the hierarchy.

The location of subprograms relative to the block from where the invocation is made can be accessed as follows:
 - Subprograms declared in the local block can be invoked from the executable section or the exception section of the same block.
 - Subprograms declared in the parent or other ancestor blocks can be invoked from the child block of the parent or other ancestors.
 - Subprograms declared in sibling blocks can be called from a sibling block or from any descendent block of the sibling.

However, the following location of subprograms cannot be accessed relative to the block from where the invocation is made:
 - Subprograms declared in blocks that are descendants of the block from where the invocation is attempted.
 - Subprograms declared in blocks that are descendants of a sibling block from where the invocation is attempted.

The following examples illustrate the various conditions previously described.

Invoking Locally Declared Subprograms

The following example contains a single hierarchy of blocks contained within standalone procedure level\_0. Within the executable section of procedure level\_1a, the means of invoking the local procedure level\_2a are shown, both with and without qualifiers.

Also note that access to the descendant of local procedure level\_2a, which is procedure level\_3a, is not permitted, with or without qualifiers. These calls are commented out in the example.

CREATE OR REPLACE PROCEDURE level\_0

IS

PROCEDURE level\_1a

IS

PROCEDURE level\_2a

IS

PROCEDURE level\_3a

IS

BEGIN

DBMS\_OUTPUT.PUT\_LINE('........ BLOCK level\_3a');

DBMS\_OUTPUT.PUT\_LINE('........ END BLOCK level\_3a');

END level\_3a;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('...... BLOCK level\_2a');

DBMS\_OUTPUT.PUT\_LINE('...... END BLOCK level\_2a');

END level\_2a;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('.. BLOCK level\_1a');

level\_2a; -- Local block called

level\_1a.level\_2a; -- Qualified local block called

level\_0.level\_1a.level\_2a; -- Double qualified local block called

\-- level\_3a; -- Error - Descendant of local block

\-- level\_2a.level\_3a; -- Error - Descendant of local block

DBMS\_OUTPUT.PUT\_LINE('.. END BLOCK level\_1a');

END level\_1a;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('BLOCK level\_0');

level\_1a;

DBMS\_OUTPUT.PUT\_LINE('END BLOCK level\_0');

END level\_0;

When the standalone procedure is invoked, the output is the following, which indicates that procedure level\_2a is successfully invoked from the calls in the executable section of procedure level\_1a.

BEGIN

level\_0;

END;

BLOCK level\_0

.. BLOCK level\_1a

...... BLOCK level\_2a

...... END BLOCK level\_2a

...... BLOCK level\_2a

...... END BLOCK level\_2a

...... BLOCK level\_2a

...... END BLOCK level\_2a

.. END BLOCK level\_1a

END BLOCK level\_0

If you were to attempt to run procedure level\_0 with any of the calls to the descendent block uncommented, then an error occurs.

Invoking Subprograms Declared in Ancestor Blocks

The following example shows how subprograms can be invoked that are declared in parent and other ancestor blocks relative to the block where the invocation is made.

In this example, the executable section of procedure level\_3a invokes procedure level\_2a, which is its parent block. (Note that v\_cnt is used to avoid an infinite loop.)

CREATE OR REPLACE PROCEDURE level\_0

IS

v\_cnt NUMBER(2) := 0;

PROCEDURE level\_1a

IS

PROCEDURE level\_2a

IS

PROCEDURE level\_3a

IS

BEGIN

DBMS\_OUTPUT.PUT\_LINE('........ BLOCK level\_3a');

v\_cnt := v\_cnt + 1;

IF v\_cnt \< 2 THEN

level\_2a; -- Parent block called

END IF;

DBMS\_OUTPUT.PUT\_LINE('........ END BLOCK level\_3a');

END level\_3a;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('...... BLOCK level\_2a');

level\_3a; -- Local block called

DBMS\_OUTPUT.PUT\_LINE('...... END BLOCK level\_2a');

END level\_2a;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('.. BLOCK level\_1a');

level\_2a; -- Local block called

DBMS\_OUTPUT.PUT\_LINE('.. END BLOCK level\_1a');

END level\_1a;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('BLOCK level\_0');

level\_1a;

DBMS\_OUTPUT.PUT\_LINE('END BLOCK level\_0');

END level\_0;

The following is the resulting output:

BEGIN

level\_0;

END;

BLOCK level\_0

.. BLOCK level\_1a

...... BLOCK level\_2a

........ BLOCK level\_3a

...... BLOCK level\_2a

........ BLOCK level\_3a

........ END BLOCK level\_3a

...... END BLOCK level\_2a

........ END BLOCK level\_3a

...... END BLOCK level\_2a

.. END BLOCK level\_1a

END BLOCK level\_0

In a similar example, the executable section of procedure level\_3a invokes procedure level\_1a, which is further up the ancestor hierarchy. (Note that v\_cnt is used to avoid an infinite loop.)

CREATE OR REPLACE PROCEDURE level\_0

IS

v\_cnt NUMBER(2) := 0;

PROCEDURE level\_1a

IS

PROCEDURE level\_2a

IS

PROCEDURE level\_3a

IS

BEGIN

DBMS\_OUTPUT.PUT\_LINE('........ BLOCK level\_3a');

v\_cnt := v\_cnt + 1;

IF v\_cnt \< 2 THEN

level\_1a; -- Ancestor block called

END IF;

DBMS\_OUTPUT.PUT\_LINE('........ END BLOCK level\_3a');

END level\_3a;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('...... BLOCK level\_2a');

level\_3a; -- Local block called

DBMS\_OUTPUT.PUT\_LINE('...... END BLOCK level\_2a');

END level\_2a;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('.. BLOCK level\_1a');

level\_2a; -- Local block called

DBMS\_OUTPUT.PUT\_LINE('.. END BLOCK level\_1a');

END level\_1a;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('BLOCK level\_0');

level\_1a;

DBMS\_OUTPUT.PUT\_LINE('END BLOCK level\_0');

END level\_0;

The following is the resulting output:

BEGIN

level\_0;

END;

BLOCK level\_0

.. BLOCK level\_1a

...... BLOCK level\_2a

........ BLOCK level\_3a

.. BLOCK level\_1a

...... BLOCK level\_2a

........ BLOCK level\_3a

........ END BLOCK level\_3a

...... END BLOCK level\_2a

.. END BLOCK level\_1a

........ END BLOCK level\_3a

...... END BLOCK level\_2a

.. END BLOCK level\_1a

END BLOCK level\_0

Invoking Subprograms Declared in Sibling Blocks

The following examples show how subprograms can be invoked that are declared in a sibling block relative to the local, parent, or other ancestor blocks from where the invocation of the subprogram is made.

In this example, the executable section of procedure level\_1b invokes procedure level\_1a, which is its sibling block. Both are local to standalone procedure level\_0.

Note that invocation of level\_2a or equivalently, level\_1a.level\_2a from within procedure level\_1b is commented out as this call would result in an error. Invoking a descendent subprogram (level\_2a) of sibling block (level\_1a) is not permitted.

CREATE OR REPLACE PROCEDURE level\_0

IS

v\_cnt NUMBER(2) := 0;

PROCEDURE level\_1a

IS

PROCEDURE level\_2a

IS

BEGIN

DBMS\_OUTPUT.PUT\_LINE('...... BLOCK level\_2a');

DBMS\_OUTPUT.PUT\_LINE('...... END BLOCK level\_2a');

END level\_2a;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('.. BLOCK level\_1a');

DBMS\_OUTPUT.PUT\_LINE('.. END BLOCK level\_1a');

END level\_1a;

PROCEDURE level\_1b

IS

BEGIN

DBMS\_OUTPUT.PUT\_LINE('.. BLOCK level\_1b');

level\_1a; -- Sibling block called

\-- level\_2a; -- Error – Descendant of sibling block

\-- level\_1a.level\_2a; -- Error - Descendant of sibling block

DBMS\_OUTPUT.PUT\_LINE('.. END BLOCK level\_1b');

END level\_1b;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('BLOCK level\_0');

level\_1b;

DBMS\_OUTPUT.PUT\_LINE('END BLOCK level\_0');

END level\_0;

The following is the resulting output:

BEGIN

level\_0;

END;

BLOCK level\_0

.. BLOCK level\_1b

.. BLOCK level\_1a

.. END BLOCK level\_1a

.. END BLOCK level\_1b

END BLOCK level\_0

In the following example, procedure level\_1a, which is the sibling of procedure level\_1b, which is an ancestor of procedure level\_3b is successfully invoked.

CREATE OR REPLACE PROCEDURE level\_0

IS

PROCEDURE level\_1a

IS

BEGIN

DBMS\_OUTPUT.PUT\_LINE('.. BLOCK level\_1a');

DBMS\_OUTPUT.PUT\_LINE('.. END BLOCK level\_1a');

END level\_1a;

PROCEDURE level\_1b

IS

PROCEDURE level\_2b

IS

PROCEDURE level\_3b

IS

BEGIN

DBMS\_OUTPUT.PUT\_LINE('........ BLOCK level\_3b');

level\_1a; -- Ancestor's sibling block called

level\_0.level\_1a; -- Qualified ancestor's sibling block

DBMS\_OUTPUT.PUT\_LINE('........ END BLOCK level\_3b');

END level\_3b;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('...... BLOCK level\_2b');

level\_3b; -- Local block called

DBMS\_OUTPUT.PUT\_LINE('...... END BLOCK level\_2b');

END level\_2b;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('.. BLOCK level\_1b');

level\_2b; -- Local block called

DBMS\_OUTPUT.PUT\_LINE('.. END BLOCK level\_1b');

END level\_1b;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('BLOCK level\_0');

level\_1b;

DBMS\_OUTPUT.PUT\_LINE('END BLOCK level\_0');

END level\_0;

The following is the resulting output:

BEGIN

level\_0;

END;

BLOCK level\_0

.. BLOCK level\_1b

...... BLOCK level\_2b

........ BLOCK level\_3b

.. BLOCK level\_1a

.. END BLOCK level\_1a

.. BLOCK level\_1a

.. END BLOCK level\_1a

........ END BLOCK level\_3b

...... END BLOCK level\_2b

.. END BLOCK level\_1b

END BLOCK level\_0

#### Using Forward Declarations

As discussed so far, when a subprogram is to be invoked, it must have been declared somewhere in the hierarchy of blocks within the standalone program, but prior to where it is invoked. In other words, when scanning the SPL code from beginning to end, the subprogram declaration must be found before its invocation.

However, there is a method of constructing the SPL code so that the full declaration of the subprogram (that is, its optional declaration section, its mandatory executable section, and optional exception section) appears in the SPL code after the point in the code where it is invoked.

This is accomplished by inserting a *forward declaration* in the SPL code prior to its invocation. The forward declaration is the specification of a subprocedure or subfunction name, formal parameters, and return type if it is a subfunction.

The full subprogram specification consisting of the optional declaration section, the executable section, and the optional exception section must be specified in the same declaration section as the forward declaration, but may appear following other subprogram declarations that invoke this subprogram with the forward declaration.

Typical usage of a forward declaration is when two subprograms invoke each other as shown by the following:

DECLARE

FUNCTION add\_one (

p\_add IN NUMBER

) RETURN NUMBER;

FUNCTION test\_max (

p\_test IN NUMBER)

RETURN NUMBER

IS

BEGIN

IF p\_test \< 5 THEN

RETURN add\_one(p\_test);

END IF;

DBMS\_OUTPUT.PUT('Final value is ');

RETURN p\_test;

END;

FUNCTION add\_one (

p\_add IN NUMBER)

RETURN NUMBER

IS

BEGIN

DBMS\_OUTPUT.PUT\_LINE('Increase by 1');

RETURN test\_max(p\_add + 1);

END;

BEGIN

DBMS\_OUTPUT.PUT\_LINE(test\_max(3));

END;

Subfunction test\_max invokes subfunction add\_one, which also invokes subfunction test\_max, so a forward declaration is required for one of the subprograms, which is implemented for add\_one at the beginning of the anonymous block declaration section.

The resulting output from the anonymous block is as follows:

Increase by 1

Increase by 1

Final value is 5

#### Overloading Subprograms

Generally, subprograms of the same type (subprocedure or subfunction) with the same name, and same formal parameter specification can appear multiple times within the same standalone program as long as they are not sibling blocks (that is, the subprograms are not declared in the same local block).

Each subprogram can be individually invoked depending upon the use of qualifiers and the location where the subprogram invocation is made as discussed in the previous sections.

It is however possible to declare subprograms, even as siblings, that are of the same subprogram type and name as long as certain aspects of the formal parameters differ. These characteristics (subprogram type, name, and formal parameter specification) is generally known as a program’s *signature*.

The declaration of multiple subprograms where the signatures are identical except for certain aspects of the formal parameter specification is referred to as subprogram *overloading*.

Thus, the determination of which particular overloaded subprogram is to be invoked is determined by a match of the actual parameters specified by the subprogram invocation and the formal parameter lists of the overloaded subprograms.

Any of the following differences permit overloaded subprograms:
 - The number of formal parameters are different.
 - At least one pair of data types of the corresponding formal parameters (that is, compared according to the same order of appearance in the formal parameter list) are different, but are not aliases. Data type aliases are discussed later in this section.

Note that the following differences alone do not permit overloaded subprograms:
 - Different formal parameter names
 - Different parameter modes (IN, IN OUT, OUT) for the corresponding formal parameters
 - For subfunctions, different data types in the RETURN clause

As previously indicated, one of the differences allowing overloaded subprograms are different data types.

However, certain data types have alternative names referred to as *aliases*, which can be used for the table definition.

For example, there are fixed length character data types that can be specified as CHAR or CHARACTER. There are variable length character data types that can be specified as CHAR VARYING, CHARACTER VARYING, VARCHAR, or VARCHAR2. For integers, there are BINARY\_INTEGER, PLS\_INTEGER, and INTEGER data types. For numbers, there are NUMBER, NUMERIC, DEC, and DECIMAL data types.

For detailed information about the data types supported by Advanced Server, please see the Database Compatibility for Oracle Developers Reference Guide, available from EnterpriseDB at:

<http://www.enterprisedb.com/products-services-training/products/documentation>

Thus, when attempting to create overloaded subprograms, the formal parameter data types are not considered different if the specified data types are aliases of each other.

It can be determined if certain data types are aliases of other types by displaying the table definition containing the data types in question.

For example, the following table definition contains some data types and their aliases.

CREATE TABLE data\_type\_aliases (

dt\_BLOB BLOB,

dt\_LONG\_RAW LONG RAW,

dt\_RAW RAW(4),

dt\_BYTEA BYTEA,

dt\_INTEGER INTEGER,

dt\_BINARY\_INTEGER BINARY\_INTEGER,

dt\_PLS\_INTEGER PLS\_INTEGER,

dt\_REAL REAL,

dt\_DOUBLE\_PRECISION DOUBLE PRECISION,

dt\_FLOAT FLOAT,

dt\_NUMBER NUMBER,

dt\_DECIMAL DECIMAL,

dt\_NUMERIC NUMERIC,

dt\_CHAR CHAR,

dt\_CHARACTER CHARACTER,

dt\_VARCHAR2 VARCHAR2(4),

dt\_CHAR\_VARYING CHAR VARYING(4),

dt\_VARCHAR VARCHAR(4)

);

Using the PSQL \\d command to display the table definition, the Type column displays the data type internally assigned to each column based upon its data type in the table definition:

\\d data\_type\_aliases

Column | Type | Modifiers

\---------------------+----------------------+-----------

dt\_blob | bytea |

dt\_long\_raw | bytea |

dt\_raw | bytea(4) |

dt\_bytea | bytea |

dt\_integer | integer |

dt\_binary\_integer | integer |

dt\_pls\_integer | integer |

dt\_real | real |

dt\_double\_precision | double precision |

dt\_float | double precision |

dt\_number | numeric |

dt\_decimal | numeric |

dt\_numeric | numeric |

dt\_char | character(1) |

dt\_character | character(1) |

dt\_varchar2 | character varying(4) |

dt\_char\_varying | character varying(4) |

dt\_varchar | character varying(4) |

In the example, the base set of data types are bytea, integer, real, double precision, numeric, character, and character varying.

When attempting to declare overloaded subprograms, a pair of formal parameter data types that are aliases would not be sufficient to allow subprogram overloading. Thus, parameters with data types INTEGER and PLS\_INTEGER cannot overload a pair of subprograms, but data types INTEGER and REAL, or INTEGER and FLOAT, or INTEGER and NUMBER can overload the subprograms.

**Note:** The overloading rules based upon formal parameter data types are not compatible with Oracle databases. Generally, the Advanced Server rules are more flexible, and certain combinations are allowed in Advanced Server that would result in an error when attempting to create the procedure or function in Oracle databases.

For certain pairs of data types used for overloading, casting of the arguments specified by the subprogram invocation may be required to avoid an error encountered during runtime of the subprogram. Invocation of a subprogram must include the actual parameter list that can specifically identify the data types. Certain pairs of overloaded data types may require the CAST function to explicitly identify data types. For example, pairs of overloaded data types that may require casting during the invocation are CHAR and VARCHAR2, or NUMBER and REAL.

The following example shows a group of overloaded subfunctions invoked from within an anonymous block. The executable section of the anonymous block contains the use of the CAST function to invoke overloaded functions with certain data types.

DECLARE

FUNCTION add\_it (

p\_add\_1 IN BINARY\_INTEGER,

p\_add\_2 IN BINARY\_INTEGER

) RETURN VARCHAR2

IS

BEGIN

RETURN 'add\_it BINARY\_INTEGER: ' || TO\_CHAR(p\_add\_1 + p\_add\_2,9999.9999);

END add\_it;

FUNCTION add\_it (

p\_add\_1 IN NUMBER,

p\_add\_2 IN NUMBER

) RETURN VARCHAR2

IS

BEGIN

RETURN 'add\_it NUMBER: ' || TO\_CHAR(p\_add\_1 + p\_add\_2,999.9999);

END add\_it;

FUNCTION add\_it (

p\_add\_1 IN REAL,

p\_add\_2 IN REAL

) RETURN VARCHAR2

IS

BEGIN

RETURN 'add\_it REAL: ' || TO\_CHAR(p\_add\_1 + p\_add\_2,9999.9999);

END add\_it;

FUNCTION add\_it (

p\_add\_1 IN DOUBLE PRECISION,

p\_add\_2 IN DOUBLE PRECISION

) RETURN VARCHAR2

IS

BEGIN

RETURN 'add\_it DOUBLE PRECISION: ' || TO\_CHAR(p\_add\_1 + p\_add\_2,9999.9999);

END add\_it;

BEGIN

DBMS\_OUTPUT.PUT\_LINE(add\_it (25, 50));

DBMS\_OUTPUT.PUT\_LINE(add\_it (25.3333, 50.3333));

DBMS\_OUTPUT.PUT\_LINE(add\_it (TO\_NUMBER(25.3333), TO\_NUMBER(50.3333)));

DBMS\_OUTPUT.PUT\_LINE(add\_it (CAST('25.3333' AS REAL), CAST('50.3333' AS REAL)));

DBMS\_OUTPUT.PUT\_LINE(add\_it (CAST('25.3333' AS DOUBLE PRECISION),

CAST('50.3333' AS DOUBLE PRECISION)));

END;

The following is the output displayed from the anonymous block:

add\_it BINARY\_INTEGER: 75.0000

add\_it NUMBER: 75.6666

add\_it NUMBER: 75.6666

add\_it REAL: 75.6666

add\_it DOUBLE PRECISION: 75.6666

#### Accessing Subprogram Variables

Variable declared in blocks such as subprograms or anonymous blocks can be accessed from the executable section or the exception section of other blocks depending upon their relative location.

Accessing a variable means being able to reference it within a SQL statement or an SPL statement as is done with any local variable.

**Note:** If the subprogram signature contains formal parameters, these may be accessed in the same manner as local variables of the subprogram. In this section, all discussion related to variables of a subprogram also applies to formal parameters of the subprogram.

Access of variables not only includes those defined as a data type, but also includes others such as record types, collection types, and cursors.

The variable may be accessed by at most one qualifier, which is the name of the subprogram or labeled anonymous block in which the variable has been locally declared.

The syntax to reference a variable is shown by the following:

\[*qualifier*.\]*variable*

If specified, *qualifier* is the subprogram or labeled anonymous block in which *variable* has been declared in its declaration section (that is, it is a local variable).

**Note:** In Advanced Server, there is only one circumstance where two qualifiers are permitted. This scenario is for accessing public variables of packages where the reference can be specified in the following format:

*schema\_name*.*package\_name*.*public\_variable\_name*

For more information about supported package syntax, please see the Database Compatibility for Oracle Developers Built-In Packages Guide.

The following summarizes how variables can be accessed:
 - Variables can be accessed as long as the block in which the variable has been locally declared is within the ancestor hierarchical path starting from the block containing the reference to the variable. Such variables declared in ancestor blocks are referred to as *global variables*.
 - If a reference to an unqualified variable is made, the first attempt is to locate a local variable of that name. If such a local variable does not exist, then the search for the variable is made in the parent of the current block, and so forth, proceeding up the ancestor hierarchy. If such a variable is not found, then an error occurs upon invocation of the subprogram.
 - If a reference to a qualified variable is made, the same search process is performed as described in the previous bullet point, but searching for the first match of the subprogram or labeled anonymous block that contains the local variable. The search proceeds up the ancestor hierarchy until a match is found. If such a match is not found, then an error occurs upon invocation of the subprogram.

The following location of variables cannot be accessed relative to the block from where the reference to the variable is made:
 - Variables declared in a descendent block cannot be accessed,
 - Variables declared in a sibling block, a sibling block of an ancestor block, or any descendants within the sibling block cannot be accessed.

**Note:** The Advanced Server process for accessing variables is not compatible with Oracle databases. For Oracle, any number of qualifiers can be specified and the search is based upon the first match of the first qualifier in a similar manner to the Oracle matching algorithm for invoking subprograms.

The following example displays how variables in various blocks are accessed, with and without qualifiers. The lines that are commented out illustrate attempts to access variables that would result in an error.

CREATE OR REPLACE PROCEDURE level\_0

IS

v\_level\_0 VARCHAR2(20) := 'Value from level\_0';

PROCEDURE level\_1a

IS

v\_level\_1a VARCHAR2(20) := 'Value from level\_1a';

PROCEDURE level\_2a

IS

v\_level\_2a VARCHAR2(20) := 'Value from level\_2a';

BEGIN

DBMS\_OUTPUT.PUT\_LINE('...... BLOCK level\_2a');

DBMS\_OUTPUT.PUT\_LINE('........ v\_level\_2a: ' || v\_level\_2a);

DBMS\_OUTPUT.PUT\_LINE('........ v\_level\_1a: ' || v\_level\_1a);

DBMS\_OUTPUT.PUT\_LINE('........ level\_1a.v\_level\_1a: ' ||

level\_1a.v\_level\_1a);

DBMS\_OUTPUT.PUT\_LINE('........ v\_level\_0: ' || v\_level\_0);

DBMS\_OUTPUT.PUT\_LINE('........ level\_0.v\_level\_0: ' || level\_0.v\_level\_0);

DBMS\_OUTPUT.PUT\_LINE('...... END BLOCK level\_2a');

END level\_2a;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('.. BLOCK level\_1a');

level\_2a;

\-- DBMS\_OUTPUT.PUT\_LINE('.... v\_level\_2a: ' || v\_level\_2a);

\-- Error - Descendent block ----^

\-- DBMS\_OUTPUT.PUT\_LINE('.... level\_2a.v\_level\_2a: ' || level\_2a.v\_level\_2a);

\-- Error - Descendent block ---------------^

DBMS\_OUTPUT.PUT\_LINE('.. END BLOCK level\_1a');

END level\_1a;

PROCEDURE level\_1b

IS

v\_level\_1b VARCHAR2(20) := 'Value from level\_1b';

BEGIN

DBMS\_OUTPUT.PUT\_LINE('.. BLOCK level\_1b');

DBMS\_OUTPUT.PUT\_LINE('.... v\_level\_1b: ' || v\_level\_1b);

DBMS\_OUTPUT.PUT\_LINE('.... v\_level\_0 : ' || v\_level\_0);

\-- DBMS\_OUTPUT.PUT\_LINE('.... level\_1a.v\_level\_1a: ' || level\_1a.v\_level\_1a);

\-- Error - Sibling block -----------------^

\-- DBMS\_OUTPUT.PUT\_LINE('.... level\_2a.v\_level\_2a: ' || level\_2a.v\_level\_2a);

\-- Error - Sibling block descendant ------^

DBMS\_OUTPUT.PUT\_LINE('.. END BLOCK level\_1b');

END level\_1b;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('BLOCK level\_0');

DBMS\_OUTPUT.PUT\_LINE('.. v\_level\_0: ' || v\_level\_0);

level\_1a;

level\_1b;

DBMS\_OUTPUT.PUT\_LINE('END BLOCK level\_0');

END level\_0;

The following is the output showing the content of each variable when the procedure is invoked:

BEGIN

level\_0;

END;

BLOCK level\_0

.. v\_level\_0: Value from level\_0

.. BLOCK level\_1a

...... BLOCK level\_2a

........ v\_level\_2a: Value from level\_2a

........ v\_level\_1a: Value from level\_1a

........ level\_1a.v\_level\_1a: Value from level\_1a

........ v\_level\_0: Value from level\_0

........ level\_0.v\_level\_0: Value from level\_0

...... END BLOCK level\_2a

.. END BLOCK level\_1a

.. BLOCK level\_1b

.... v\_level\_1b: Value from level\_1b

.... v\_level\_0 : Value from level\_0

.. END BLOCK level\_1b

END BLOCK level\_0

The following example shows similar access attempts when all variables in all blocks have the same name:

CREATE OR REPLACE PROCEDURE level\_0

IS

v\_common VARCHAR2(20) := 'Value from level\_0';

PROCEDURE level\_1a

IS

v\_common VARCHAR2(20) := 'Value from level\_1a';

PROCEDURE level\_2a

IS

v\_common VARCHAR2(20) := 'Value from level\_2a';

BEGIN

DBMS\_OUTPUT.PUT\_LINE('...... BLOCK level\_2a');

DBMS\_OUTPUT.PUT\_LINE('........ v\_common: ' || v\_common);

DBMS\_OUTPUT.PUT\_LINE('........ level\_2a.v\_common: ' || level\_2a.v\_common);

DBMS\_OUTPUT.PUT\_LINE('........ level\_1a.v\_common: ' || level\_1a.v\_common);

DBMS\_OUTPUT.PUT\_LINE('........ level\_0.v\_common: ' || level\_0.v\_common);

DBMS\_OUTPUT.PUT\_LINE('...... END BLOCK level\_2a');

END level\_2a;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('.. BLOCK level\_1a');

DBMS\_OUTPUT.PUT\_LINE('.... v\_common: ' || v\_common);

DBMS\_OUTPUT.PUT\_LINE('.... level\_0.v\_common: ' || level\_0.v\_common);

level\_2a;

DBMS\_OUTPUT.PUT\_LINE('.. END BLOCK level\_1a');

END level\_1a;

PROCEDURE level\_1b

IS

v\_common VARCHAR2(20) := 'Value from level\_1b';

BEGIN

DBMS\_OUTPUT.PUT\_LINE('.. BLOCK level\_1b');

DBMS\_OUTPUT.PUT\_LINE('.... v\_common: ' || v\_common);

DBMS\_OUTPUT.PUT\_LINE('.... level\_0.v\_common : ' || level\_0.v\_common);

DBMS\_OUTPUT.PUT\_LINE('.. END BLOCK level\_1b');

END level\_1b;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('BLOCK level\_0');

DBMS\_OUTPUT.PUT\_LINE('.. v\_common: ' || v\_common);

level\_1a;

level\_1b;

DBMS\_OUTPUT.PUT\_LINE('END BLOCK level\_0');

END level\_0;

The following is the output showing the content of each variable when the procedure is invoked:

BEGIN

level\_0;

END;

BLOCK level\_0

.. v\_common: Value from level\_0

.. BLOCK level\_1a

.... v\_common: Value from level\_1a

.... level\_0.v\_common: Value from level\_0

...... BLOCK level\_2a

........ v\_common: Value from level\_2a

........ level\_2a.v\_common: Value from level\_2a

........ level\_1a.v\_common: Value from level\_1a

........ level\_0.v\_common: Value from level\_0

...... END BLOCK level\_2a

.. END BLOCK level\_1a

.. BLOCK level\_1b

.... v\_common: Value from level\_1b

.... level\_0.v\_common : Value from level\_0

.. END BLOCK level\_1b

END BLOCK level\_0

As previously discussed, the labels on anonymous blocks can also be used to qualify access to variables. The following example shows variable access within a set of nested anonymous blocks:

DECLARE

v\_common VARCHAR2(20) := 'Value from level\_0';

BEGIN

DBMS\_OUTPUT.PUT\_LINE('BLOCK level\_0');

DBMS\_OUTPUT.PUT\_LINE('.. v\_common: ' || v\_common);

\<\<level\_1a\>\>

DECLARE

v\_common VARCHAR2(20) := 'Value from level\_1a';

BEGIN

DBMS\_OUTPUT.PUT\_LINE('.. BLOCK level\_1a');

DBMS\_OUTPUT.PUT\_LINE('.... v\_common: ' || v\_common);

\<\<level\_2a\>\>

DECLARE

v\_common VARCHAR2(20) := 'Value from level\_2a';

BEGIN

DBMS\_OUTPUT.PUT\_LINE('...... BLOCK level\_2a');

DBMS\_OUTPUT.PUT\_LINE('........ v\_common: ' || v\_common);

DBMS\_OUTPUT.PUT\_LINE('........ level\_1a.v\_common: ' || level\_1a.v\_common);

DBMS\_OUTPUT.PUT\_LINE('...... END BLOCK level\_2a');

END;

DBMS\_OUTPUT.PUT\_LINE('.. END BLOCK level\_1a');

END;

\<\<level\_1b\>\>

DECLARE

v\_common VARCHAR2(20) := 'Value from level\_1b';

BEGIN

DBMS\_OUTPUT.PUT\_LINE('.. BLOCK level\_1b');

DBMS\_OUTPUT.PUT\_LINE('.... v\_common: ' || v\_common);

DBMS\_OUTPUT.PUT\_LINE('.... level\_1b.v\_common: ' || level\_1b.v\_common);

DBMS\_OUTPUT.PUT\_LINE('.. END BLOCK level\_1b');

END;

DBMS\_OUTPUT.PUT\_LINE('END BLOCK level\_0');

END;

The following is the output showing the content of each variable when the anonymous block is invoked:

BLOCK level\_0

.. v\_common: Value from level\_0

.. BLOCK level\_1a

.... v\_common: Value from level\_1a

...... BLOCK level\_2a

........ v\_common: Value from level\_2a

........ level\_1a.v\_common: Value from level\_1a

...... END BLOCK level\_2a

.. END BLOCK level\_1a

.. BLOCK level\_1b

.... v\_common: Value from level\_1b

.... level\_1b.v\_common: Value from level\_1b

.. END BLOCK level\_1b

END BLOCK level\_0

The following example is an object type whose object type method, display\_emp, contains record type emp\_typ and subprocedure emp\_sal\_query. Record variable r\_emp declared locally to emp\_sal\_query is able to access the record type emp\_typ declared in the parent block display\_emp.

CREATE OR REPLACE TYPE emp\_pay\_obj\_typ AS OBJECT

(

empno NUMBER(4),

MEMBER PROCEDURE display\_emp(SELF IN OUT emp\_pay\_obj\_typ)

);

CREATE OR REPLACE TYPE BODY emp\_pay\_obj\_typ AS

MEMBER PROCEDURE display\_emp (SELF IN OUT emp\_pay\_obj\_typ)

IS

TYPE emp\_typ IS RECORD (

ename emp.ename%TYPE,

job emp.job%TYPE,

hiredate emp.hiredate%TYPE,

sal emp.sal%TYPE,

deptno emp.deptno%TYPE

);

PROCEDURE emp\_sal\_query (

p\_empno IN emp.empno%TYPE

)

IS

r\_emp emp\_typ;

v\_avgsal emp.sal%TYPE;

BEGIN

SELECT ename, job, hiredate, sal, deptno

INTO r\_emp.ename, r\_emp.job, r\_emp.hiredate, r\_emp.sal, r\_emp.deptno

FROM emp WHERE empno = p\_empno;

DBMS\_OUTPUT.PUT\_LINE('Employee \# : ' || p\_empno);

DBMS\_OUTPUT.PUT\_LINE('Name : ' || r\_emp.ename);

DBMS\_OUTPUT.PUT\_LINE('Job : ' || r\_emp.job);

DBMS\_OUTPUT.PUT\_LINE('Hire Date : ' || r\_emp.hiredate);

DBMS\_OUTPUT.PUT\_LINE('Salary : ' || r\_emp.sal);

DBMS\_OUTPUT.PUT\_LINE('Dept \# : ' || r\_emp.deptno);

SELECT AVG(sal) INTO v\_avgsal

FROM emp WHERE deptno = r\_emp.deptno;

IF r\_emp.sal \> v\_avgsal THEN

DBMS\_OUTPUT.PUT\_LINE('Employee''s salary is more than the '

|| 'department average of ' || v\_avgsal);

ELSE

DBMS\_OUTPUT.PUT\_LINE('Employee''s salary does not exceed the '

|| 'department average of ' || v\_avgsal);

END IF;

END;

BEGIN

emp\_sal\_query(SELF.empno);

END;

END;

The following is the output displayed when an instance of the object type is created and procedure display\_emp is invoked:

DECLARE

v\_emp EMP\_PAY\_OBJ\_TYP;

BEGIN

v\_emp := emp\_pay\_obj\_typ(7900);

v\_emp.display\_emp;

END;

Employee \# : 7900

Name : JAMES

Job : CLERK

Hire Date : 03-DEC-81 00:00:00

Salary : 950.00

Dept \# : 30

Employee's salary does not exceed the department average of 1566.67

The following example is a package with three levels of subprocedures. A record type, collection type, and cursor type declared in the upper level procedure can be accessed by the descendent subprocedure.

CREATE OR REPLACE PACKAGE emp\_dept\_pkg

IS

PROCEDURE display\_emp (

p\_deptno NUMBER

);

END;

CREATE OR REPLACE PACKAGE BODY emp\_dept\_pkg

IS

PROCEDURE display\_emp (

p\_deptno NUMBER

)

IS

TYPE emp\_rec\_typ IS RECORD (

empno emp.empno%TYPE,

ename emp.ename%TYPE

);

TYPE emp\_arr\_typ IS TABLE OF emp\_rec\_typ INDEX BY BINARY\_INTEGER;

TYPE emp\_cur\_type IS REF CURSOR RETURN emp\_rec\_typ;

PROCEDURE emp\_by\_dept (

p\_deptno emp.deptno%TYPE

)

IS

emp\_arr emp\_arr\_typ;

emp\_refcur emp\_cur\_type;

i BINARY\_INTEGER := 0;

PROCEDURE display\_emp\_arr

IS

BEGIN

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME');

DBMS\_OUTPUT.PUT\_LINE('----- -------');

FOR j IN emp\_arr.FIRST .. emp\_arr.LAST LOOP

DBMS\_OUTPUT.PUT\_LINE(emp\_arr(j).empno || ' ' ||

emp\_arr(j).ename);

END LOOP;

END display\_emp\_arr;

BEGIN

OPEN emp\_refcur FOR SELECT empno, ename FROM emp WHERE deptno = p\_deptno;

LOOP

i := i + 1;

FETCH emp\_refcur INTO emp\_arr(i).empno, emp\_arr(i).ename;

EXIT WHEN emp\_refcur%NOTFOUND;

END LOOP;

CLOSE emp\_refcur;

display\_emp\_arr;

END emp\_by\_dept;

BEGIN

emp\_by\_dept(p\_deptno);

END;

END;

The following is the output displayed when the top level package procedure is invoked:

BEGIN

emp\_dept\_pkg.display\_emp(20);

END;

EMPNO ENAME

\----- -------

7369 SMITH

7566 JONES

7788 SCOTT

7876 ADAMS

7902 FORD

### Compilation Errors in Procedures and Functions

When the Advanced Server parsers compile a procedure or function, they confirm that both the CREATE statement and the program body (that portion of the program that follows the AS keyword) conforms to the grammar rules for SPL and SQL constructs. By default, the server will terminate the compilation process if a parser detects an error. Note that the parsers detect syntax errors in expressions, but not semantic errors (i.e. an expression referencing a non-existent column, table, or function, or a value of incorrect type).

spl.max\_error\_count instructs the server to stop parsing if it encounters the specified number of errors in SPL code, or when it encounters an error in SQL code. The default value of spl.max\_error\_count is 10; the maximum value is 1000. Setting spl.max\_error\_count to a value of 1 instructs the server to stop parsing when it encounters the first error in either SPL or SQL code.

You can use the SET command to specify a value for spl.max\_error\_count for your current session. The syntax is:

> SET spl.max\_error\_count = *number\_of\_errors*

Where *number\_of\_errors* specifies the number of SPL errors that may occur before the server halts the compilation process. For example:

> SET spl.max\_error\_count = 6

The example instructs the server to continue past the first five SPL errors it encounters. When the server encounters the sixth error it will stop validating, and print six detailed error messages, and one error summary.

To save time when developing new code, or when importing existing code from another source, you may want to set the spl.max\_error\_count configuration parameter to a relatively high number of errors.

Please note that if you instruct the server to continue parsing in spite of errors in the SPL code in a program body, and the parser encounters an error in a segment of SQL code, there may still be errors in any SPL or SQL code that follows the erroneous SQL code. For example, the following function results in two errors:

> CREATE FUNCTION computeBonus(baseSalary number) RETURN number AS
> BEGIN
>
> bonus := baseSalary \* 1.10;
> total := bonus + 100;
>
> RETURN bonus;
> END;
>
> ERROR: "bonus" is not a known variable
> LINE 4: bonus := baseSalary \* 1.10;
> ^
> ERROR: "total" is not a known variable
> LINE 5: total := bonus + 100;
> ^
> ERROR: compilation of SPL function/procedure "computebonus" failed due to 2 errors

The following example adds a SELECT statement to the previous example. The error in the SELECT statement masks the other errors that follow:

> CREATE FUNCTION computeBonus(employeeName number) RETURN number AS
> BEGIN
> SELECT salary INTO baseSalary FROM emp
> WHERE ename = employeeName;
>
> bonus := baseSalary \* 1.10;
> total := bonus + 100;
>
> RETURN bonus;
>
> END;
>
> ERROR: "basesalary" is not a known variable
> LINE 3: SELECT salary INTO baseSalary FROM emp WHERE ename = emp...

### Program Security

Security over what user may execute an SPL program and what database objects an SPL program may access for any given user executing the program is controlled by the following:
 - Privilege to execute a program.
 - Privileges granted on the database objects (including other SPL programs) which a program attempts to access.
 - Whether the program is defined with definer’s rights or invoker’s rights.

These aspects are discussed in the following sections.

#### EXECUTE Privilege

An SPL program (function, procedure, or package) can begin execution only if any of the following are true:
 - The current user is a superuser, or
 - The current user has been granted EXECUTE privilege on the SPL program, or
 - The current user inherits EXECUTE privilege on the SPL program by virtue of being a member of a group which does have such privilege, or
 - EXECUTE privilege has been granted to the PUBLIC group.

Whenever an SPL program is created in Advanced Server, EXECUTE privilege is automatically granted to the PUBLIC group by default, therefore, any user can immediately execute the program.

This default privilege can be removed by using the REVOKE EXECUTE command. The following is an example:

REVOKE EXECUTE ON PROCEDURE list\_emp FROM PUBLIC;

Explicit EXECUTE privilege on the program can then be granted to individual users or groups.

GRANT EXECUTE ON PROCEDURE list\_emp TO john;

Now, user, john, can execute the list\_emp program; other users who do not meet any of the conditions listed at the beginning of this section cannot.

Once a program begins execution, the next aspect of security is what privilege checks occur if the program attempts to perform an action on any database object including:
 - Reading or modifying table or view data.
 - Creating, modifying, or deleting a database object such as a table, view, index, or sequence.
 - Obtaining the current or next value from a sequence.
 - Calling another program (function, procedure, or package).

Each such action can be protected by privileges on the database object either allowed or disallowed for the user.

Note that it is possible for a database to have more than one object of the same type with the same name, but each such object belonging to a different schema in the database. If this is the case, which object is being referenced by an SPL program? This is the topic of the next section.

#### Database Object Name Resolution

A database object inside an SPL program may either be referenced by its qualified name or by an unqualified name. A qualified name is in the form of *schema*.*name* where *schema* is the name of the schema under which the database object with identifier, *name*, exists. An unqualified name does not have the “*schema*.” portion. When a reference is made to a qualified name, there is absolutely no ambiguity as to exactly which database object is intended – it either does or does not exist in the specified schema.

Locating an object with an unqualified name, however, requires the use of the current user’s search path. When a user becomes the current user of a session, a default search path is always associated with that user. The search path consists of a list of schemas which are searched in left-to-right order for locating an unqualified database object reference. The object is considered non-existent if it can’t be found in any of the schemas in the search path. The default search path can be displayed in PSQL using the SHOW search\_path command.

SHOW search\_path;

search\_path

\----------------------

$user,public,sys,dbo

(1 row)

$user in the above search path is a generic placeholder that refers to the current user so if the current user of the above session is enterprisedb, an unqualified database object would be searched for in the following schemas in this order – first, enterprisedb, then public, then sys, and finally, dbo.

Once an unqualified name has been resolved in the search path, it can be determined if the current user has the appropriate privilege to perform the desired action on that specific object.

**Note:** The concept of the search path is not compatible with Oracle databases. For an unqualified reference, Oracle simply looks in the schema of the current user for the named database object. It also important to note that in Oracle, a user and his or her schema is the same entity while in Advanced Server, a user and a schema are two distinct objects.

#### Database Object Privileges

Once an SPL program begins execution, any attempt to access a database object from within the program results in a check to ensure the current user has the authorization to perform the intended action against the referenced object. Privileges on database objects are bestowed and removed using the GRANT and REVOKE commands, respectively. If the current user attempts unauthorized access on a database object, then the program will throw an exception. See Section <span class="underline">3.5.7</span> for information about exception handling.

The final topic discusses exactly who is the current user.

#### Definer’s vs. Invokers Rights

When an SPL program is about to begin execution, a determination is made as to what user is to be associated with this process. This user is referred to as the *current user*. The current user’s database object privileges are used to determine whether or not access to database objects referenced in the program will be permitted. The current, prevailing search path in effect when the program is invoked will be used to resolve any unqualified object references.

The selection of the current user is influenced by whether the SPL program was created with definer’s right or invoker’s rights. The AUTHID clause determines that selection. Appearance of the clause AUTHID DEFINER gives the program definer’s rights. This is also the default if the AUTHID clause is omitted. Use of the clause AUTHID CURRENT\_USER gives the program invoker’s rights. The difference between the two is summarized as follows:
 - If a program has *definer’s rights*, then the owner of the program becomes the current user when program execution begins. The program owner’s database object privileges are used to determine if access to a referenced object is permitted. In a definer’s rights program, it is irrelevant as to which user actually invoked the program.
 - If a program has *invoker’s rights*, then the current user at the time the program is called remains the current user while the program is executing (but not necessarily within called subprograms – see the following bullet points). When an invoker’s rights program is invoked, the current user is typically the user that started the session (i.e., made the database connection) although it is possible to change the current user after the session has started using the SET ROLE command. In an invoker’s rights program, it is irrelevant as to which user actually owns the program.

From the previous definitions, the following observations can be made:
 - If a definer’s rights program calls a definer’s rights program, the current user changes from the owner of the calling program to the owner of the called program during execution of the called program.
 - If a definer’s rights program calls an invoker’s rights program, the owner of the calling program remains the current user during execution of both the calling and called programs.
 - If an invoker’s rights program calls an invoker’s rights program, the current user of the calling program remains the current user during execution of the called program.
 - If an invokers’ rights program calls a definer’s rights program, the current user switches to the owner of the definer’s rights program during execution of the called program.

The same principles apply if the called program in turn calls another program in the cases cited above.

This section on security concludes with an example using the sample application.

#### Security Example

In the following example, a new database will be created along with two users – hr\_mgr who will own a copy of the entire sample application in schema, hr\_mgr; and sales\_mgr who will own a schema named, sales\_mgr, that will have a copy of only the emp table containing only the employees who work in sales.

The procedure list\_emp, function hire\_clerk, and package emp\_admin will be used in this example. All of the default privileges that are granted upon installation of the sample application will be removed and then be explicitly re-granted so as to present a more secure environment in this example.

Programs list\_emp and hire\_clerk will be changed from the default of definer’s rights to invoker’s rights. It will be then illustrated that when sales\_mgr runs these programs, they act upon the emp table in sales\_mgr’s schema since sales\_mgr’s search path and privileges will be used for name resolution and authorization checking.

Programs get\_dept\_name and hire\_emp in the emp\_admin package will then be executed by sales\_mgr. In this case, the dept table and emp table in hr\_mgr’s schema will be accessed as hr\_mgr is the owner of the emp\_admin package which is using definer’s rights. Since the default search path is in effect with the $user placeholder, the schema matching the user (in this case, hr\_mgr) is used to find the tables.

Step 1 – Create Database and Users

As user enterprisedb, create the hr database:

CREATE DATABASE hr;

Switch to the hr database and create the users:

\\c hr enterprisedb

CREATE USER hr\_mgr IDENTIFIED BY password;

CREATE USER sales\_mgr IDENTIFIED BY password;

Step 2 – Create the Sample Application

Create the entire sample application, owned by hr\_mgr, in hr\_mgr’s schema.

\\c - hr\_mgr

\\i /opt/edb/as10/installer/server/edb-sample.sql

BEGIN

CREATE TABLE

CREATE TABLE

CREATE TABLE

CREATE VIEW

CREATE SEQUENCE

.

.

.

CREATE PACKAGE

CREATE PACKAGE BODY

COMMIT

Step 3 – Create the emp Table in Schema sales\_mgr

Create a subset of the emp table owned by sales\_mgr in sales\_mgr’s schema.

\\c – hr\_mgr

GRANT USAGE ON SCHEMA hr\_mgr TO sales\_mgr;

\\c – sales\_mgr

CREATE TABLE emp AS SELECT \* FROM hr\_mgr.emp WHERE job = 'SALESMAN';

In the above example, the GRANT USAGE ON SCHEMA command is given to allow sales\_mgr access into hr\_mgr’s schema to make a copy of hr\_mgr’s emp table. This step is required in Advanced Server and is not compatible with Oracle databases since Oracle does not have the concept of a schema that is distinct from its user.

Step 4 – Remove Default Privileges

Remove all privileges to later illustrate the minimum required privileges needed.

\\c – hr\_mgr

REVOKE USAGE ON SCHEMA hr\_mgr FROM sales\_mgr;

REVOKE ALL ON dept FROM PUBLIC;

REVOKE ALL ON emp FROM PUBLIC;

REVOKE ALL ON next\_empno FROM PUBLIC;

REVOKE EXECUTE ON FUNCTION new\_empno() FROM PUBLIC;

REVOKE EXECUTE ON PROCEDURE list\_emp FROM PUBLIC;

REVOKE EXECUTE ON FUNCTION hire\_clerk(VARCHAR2,NUMBER) FROM PUBLIC;

REVOKE EXECUTE ON PACKAGE emp\_admin FROM PUBLIC;

Step 5 – Change list\_emp to Invoker’s Rights

While connected as user, hr\_mgr, add the AUTHID CURRENT\_USER clause to the list\_emp program and resave it in Advanced Server. When performing this step, be sure you are logged on as hr\_mgr, otherwise the modified program may wind up in the public schema instead of in hr\_mgr’s schema.

CREATE OR REPLACE PROCEDURE list\_emp

AUTHID CURRENT\_USER

IS

v\_empno NUMBER(4);

v\_ename VARCHAR2(10);

CURSOR emp\_cur IS

SELECT empno, ename FROM emp ORDER BY empno;

BEGIN

OPEN emp\_cur;

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME');

DBMS\_OUTPUT.PUT\_LINE('----- -------');

LOOP

FETCH emp\_cur INTO v\_empno, v\_ename;

EXIT WHEN emp\_cur%NOTFOUND;

DBMS\_OUTPUT.PUT\_LINE(v\_empno || ' ' || v\_ename);

END LOOP;

CLOSE emp\_cur;

END;

Step 6 – Change hire\_clerk to Invoker’s Rights and Qualify Call to new\_empno

While connected as user, hr\_mgr, add the AUTHID CURRENT\_USER clause to the hire\_clerk program.

Also, after the BEGIN statement, fully qualify the reference, new\_empno, to hr\_mgr.new\_empno in order to ensure the hire\_clerk function call to the new\_empno function resolves to the hr\_mgr schema.

When resaving the program, be sure you are logged on as hr\_mgr, otherwise the modified program may wind up in the public schema instead of in hr\_mgr’s schema.

CREATE OR REPLACE FUNCTION hire\_clerk (

p\_ename VARCHAR2,

p\_deptno NUMBER

) RETURN NUMBER

AUTHID CURRENT\_USER

IS

v\_empno NUMBER(4);

v\_ename VARCHAR2(10);

v\_job VARCHAR2(9);

v\_mgr NUMBER(4);

v\_hiredate DATE;

v\_sal NUMBER(7,2);

v\_comm NUMBER(7,2);

v\_deptno NUMBER(2);

BEGIN

v\_empno := hr\_mgr.new\_empno;

INSERT INTO emp VALUES (v\_empno, p\_ename, 'CLERK', 7782,

TRUNC(SYSDATE), 950.00, NULL, p\_deptno);

SELECT empno, ename, job, mgr, hiredate, sal, comm, deptno INTO

v\_empno, v\_ename, v\_job, v\_mgr, v\_hiredate, v\_sal, v\_comm, v\_deptno

FROM emp WHERE empno = v\_empno;

DBMS\_OUTPUT.PUT\_LINE('Department : ' || v\_deptno);

DBMS\_OUTPUT.PUT\_LINE('Employee No: ' || v\_empno);

DBMS\_OUTPUT.PUT\_LINE('Name : ' || v\_ename);

DBMS\_OUTPUT.PUT\_LINE('Job : ' || v\_job);

DBMS\_OUTPUT.PUT\_LINE('Manager : ' || v\_mgr);

DBMS\_OUTPUT.PUT\_LINE('Hire Date : ' || v\_hiredate);

DBMS\_OUTPUT.PUT\_LINE('Salary : ' || v\_sal);

DBMS\_OUTPUT.PUT\_LINE('Commission : ' || v\_comm);

RETURN v\_empno;

EXCEPTION

WHEN OTHERS THEN

DBMS\_OUTPUT.PUT\_LINE('The following is SQLERRM:');

DBMS\_OUTPUT.PUT\_LINE(SQLERRM);

DBMS\_OUTPUT.PUT\_LINE('The following is SQLCODE:');

DBMS\_OUTPUT.PUT\_LINE(SQLCODE);

RETURN -1;

END;

Step 7 – Grant Required Privileges

While connected as user, hr\_mgr, grant the privileges needed so sales\_mgr can execute the list\_emp procedure, hire\_clerk function, and emp\_admin package. Note that the only data object sales\_mgr has access to is the emp table in the sales\_mgr schema. sales\_mgr has no privileges on any table in the hr\_mgr schema.

GRANT USAGE ON SCHEMA hr\_mgr TO sales\_mgr;

GRANT EXECUTE ON PROCEDURE list\_emp TO sales\_mgr;

GRANT EXECUTE ON FUNCTION hire\_clerk(VARCHAR2,NUMBER) TO sales\_mgr;

GRANT EXECUTE ON FUNCTION new\_empno() TO sales\_mgr;

GRANT EXECUTE ON PACKAGE emp\_admin TO sales\_mgr;

Step 8 – Run Programs list\_emp and hire\_clerk

Connect as user, sales\_mgr, and run the following anonymous block:

\\c – sales\_mgr

DECLARE

v\_empno NUMBER(4);

BEGIN

hr\_mgr.list\_emp;

DBMS\_OUTPUT.PUT\_LINE('\*\*\* Adding new employee \*\*\*');

v\_empno := hr\_mgr.hire\_clerk('JONES',40);

DBMS\_OUTPUT.PUT\_LINE('\*\*\* After new employee added \*\*\*');

hr\_mgr.list\_emp;

END;

EMPNO ENAME

\----- -------

7499 ALLEN

7521 WARD

7654 MARTIN

7844 TURNER

\*\*\* Adding new employee \*\*\*

Department : 40

Employee No: 8000

Name : JONES

Job : CLERK

Manager : 7782

Hire Date : 08-NOV-07 00:00:00

Salary : 950.00

\*\*\* After new employee added \*\*\*

EMPNO ENAME

\----- -------

7499 ALLEN

7521 WARD

7654 MARTIN

7844 TURNER

8000 JONES

The table and sequence accessed by the programs of the anonymous block are illustrated in the following diagram. The gray ovals represent the schemas of sales\_mgr and hr\_mgr. The current user during each program execution is shown within parenthesis in bold red font.

Figure 3 - Invoker's Rights Programs

Selecting from sales\_mgr’s emp table shows that the update was made in this table.

SELECT empno, ename, hiredate, sal, deptno, hr\_mgr.emp\_admin.get\_dept\_name(deptno) FROM sales\_mgr.emp;

empno | ename | hiredate | sal | deptno | get\_dept\_name

\-------+--------+--------------------+---------+--------+---------------

7499 | ALLEN | 20-FEB-81 00:00:00 | 1600.00 | 30 | SALES

7521 | WARD | 22-FEB-81 00:00:00 | 1250.00 | 30 | SALES

7654 | MARTIN | 28-SEP-81 00:00:00 | 1250.00 | 30 | SALES

7844 | TURNER | 08-SEP-81 00:00:00 | 1500.00 | 30 | SALES

8000 | JONES | 08-NOV-07 00:00:00 | 950.00 | 40 | OPERATIONS

(5 rows)

The following diagram shows that the SELECT command references the emp table in the sales\_mgr schema, but the dept table referenced by the get\_dept\_name function in the emp\_admin package is from the hr\_mgr schema since the emp\_admin package has definer’s rights and is owned by hr\_mgr. The default search path setting with the $user placeholder resolves the access by user hr\_mgr to the dept table in the hr\_mgr schema.

Figure 4 Definer's Rights Package

Step 9 – Run Program hire\_emp in the emp\_admin Package

While connected as user, sales\_mgr, run the hire\_emp procedure in the emp\_admin package.

EXEC hr\_mgr.emp\_admin.hire\_emp(9001, 'ALICE','SALESMAN',8000,TRUNC(SYSDATE),1000,7369,40);

This diagram illustrates that the hire\_emp procedure in the emp\_admin definer’s rights package updates the emp table belonging to hr\_mgr since the object privileges of hr\_mgr are used, and the default search path setting with the $user placeholder resolves to the schema of hr\_mgr.

Figure 5 Definer's Rights Package

Now connect as user, hr\_mgr. The following SELECT command verifies that the new employee was added to hr\_mgr’s emp table since the emp\_admin package has definer’s rights and hr\_mgr is emp\_admin’s owner.

\\c – hr\_mgr

SELECT empno, ename, hiredate, sal, deptno, hr\_mgr.emp\_admin.get\_dept\_name(deptno) FROM hr\_mgr.emp;

empno | ename | hiredate | sal | deptno | get\_dept\_name

\-------+--------+--------------------+---------+--------+---------------

7369 | SMITH | 17-DEC-80 00:00:00 | 800.00 | 20 | RESEARCH

7499 | ALLEN | 20-FEB-81 00:00:00 | 1600.00 | 30 | SALES

7521 | WARD | 22-FEB-81 00:00:00 | 1250.00 | 30 | SALES

7566 | JONES | 02-APR-81 00:00:00 | 2975.00 | 20 | RESEARCH

7654 | MARTIN | 28-SEP-81 00:00:00 | 1250.00 | 30 | SALES

7698 | BLAKE | 01-MAY-81 00:00:00 | 2850.00 | 30 | SALES

7782 | CLARK | 09-JUN-81 00:00:00 | 2450.00 | 10 | ACCOUNTING

7788 | SCOTT | 19-APR-87 00:00:00 | 3000.00 | 20 | RESEARCH

7839 | KING | 17-NOV-81 00:00:00 | 5000.00 | 10 | ACCOUNTING

7844 | TURNER | 08-SEP-81 00:00:00 | 1500.00 | 30 | SALES

7876 | ADAMS | 23-MAY-87 00:00:00 | 1100.00 | 20 | RESEARCH

7900 | JAMES | 03-DEC-81 00:00:00 | 950.00 | 30 | SALES

7902 | FORD | 03-DEC-81 00:00:00 | 3000.00 | 20 | RESEARCH

7934 | MILLER | 23-JAN-82 00:00:00 | 1300.00 | 10 | ACCOUNTING

9001 | ALICE | 08-NOV-07 00:00:00 | 8000.00 | 40 | OPERATIONS

(15 rows)

## Variable Declarations

SPL is a block-structured language. The first section that can appear in a block is the declaration. The declaration contains the definition of variables, cursors, and other types that can be used in SPL statements contained in the block.

### Declaring a Variable

Generally, all variables used in a block must be declared in the declaration section of the block. A variable declaration consists of a name that is assigned to the variable and its data type. Optionally, the variable can be initialized to a default value in the variable declaration.

The general syntax of a variable declaration is:

*name* *type* \[ { := | DEFAULT } { *expression* | NULL } \];

*name* is an identifier assigned to the variable.

*type* is the data type assigned to the variable.

\[ := *expression* \], if given, specifies the initial value assigned to the variable when the block is entered. If the clause is not given then the variable is initialized to the SQL NULL value.

The default value is evaluated every time the block is entered. So, for example, assigning SYSDATE to a variable of type DATE causes the variable to have the time of the current invocation, not the time when the procedure or function was precompiled.

The following procedure illustrates some variable declarations that utilize defaults consisting of string and numeric expressions.

CREATE OR REPLACE PROCEDURE dept\_salary\_rpt (

p\_deptno NUMBER

)

IS

todays\_date DATE := SYSDATE;

rpt\_title VARCHAR2(60) := 'Report For Department \# ' || p\_deptno

|| ' on ' || todays\_date;

base\_sal INTEGER := 35525;

base\_comm\_rate NUMBER := 1.33333;

base\_annual NUMBER := ROUND(base\_sal \* base\_comm\_rate, 2);

BEGIN

DBMS\_OUTPUT.PUT\_LINE(rpt\_title);

DBMS\_OUTPUT.PUT\_LINE('Base Annual Salary: ' || base\_annual);

END;

The following output of the above procedure shows that default values in the variable declarations are indeed assigned to the variables.

EXEC dept\_salary\_rpt(20);

Report For Department \# 20 on 10-JUL-07 16:44:45

Base Annual Salary: 47366.55

### Using %TYPE in Variable Declarations

Often, variables will be declared in SPL programs that will be used to hold values from tables in the database. In order to ensure compatibility between the table columns and the SPL variables, the data types of the two should be the same.

However, as quite often happens, a change might be made to the table definition. If the data type of the column is changed, the corresponding change may be required to the variable in the SPL program.

Instead of coding the specific column data type into the variable declaration the column attribute, %TYPE, can be used instead. A qualified column name in dot notation or the name of a previously declared variable must be specified as a prefix to %TYPE. The data type of the column or variable prefixed to %TYPE is assigned to the variable being declared. If the data type of the given column or variable changes, the new data type will be associated with the variable without the need to modify the declaration code.

**Note:** The %TYPE attribute can be used with formal parameter declarations as well.

*name* { { *table* | *view* }.*column* | *variable* }%TYPE;

*name* is the identifier assigned to the variable or formal parameter that is being declared. *column* is the name of a column in *table* or *view*. *variable* is the name of a variable that was declared prior to the variable identified by *name*.

**Note:** The variable does not inherit any of the column’s other attributes such as might be specified on the column with the NOT NULL clause or the DEFAULT clause.

In the following example a procedure queries the emp table using an employee number, displays the employee’s data, finds the average salary of all employees in the department to which the employee belongs, and then compares the chosen employee’s salary with the department average.

CREATE OR REPLACE PROCEDURE emp\_sal\_query (

p\_empno IN NUMBER

)

IS

v\_ename VARCHAR2(10);

v\_job VARCHAR2(9);

v\_hiredate DATE;

v\_sal NUMBER(7,2);

v\_deptno NUMBER(2);

v\_avgsal NUMBER(7,2);

BEGIN

SELECT ename, job, hiredate, sal, deptno

INTO v\_ename, v\_job, v\_hiredate, v\_sal, v\_deptno

FROM emp WHERE empno = p\_empno;

DBMS\_OUTPUT.PUT\_LINE('Employee \# : ' || p\_empno);

DBMS\_OUTPUT.PUT\_LINE('Name : ' || v\_ename);

DBMS\_OUTPUT.PUT\_LINE('Job : ' || v\_job);

DBMS\_OUTPUT.PUT\_LINE('Hire Date : ' || v\_hiredate);

DBMS\_OUTPUT.PUT\_LINE('Salary : ' || v\_sal);

DBMS\_OUTPUT.PUT\_LINE('Dept \# : ' || v\_deptno);

SELECT AVG(sal) INTO v\_avgsal

FROM emp WHERE deptno = v\_deptno;

IF v\_sal \> v\_avgsal THEN

DBMS\_OUTPUT.PUT\_LINE('Employee''s salary is more than the '

|| 'department average of ' || v\_avgsal);

ELSE

DBMS\_OUTPUT.PUT\_LINE('Employee''s salary does not exceed the '

|| 'department average of ' || v\_avgsal);

END IF;

END;

Instead of the above, the procedure could be written as follows without explicitly coding the emp table data types into the declaration section of the procedure.

CREATE OR REPLACE PROCEDURE emp\_sal\_query (

p\_empno IN emp.empno%TYPE

)

IS

v\_ename emp.ename%TYPE;

v\_job emp.job%TYPE;

v\_hiredate emp.hiredate%TYPE;

v\_sal emp.sal%TYPE;

v\_deptno emp.deptno%TYPE;

v\_avgsal v\_sal%TYPE;

BEGIN

SELECT ename, job, hiredate, sal, deptno

INTO v\_ename, v\_job, v\_hiredate, v\_sal, v\_deptno

FROM emp WHERE empno = p\_empno;

DBMS\_OUTPUT.PUT\_LINE('Employee \# : ' || p\_empno);

DBMS\_OUTPUT.PUT\_LINE('Name : ' || v\_ename);

DBMS\_OUTPUT.PUT\_LINE('Job : ' || v\_job);

DBMS\_OUTPUT.PUT\_LINE('Hire Date : ' || v\_hiredate);

DBMS\_OUTPUT.PUT\_LINE('Salary : ' || v\_sal);

DBMS\_OUTPUT.PUT\_LINE('Dept \# : ' || v\_deptno);

SELECT AVG(sal) INTO v\_avgsal

FROM emp WHERE deptno = v\_deptno;

IF v\_sal \> v\_avgsal THEN

DBMS\_OUTPUT.PUT\_LINE('Employee''s salary is more than the '

|| 'department average of ' || v\_avgsal);

ELSE

DBMS\_OUTPUT.PUT\_LINE('Employee''s salary does not exceed the '

|| 'department average of ' || v\_avgsal);

END IF;

END;

**Note:** p\_empno shows an example of a formal parameter defined using %TYPE.

v\_avgsal illustrates the usage of %TYPE referring to another variable instead of a table column.

The following is sample output from executing this procedure.

EXEC emp\_sal\_query(7698);

Employee \# : 7698

Name : BLAKE

Job : MANAGER

Hire Date : 01-MAY-81 00:00:00

Salary : 2850.00

Dept \# : 30

Employee's salary is more than the department average of 1566.67

### Using %ROWTYPE in Record Declarations

The %TYPE attribute provides an easy way to create a variable dependent upon a column’s data type. Using the %ROWTYPE attribute, you can define a record that contains fields that correspond to all columns of a given table. Each field takes on the data type of its corresponding column. The fields in the record do not inherit any of the columns’ other attributes such as might be specified with the NOT NULL clause or the DEFAULT clause.

A *record* is a named, ordered collection of fields. A *field* is similar to a variable; it has an identifier and data type, but has the additional property of belonging to a record, and must be referenced using dot notation with the record name as its qualifier.

You can use the %ROWTYPE attribute to declare a record. The %ROWTYPE attribute is prefixed by a table name. Each column in the named table defines an identically named field in the record with the same data type as the column.

*record* *table*%ROWTYPE;

*record* is an identifier assigned to the record. *table* is the name of a table (or view) whose columns are to define the fields in the record. The following example shows how the emp\_sal\_query procedure from the prior section can be modified to use emp%ROWTYPE to create a record named r\_emp instead of declaring individual variables for the columns in emp.

CREATE OR REPLACE PROCEDURE emp\_sal\_query (

p\_empno IN emp.empno%TYPE

)

IS

r\_emp emp%ROWTYPE;

v\_avgsal emp.sal%TYPE;

BEGIN

SELECT ename, job, hiredate, sal, deptno

INTO r\_emp.ename, r\_emp.job, r\_emp.hiredate, r\_emp.sal, r\_emp.deptno

FROM emp WHERE empno = p\_empno;

DBMS\_OUTPUT.PUT\_LINE('Employee \# : ' || p\_empno);

DBMS\_OUTPUT.PUT\_LINE('Name : ' || r\_emp.ename);

DBMS\_OUTPUT.PUT\_LINE('Job : ' || r\_emp.job);

DBMS\_OUTPUT.PUT\_LINE('Hire Date : ' || r\_emp.hiredate);

DBMS\_OUTPUT.PUT\_LINE('Salary : ' || r\_emp.sal);

DBMS\_OUTPUT.PUT\_LINE('Dept \# : ' || r\_emp.deptno);

SELECT AVG(sal) INTO v\_avgsal

FROM emp WHERE deptno = r\_emp.deptno;

IF r\_emp.sal \> v\_avgsal THEN

DBMS\_OUTPUT.PUT\_LINE('Employee''s salary is more than the '

|| 'department average of ' || v\_avgsal);

ELSE

DBMS\_OUTPUT.PUT\_LINE('Employee''s salary does not exceed the '

|| 'department average of ' || v\_avgsal);

END IF;

END;

### User-Defined Record Types and Record Variables

Records can be declared based upon a table definition using the %ROWTYPE attribute as shown in Section <span class="underline">3.3.3</span>. This section describes how a new record structure can be defined that is not tied to any particular table definition.

The TYPE IS RECORD statement is used to create the definition of a record type. A *record type* is a definition of a record comprised of one or more identifiers and their corresponding data types. A record type cannot, by itself, be used to manipulate data.

The syntax for a TYPE IS RECORD statement is:

> TYPE *rec*\_*type* IS RECORD ( *fields* )

Where *fields* is a comma-separated list of one or more field definitions of the following form:

> *field*\_*name* *data\_type* \[NOT NULL\]\[{:= | DEFAULT} *default*\_*value*\]

Where:

*rec\_type*

> *rec\_type* is an identifier assigned to the record type.

*field\_name*

> *field\_name* is the identifier assigned to the field of the record type.

*data\_type*

> *data\_type* specifies the data type of *field\_name*.

DEFAULT *default\_value*

> The DEFAULT clause assigns a default data value for the corresponding field. The data type of the default expression must match the data type of the column. If no default is specified, then the default is NULL.

A *record variable* or simply put, a *record*, is an instance of a record type. A record is declared from a record type. The properties of the record such as its field names and types are inherited from the record type.

The following is the syntax for a record declaration.

*record rectype*

*record* is an identifier assigned to the record variable. *rectype* is the identifier of a previously defined record type. Once declared, a record can then be used to hold data.

Dot notation is used to make reference to the fields in the record.

*record.field*

*record* is a previously declared record variable and *field* is the identifier of a field belonging to the record type from which *record* is defined.

The emp\_sal\_query is again modified – this time using a user-defined record type and record variable.

CREATE OR REPLACE PROCEDURE emp\_sal\_query (

p\_empno IN emp.empno%TYPE

)

IS

TYPE emp\_typ IS RECORD (

ename emp.ename%TYPE,

job emp.job%TYPE,

hiredate emp.hiredate%TYPE,

sal emp.sal%TYPE,

deptno emp.deptno%TYPE

);

r\_emp emp\_typ;

v\_avgsal emp.sal%TYPE;

BEGIN

SELECT ename, job, hiredate, sal, deptno

INTO r\_emp.ename, r\_emp.job, r\_emp.hiredate, r\_emp.sal, r\_emp.deptno

FROM emp WHERE empno = p\_empno;

DBMS\_OUTPUT.PUT\_LINE('Employee \# : ' || p\_empno);

DBMS\_OUTPUT.PUT\_LINE('Name : ' || r\_emp.ename);

DBMS\_OUTPUT.PUT\_LINE('Job : ' || r\_emp.job);

DBMS\_OUTPUT.PUT\_LINE('Hire Date : ' || r\_emp.hiredate);

DBMS\_OUTPUT.PUT\_LINE('Salary : ' || r\_emp.sal);

DBMS\_OUTPUT.PUT\_LINE('Dept \# : ' || r\_emp.deptno);

SELECT AVG(sal) INTO v\_avgsal

FROM emp WHERE deptno = r\_emp.deptno;

IF r\_emp.sal \> v\_avgsal THEN

DBMS\_OUTPUT.PUT\_LINE('Employee''s salary is more than the '

|| 'department average of ' || v\_avgsal);

ELSE

DBMS\_OUTPUT.PUT\_LINE('Employee''s salary does not exceed the '

|| 'department average of ' || v\_avgsal);

END IF;

END;

Note that instead of specifying data type names, the %TYPE attribute can be used for the field data types in the record type definition.

The following is the output from executing this stored procedure.

EXEC emp\_sal\_query(7698);

Employee \# : 7698

Name : BLAKE

Job : MANAGER

Hire Date : 01-MAY-81 00:00:00

Salary : 2850.00

Dept \# : 30

Employee's salary is more than the department average of 1566.67

## Basic Statements

This section begins the discussion of the programming statements that can be used in an SPL program.

### NULL

The simplest statement is the NULL statement. This statement is an executable statement that does nothing.

NULL;

The following is the simplest, possible valid SPL program.

BEGIN

NULL;

END;

The NULL statement can act as a placeholder where an executable statement is required such as in a branch of an IF-THEN-ELSE statement.

For example:

CREATE OR REPLACE PROCEDURE divide\_it (

p\_numerator IN NUMBER,

p\_denominator IN NUMBER,

p\_result OUT NUMBER

)

IS

BEGIN

IF p\_denominator = 0 THEN

NULL;

ELSE

p\_result := p\_numerator / p\_denominator;

END IF;

END;

### Assignment

The assignment statement sets a variable or a formal parameter of mode OUT or IN OUT specified on the left side of the assignment, :=, to the evaluated expression specified on the right side of the assignment.

*variable* := *expression*;

*variable* is an identifier for a previously declared variable, OUT formal parameter, or IN OUT formal parameter.

*expression* is an expression that produces a single value. The value produced by the expression must have a compatible data type with that of *variable*.

The following example shows the typical use of assignment statements in the executable section of the procedure.

CREATE OR REPLACE PROCEDURE dept\_salary\_rpt (

p\_deptno NUMBER

)

IS

todays\_date DATE;

rpt\_title VARCHAR2(60);

base\_sal INTEGER;

base\_comm\_rate NUMBER;

base\_annual NUMBER;

BEGIN

todays\_date := SYSDATE;

rpt\_title := 'Report For Department \# ' || p\_deptno || ' on '

|| todays\_date;

base\_sal := 35525;

base\_comm\_rate := 1.33333;

base\_annual := ROUND(base\_sal \* base\_comm\_rate, 2);

DBMS\_OUTPUT.PUT\_LINE(rpt\_title);

DBMS\_OUTPUT.PUT\_LINE('Base Annual Salary: ' || base\_annual);

END;

### SELECT INTO

The SELECT INTO statement is an SPL variation of the SQL SELECT command, the differences being:
 - That SELECT INTO is designed to assign the results to variables or records where they can then be used in SPL program statements.
 - The accessible result set of SELECT INTO is at most one row.

Other than the above, all of the clauses of the SELECT command such as WHERE, ORDER BY, GROUP BY, HAVING, etc. are valid for SELECT INTO. The following are the two variations of SELECT INTO.

SELECT *select\_expressions* INTO *target* FROM ...;

*target* is a comma-separated list of simple variables. *select\_expressions* and the remainder of the statement are the same as for the SELECT command. The selected values must exactly match in data type, number, and order the structure of the target or a runtime error occurs.

SELECT \* INTO *record* FROM *table* ...;

*record* is a record variable that has previously been declared.

If the query returns zero rows, null values are assigned to the target(s). If the query returns multiple rows, the first row is assigned to the target(s) and the rest are discarded. (Note that "the first row" is not well-defined unless you’ve used ORDER BY.)

**Note:** In either cases, where no row is returned or more than one row is returned, SPL throws an exception.

**Note:** There is a variation of SELECT INTO using the BULK COLLECT clause that allows a result set of more than one row that is returned into a collection. See Section <span class="underline">3.12.4.1</span> for more information on using the BULK COLLECT clause with the SELECT INTO statement.

You can use the WHEN NO\_DATA\_FOUND clause in an EXCEPTION block to determine whether the assignment was successful (that is, at least one row was returned by the query).

This version of the emp\_sal\_query procedure uses the variation of SELECT INTO that returns the result set into a record. Also note the addition of the EXCEPTION block containing the WHEN NO\_DATA\_FOUND conditional expression.

CREATE OR REPLACE PROCEDURE emp\_sal\_query (

p\_empno IN emp.empno%TYPE

)

IS

r\_emp emp%ROWTYPE;

v\_avgsal emp.sal%TYPE;

BEGIN

SELECT \* INTO r\_emp

FROM emp WHERE empno = p\_empno;

DBMS\_OUTPUT.PUT\_LINE('Employee \# : ' || p\_empno);

DBMS\_OUTPUT.PUT\_LINE('Name : ' || r\_emp.ename);

DBMS\_OUTPUT.PUT\_LINE('Job : ' || r\_emp.job);

DBMS\_OUTPUT.PUT\_LINE('Hire Date : ' || r\_emp.hiredate);

DBMS\_OUTPUT.PUT\_LINE('Salary : ' || r\_emp.sal);

DBMS\_OUTPUT.PUT\_LINE('Dept \# : ' || r\_emp.deptno);

SELECT AVG(sal) INTO v\_avgsal

FROM emp WHERE deptno = r\_emp.deptno;

IF r\_emp.sal \> v\_avgsal THEN

DBMS\_OUTPUT.PUT\_LINE('Employee''s salary is more than the '

|| 'department average of ' || v\_avgsal);

ELSE

DBMS\_OUTPUT.PUT\_LINE('Employee''s salary does not exceed the '

|| 'department average of ' || v\_avgsal);

END IF;

EXCEPTION

WHEN NO\_DATA\_FOUND THEN

DBMS\_OUTPUT.PUT\_LINE('Employee \# ' || p\_empno || ' not found');

END;

If the query is executed with a non-existent employee number the results appear as follows.

EXEC emp\_sal\_query(0);

Employee \# 0 not found

Another conditional clause of use in the EXCEPTION section with SELECT INTO is the TOO\_MANY\_ROWS exception. If more than one row is selected by the SELECT INTO statement an exception is thrown by SPL.

When the following block is executed, the TOO\_MANY\_ROWS exception is thrown since there are many employees in the specified department.

DECLARE

v\_ename emp.ename%TYPE;

BEGIN

SELECT ename INTO v\_ename FROM emp WHERE deptno = 20 ORDER BY ename;

EXCEPTION

WHEN TOO\_MANY\_ROWS THEN

DBMS\_OUTPUT.PUT\_LINE('More than one employee found');

DBMS\_OUTPUT.PUT\_LINE('First employee returned is ' || v\_ename);

END;

More than one employee found

First employee returned is ADAMS

**Note:** See Section <span class="underline">3.5.7</span> or more information on exception handling.

### INSERT

The INSERT command available in the SQL language can also be used in SPL programs.

An expression in the SPL language can be used wherever an expression is allowed in the SQL INSERT command. Thus, SPL variables and parameters can be used to supply values to the insert operation.

The following is an example of a procedure that performs an insert of a new employee using data passed from a calling program.

CREATE OR REPLACE PROCEDURE emp\_insert (

p\_empno IN emp.empno%TYPE,

p\_ename IN emp.ename%TYPE,

p\_job IN emp.job%TYPE,

p\_mgr IN emp.mgr%TYPE,

p\_hiredate IN emp.hiredate%TYPE,

p\_sal IN emp.sal%TYPE,

p\_comm IN emp.comm%TYPE,

p\_deptno IN emp.deptno%TYPE

)

IS

BEGIN

INSERT INTO emp VALUES (

p\_empno,

p\_ename,

p\_job,

p\_mgr,

p\_hiredate,

p\_sal,

p\_comm,

p\_deptno);

DBMS\_OUTPUT.PUT\_LINE('Added employee...');

DBMS\_OUTPUT.PUT\_LINE('Employee \# : ' || p\_empno);

DBMS\_OUTPUT.PUT\_LINE('Name : ' || p\_ename);

DBMS\_OUTPUT.PUT\_LINE('Job : ' || p\_job);

DBMS\_OUTPUT.PUT\_LINE('Manager : ' || p\_mgr);

DBMS\_OUTPUT.PUT\_LINE('Hire Date : ' || p\_hiredate);

DBMS\_OUTPUT.PUT\_LINE('Salary : ' || p\_sal);

DBMS\_OUTPUT.PUT\_LINE('Commission : ' || p\_comm);

DBMS\_OUTPUT.PUT\_LINE('Dept \# : ' || p\_deptno);

DBMS\_OUTPUT.PUT\_LINE('----------------------');

EXCEPTION

WHEN OTHERS THEN

DBMS\_OUTPUT.PUT\_LINE('OTHERS exception on INSERT of employee \# '

|| p\_empno);

DBMS\_OUTPUT.PUT\_LINE('SQLCODE : ' || SQLCODE);

DBMS\_OUTPUT.PUT\_LINE('SQLERRM : ' || SQLERRM);

END;

If an exception occurs all database changes made in the procedure are automatically rolled back. In this example the EXCEPTION section with the WHEN OTHERS clause catches all exceptions. Two variables are displayed. SQLCODE is a number that identifies the specific exception that occurred. SQLERRM is a text message explaining the error. See Section <span class="underline">3.5.7</span> for more information on exception handling.

The following shows the output when this procedure is executed.

EXEC emp\_insert(9503,'PETERSON','ANALYST',7902,'31-MAR-05',5000,NULL,40);

Added employee...

Employee \# : 9503

Name : PETERSON

Job : ANALYST

Manager : 7902

Hire Date : 31-MAR-05 00:00:00

Salary : 5000

Dept \# : 40

\----------------------

SELECT \* FROM emp WHERE empno = 9503;

empno | ename | job | mgr | hiredate | sal | comm | deptno

\-------+----------+---------+------+--------------------+---------+------+--------

9503 | PETERSON | ANALYST | 7902 | 31-MAR-05 00:00:00 | 5000.00 | | 40

(1 row)

Note: The INSERT command can be included in a FORALL statement. A FORALL statement allows a single INSERT command to insert multiple rows from values supplied in one or more collections. See <span class="underline">3.12.3</span> for more information on the FORALL statement.

### UPDATE

The UPDATE command available in the SQL language can also be used in SPL programs.

An expression in the SPL language can be used wherever an expression is allowed in the SQL UPDATE command. Thus, SPL variables and parameters can be used to supply values to the update operation.

CREATE OR REPLACE PROCEDURE emp\_comp\_update (

p\_empno IN emp.empno%TYPE,

p\_sal IN emp.sal%TYPE,

p\_comm IN emp.comm%TYPE

)

IS

BEGIN

UPDATE emp SET sal = p\_sal, comm = p\_comm WHERE empno = p\_empno;

IF SQL%FOUND THEN

DBMS\_OUTPUT.PUT\_LINE('Updated Employee \# : ' || p\_empno);

DBMS\_OUTPUT.PUT\_LINE('New Salary : ' || p\_sal);

DBMS\_OUTPUT.PUT\_LINE('New Commission : ' || p\_comm);

ELSE

DBMS\_OUTPUT.PUT\_LINE('Employee \# ' || p\_empno || ' not found');

END IF;

END;

The SQL%FOUND conditional expression returns TRUE if a row is updated, FALSE otherwise. See Section <span class="underline">3.4.8</span> for a discussion of SQL%FOUND and other similar expressions.

The following shows the update on the employee using this procedure.

EXEC emp\_comp\_update(9503, 6540, 1200);

Updated Employee \# : 9503

New Salary : 6540

New Commission : 1200

SELECT \* FROM emp WHERE empno = 9503;

empno | ename | job | mgr | hiredate | sal | comm | deptno

\-------+----------+---------+------+--------------------+---------+---------+--------

9503 | PETERSON | ANALYST | 7902 | 31-MAR-05 00:00:00 | 6540.00 | 1200.00 | 40

(1 row)

**Note:** The UPDATE command can be included in a FORALL statement. A FORALL statement allows a single UPDATE command to update multiple rows from values supplied in one or more collections. See Section <span class="underline">3.12.3</span> for more information on the FORALL statement.

### DELETE

The DELETE command (available in the SQL language) can also be used in SPL programs.

An expression in the SPL language can be used wherever an expression is allowed in the SQL DELETE command. Thus, SPL variables and parameters can be used to supply values to the delete operation.

CREATE OR REPLACE PROCEDURE emp\_delete (

p\_empno IN emp.empno%TYPE

)

IS

BEGIN

DELETE FROM emp WHERE empno = p\_empno;

IF SQL%FOUND THEN

DBMS\_OUTPUT.PUT\_LINE('Deleted Employee \# : ' || p\_empno);

ELSE

DBMS\_OUTPUT.PUT\_LINE('Employee \# ' || p\_empno || ' not found');

END IF;

END;

The SQL%FOUND conditional expression returns TRUE if a row is deleted, FALSE otherwise. See Section <span class="underline">3.4.8</span> for a discussion of SQL%FOUND and other similar expressions.

The following shows the deletion of an employee using this procedure.

EXEC emp\_delete(9503);

Deleted Employee \# : 9503

SELECT \* FROM emp WHERE empno = 9503;

empno | ename | job | mgr | hiredate | sal | comm | deptno

\-------+-------+-----+-----+----------+-----+------+--------

(0 rows)

**Note:** The DELETE command can be included in a FORALL statement. A FORALL statement allows a single DELETE command to delete multiple rows from values supplied in one or more collections. See Section <span class="underline">3.12.3</span> for more information on the FORALL statement.

### Using the RETURNING INTO Clause

The INSERT, UPDATE, and DELETE commands may be appended by the optional RETURNING INTO clause. This clause allows the SPL program to capture the newly added, modified, or deleted values from the results of an INSERT, UPDATE, or DELETE command, respectively.

The following is the syntax.

{ *insert* | *update* | *delete* }

RETURNING { \* | *expr\_1* \[, *expr\_2* \] ...}

INTO { *record* | *field\_1* \[, *field\_2* \] ...};

*insert* is a valid INSERT command. *update* is a valid UPDATE command. *delete* is a valid DELETE command. If \* is specified, then the values from the row affected by the INSERT, UPDATE, or DELETE command are made available for assignment to the record or fields to the right of the INTO keyword. (Note that the use of \* is an Advanced Server extension and is not compatible with Oracle databases.) *expr\_1*, *expr\_2*... are expressions evaluated upon the row affected by the INSERT, UPDATE, or DELETE command. The evaluated results are assigned to the record or fields to the right of the INTO keyword. *record* is the identifier of a record that must contain fields that match in number and order, and are data type compatible with the values in the RETURNING clause. *field\_1*, *field\_2*,... are variables that must match in number and order, and are data type compatible with the set of values in the RETURNING clause.

If the INSERT, UPDATE, or DELETE command returns a result set with more than one row, then an exception is thrown with SQLCODE 01422, query returned more than one row. If no rows are in the result set, then the variables following the INTO keyword are set to null.

**Note:** There is a variation of RETURNING INTO using the BULK COLLECT clause that allows a result set of more than one row that is returned into a collection. See Section 3.12.4 for more information on the BULK COLLECT clause.

The following example is a modification of the emp\_comp\_update procedure introduced in Section <span class="underline">3.4.5</span>, with the addition of the RETURNING INTO clause.

CREATE OR REPLACE PROCEDURE emp\_comp\_update (

p\_empno IN emp.empno%TYPE,

p\_sal IN emp.sal%TYPE,

p\_comm IN emp.comm%TYPE

)

IS

v\_empno emp.empno%TYPE;

v\_ename emp.ename%TYPE;

v\_job emp.job%TYPE;

v\_sal emp.sal%TYPE;

v\_comm emp.comm%TYPE;

v\_deptno emp.deptno%TYPE;

BEGIN

UPDATE emp SET sal = p\_sal, comm = p\_comm WHERE empno = p\_empno

RETURNING

empno,

ename,

job,

sal,

comm,

deptno

INTO

v\_empno,

v\_ename,

v\_job,

v\_sal,

v\_comm,

v\_deptno;

IF SQL%FOUND THEN

DBMS\_OUTPUT.PUT\_LINE('Updated Employee \# : ' || v\_empno);

DBMS\_OUTPUT.PUT\_LINE('Name : ' || v\_ename);

DBMS\_OUTPUT.PUT\_LINE('Job : ' || v\_job);

DBMS\_OUTPUT.PUT\_LINE('Department : ' || v\_deptno);

DBMS\_OUTPUT.PUT\_LINE('New Salary : ' || v\_sal);

DBMS\_OUTPUT.PUT\_LINE('New Commission : ' || v\_comm);

ELSE

DBMS\_OUTPUT.PUT\_LINE('Employee \# ' || p\_empno || ' not found');

END IF;

END;

The following is the output from this procedure (assuming employee 9503 created by the emp\_insert procedure still exists within the table).

EXEC emp\_comp\_update(9503, 6540, 1200);

Updated Employee \# : 9503

Name : PETERSON

Job : ANALYST

Department : 40

New Salary : 6540.00

New Commission : 1200.00

The following example is a modification of the emp\_delete procedure, with the addition of the RETURNING INTO clause using record types.

CREATE OR REPLACE PROCEDURE emp\_delete (

p\_empno IN emp.empno%TYPE

)

IS

r\_emp emp%ROWTYPE;

BEGIN

DELETE FROM emp WHERE empno = p\_empno

RETURNING

\*

INTO

r\_emp;

IF SQL%FOUND THEN

DBMS\_OUTPUT.PUT\_LINE('Deleted Employee \# : ' || r\_emp.empno);

DBMS\_OUTPUT.PUT\_LINE('Name : ' || r\_emp.ename);

DBMS\_OUTPUT.PUT\_LINE('Job : ' || r\_emp.job);

DBMS\_OUTPUT.PUT\_LINE('Manager : ' || r\_emp.mgr);

DBMS\_OUTPUT.PUT\_LINE('Hire Date : ' || r\_emp.hiredate);

DBMS\_OUTPUT.PUT\_LINE('Salary : ' || r\_emp.sal);

DBMS\_OUTPUT.PUT\_LINE('Commission : ' || r\_emp.comm);

DBMS\_OUTPUT.PUT\_LINE('Department : ' || r\_emp.deptno);

ELSE

DBMS\_OUTPUT.PUT\_LINE('Employee \# ' || p\_empno || ' not found');

END IF;

END;

The following is the output from this procedure.

EXEC emp\_delete(9503);

Deleted Employee \# : 9503

Name : PETERSON

Job : ANALYST

Manager : 7902

Hire Date : 31-MAR-05 00:00:00

Salary : 6540.00

Commission : 1200.00

Department : 40

### Obtaining the Result Status

There are several attributes that can be used to determine the effect of a command. SQL%FOUND is a Boolean that returns true if at least one row was affected by an INSERT, UPDATE or DELETE command or a SELECT INTO command retrieved one or more rows.

The following anonymous block inserts a row and then displays the fact that the row has been inserted.

BEGIN

INSERT INTO emp (empno,ename,job,sal,deptno) VALUES (

9001, 'JONES', 'CLERK', 850.00, 40);

IF SQL%FOUND THEN

DBMS\_OUTPUT.PUT\_LINE('Row has been inserted');

END IF;

END;

Row has been inserted

SQL%ROWCOUNT provides the number of rows affected by an INSERT, UPDATE, DELETE, or SELECT INTO command. The SQL%ROWCOUNT value is returned as a BIGINT data type. The following example updates the row that was just inserted and displays SQL%ROWCOUNT.

BEGIN

UPDATE emp SET hiredate = '03-JUN-07' WHERE empno = 9001;

DBMS\_OUTPUT.PUT\_LINE('\# rows updated: ' || SQL%ROWCOUNT);

END;

\# rows updated: 1

SQL%NOTFOUND is the opposite of SQL%FOUND. SQL%NOTFOUND returns true if no rows were affected by an INSERT, UPDATE or DELETE command or a SELECT INTO command retrieved no rows.

BEGIN

UPDATE emp SET hiredate = '03-JUN-07' WHERE empno = 9000;

IF SQL%NOTFOUND THEN

DBMS\_OUTPUT.PUT\_LINE('No rows were updated');

END IF;

END;

No rows were updated

## Control Structures

The programming statements in SPL that make it a full procedural complement to SQL are described in this section.

### IF Statement

IF statements let you execute commands based on certain conditions. SPL has four forms of IF:
 - IF ... THEN
 - IF ... THEN ... ELSE
 - IF ... THEN ... ELSE IF
 - IF ... THEN ... ELSIF ... THEN ... ELSE

#### IF-THEN

IF *boolean-expression* THEN

*statements*

END IF;

IF-THEN statements are the simplest form of IF. The statements between THEN and END IF will be executed if the condition is true. Otherwise, they are skipped.

In the following example an IF-THEN statement is used to test and display employees who have a commission.

DECLARE

v\_empno emp.empno%TYPE;

v\_comm emp.comm%TYPE;

CURSOR emp\_cursor IS SELECT empno, comm FROM emp;

BEGIN

OPEN emp\_cursor;

DBMS\_OUTPUT.PUT\_LINE('EMPNO COMM');

DBMS\_OUTPUT.PUT\_LINE('----- -------');

LOOP

FETCH emp\_cursor INTO v\_empno, v\_comm;

EXIT WHEN emp\_cursor%NOTFOUND;

\--

\-- Test whether or not the employee gets a commission

\--

IF v\_comm IS NOT NULL AND v\_comm \> 0 THEN

DBMS\_OUTPUT.PUT\_LINE(v\_empno || ' ' ||

TO\_CHAR(v\_comm,'$99999.99'));

END IF;

END LOOP;

CLOSE emp\_cursor;

END;

The following is the output from this program.

EMPNO COMM

\----- -------

7499 $300.00

7521 $500.00

7654 $1400.00

#### IF-THEN-ELSE

IF *boolean-expression* THEN

*statements*

ELSE

*statements*

END IF;

IF-THEN-ELSE statements add to IF-THEN by letting you specify an alternative set of statements that should be executed if the condition evaluates to false.

The previous example is modified so an IF-THEN-ELSE statement is used to display the text Non-commission if the employee does not get a commission.

DECLARE

v\_empno emp.empno%TYPE;

v\_comm emp.comm%TYPE;

CURSOR emp\_cursor IS SELECT empno, comm FROM emp;

BEGIN

OPEN emp\_cursor;

DBMS\_OUTPUT.PUT\_LINE('EMPNO COMM');

DBMS\_OUTPUT.PUT\_LINE('----- -------');

LOOP

FETCH emp\_cursor INTO v\_empno, v\_comm;

EXIT WHEN emp\_cursor%NOTFOUND;

\--

\-- Test whether or not the employee gets a commission

\--

IF v\_comm IS NOT NULL AND v\_comm \> 0 THEN

DBMS\_OUTPUT.PUT\_LINE(v\_empno || ' ' ||

TO\_CHAR(v\_comm,'$99999.99'));

ELSE

DBMS\_OUTPUT.PUT\_LINE(v\_empno || ' ' || 'Non-commission');

END IF;

END LOOP;

CLOSE emp\_cursor;

END;

The following is the output from this program.

EMPNO COMM

\----- -------

7369 Non-commission

7499 $ 300.00

7521 $ 500.00

7566 Non-commission

7654 $ 1400.00

7698 Non-commission

7782 Non-commission

7788 Non-commission

7839 Non-commission

7844 Non-commission

7876 Non-commission

7900 Non-commission

7902 Non-commission

7934 Non-commission

#### IF-THEN-ELSE IF

IF statements can be nested so that alternative IF statements can be invoked once it is determined whether or not the conditional of an outer IF statement is true or false.

In the following example the outer IF-THEN-ELSE statement tests whether or not an employee has a commission. The inner IF-THEN-ELSE statements then test whether the employee’s total compensation exceeds or is less than the company average.

DECLARE

v\_empno emp.empno%TYPE;

v\_sal emp.sal%TYPE;

v\_comm emp.comm%TYPE;

v\_avg NUMBER(7,2);

CURSOR emp\_cursor IS SELECT empno, sal, comm FROM emp;

BEGIN

\--

\-- Calculate the average yearly compensation in the company

\--

SELECT AVG((sal + NVL(comm,0)) \* 24) INTO v\_avg FROM emp;

DBMS\_OUTPUT.PUT\_LINE('Average Yearly Compensation: ' ||

TO\_CHAR(v\_avg,'$999,999.99'));

OPEN emp\_cursor;

DBMS\_OUTPUT.PUT\_LINE('EMPNO YEARLY COMP');

DBMS\_OUTPUT.PUT\_LINE('----- -----------');

LOOP

FETCH emp\_cursor INTO v\_empno, v\_sal, v\_comm;

EXIT WHEN emp\_cursor%NOTFOUND;

\--

\-- Test whether or not the employee gets a commission

\--

IF v\_comm IS NOT NULL AND v\_comm \> 0 THEN

\--

\-- Test if the employee's compensation with commission exceeds the average

\--

IF (v\_sal + v\_comm) \* 24 \> v\_avg THEN

DBMS\_OUTPUT.PUT\_LINE(v\_empno || ' ' ||

TO\_CHAR((v\_sal + v\_comm) \* 24,'$999,999.99') ||

' Exceeds Average');

ELSE

DBMS\_OUTPUT.PUT\_LINE(v\_empno || ' ' ||

TO\_CHAR((v\_sal + v\_comm) \* 24,'$999,999.99') ||

' Below Average');

END IF;

ELSE

\--

\-- Test if the employee's compensation without commission exceeds the average

\--

IF v\_sal \* 24 \> v\_avg THEN

DBMS\_OUTPUT.PUT\_LINE(v\_empno || ' ' ||

TO\_CHAR(v\_sal \* 24,'$999,999.99') || ' Exceeds Average');

ELSE

DBMS\_OUTPUT.PUT\_LINE(v\_empno || ' ' ||

TO\_CHAR(v\_sal \* 24,'$999,999.99') || ' Below Average');

END IF;

END IF;

END LOOP;

CLOSE emp\_cursor;

END;

**Note:** The logic in this program can be simplified considerably by calculating the employee’s yearly compensation using the NVL function within the SELECT command of the cursor declaration, however, the purpose of this example is to demonstrate how IF statements can be used.

The following is the output from this program.

Average Yearly Compensation: $ 53,528.57

EMPNO YEARLY COMP

\----- -----------

7369 $ 19,200.00 Below Average

7499 $ 45,600.00 Below Average

7521 $ 42,000.00 Below Average

7566 $ 71,400.00 Exceeds Average

7654 $ 63,600.00 Exceeds Average

7698 $ 68,400.00 Exceeds Average

7782 $ 58,800.00 Exceeds Average

7788 $ 72,000.00 Exceeds Average

7839 $ 120,000.00 Exceeds Average

7844 $ 36,000.00 Below Average

7876 $ 26,400.00 Below Average

7900 $ 22,800.00 Below Average

7902 $ 72,000.00 Exceeds Average

7934 $ 31,200.00 Below Average

When you use this form, you are actually nesting an IF statement inside the ELSE part of an outer IF statement. Thus you need one END IF statement for each nested IF and one for the parent IF-ELSE.

#### IF-THEN-ELSIF-ELSE

IF *boolean-expression* THEN

*statements*

\[ ELSIF *boolean-expression* THEN

*statements*

\[ ELSIF *boolean-expression* THEN

*statements* \] ...\]

\[ ELSE

*statements* \]

END IF;

IF-THEN-ELSIF-ELSE provides a method of checking many alternatives in one statement. Formally it is equivalent to nested IF-THEN-ELSE-IF-THEN commands, but only one END IF is needed.

The following example uses an IF-THEN-ELSIF-ELSE statement to count the number of employees by compensation ranges of $25,000.

DECLARE

v\_empno emp.empno%TYPE;

v\_comp NUMBER(8,2);

v\_lt\_25K SMALLINT := 0;

v\_25K\_50K SMALLINT := 0;

v\_50K\_75K SMALLINT := 0;

v\_75K\_100K SMALLINT := 0;

v\_ge\_100K SMALLINT := 0;

CURSOR emp\_cursor IS SELECT empno, (sal + NVL(comm,0)) \* 24 FROM emp;

BEGIN

OPEN emp\_cursor;

LOOP

FETCH emp\_cursor INTO v\_empno, v\_comp;

EXIT WHEN emp\_cursor%NOTFOUND;

IF v\_comp \< 25000 THEN

v\_lt\_25K := v\_lt\_25K + 1;

ELSIF v\_comp \< 50000 THEN

v\_25K\_50K := v\_25K\_50K + 1;

ELSIF v\_comp \< 75000 THEN

v\_50K\_75K := v\_50K\_75K + 1;

ELSIF v\_comp \< 100000 THEN

v\_75K\_100K := v\_75K\_100K + 1;

ELSE

v\_ge\_100K := v\_ge\_100K + 1;

END IF;

END LOOP;

CLOSE emp\_cursor;

DBMS\_OUTPUT.PUT\_LINE('Number of employees by yearly compensation');

DBMS\_OUTPUT.PUT\_LINE('Less than 25,000 : ' || v\_lt\_25K);

DBMS\_OUTPUT.PUT\_LINE('25,000 - 49,9999 : ' || v\_25K\_50K);

DBMS\_OUTPUT.PUT\_LINE('50,000 - 74,9999 : ' || v\_50K\_75K);

DBMS\_OUTPUT.PUT\_LINE('75,000 - 99,9999 : ' || v\_75K\_100K);

DBMS\_OUTPUT.PUT\_LINE('100,000 and over : ' || v\_ge\_100K);

END;

The following is the output from this program.

Number of employees by yearly compensation

Less than 25,000 : 2

25,000 - 49,9999 : 5

50,000 - 74,9999 : 6

75,000 - 99,9999 : 0

100,000 and over : 1

### RETURN Statement

The RETURN statement terminates the current function, procedure or anonymous block and returns control to the caller.

There are two forms of the RETURN Statement. The first form of the RETURN statement is used to terminate a procedure or function that returns void. The syntax of the first form is:

> RETURN;

The second form of RETURN returns a value to the caller. The syntax of the second form of the RETURN statement is:

> RETURN *expression*;

*expression* must evaluate to the same data type as the return type of the function.

The following example uses the RETURN statement returns a value to the caller:

CREATE OR REPLACE FUNCTION emp\_comp (

p\_sal NUMBER,

p\_comm NUMBER

) RETURN NUMBER

IS

BEGIN

RETURN (p\_sal + NVL(p\_comm, 0)) \* 24;

END emp\_comp;

### GOTO Statement

The GOTO statement causes the point of execution to jump to the statement with the specified label. The syntax of a GOTO statement is:

> GOTO *label*

*label* is a name assigned to an executable statement. *label* must be unique within the scope of the function, procedure or anonymous block.

To label a statement, use the syntax:

\<\<*label*\>\> *statement*

*statement* is the point of execution that the program jumps to.

You can label assignment statements, any SQL statement (like INSERT, UPDATE, CREATE, etc.) and selected procedural language statements. The procedural language statements that can be labeled are:
 - IF
 - EXIT
 - RETURN
 - RAISE
 - EXECUTE
 - PERFORM
 - GET DIAGNOSTICS
 - OPEN
 - FETCH
 - MOVE
 - CLOSE
 - NULL
 - COMMIT
 - ROLLBACK
 - GOTO
 - CASE
 - LOOP
 - WHILE
 - FOR

Please note that exit is considered a keyword, and cannot be used as the name of a label.

GOTO statements cannot transfer control *into* a conditional block or sub-block, but can transfer control *from* a conditional block or sub-block.

The following example verifies that an employee record contains a name, job description, and employee hire date; if any piece of information is missing, a GOTO statement transfers the point of execution to a statement that prints a message that the employee is not valid.

CREATE OR REPLACE PROCEDURE verify\_emp (

p\_empno NUMBER

)

IS

v\_ename emp.ename%TYPE;

v\_job emp.job%TYPE;

v\_hiredate emp.hiredate%TYPE;

BEGIN

SELECT ename, job, hiredate

INTO v\_ename, v\_job, v\_hiredate FROM emp

WHERE empno = p\_empno;

IF v\_ename IS NULL THEN

GOTO invalid\_emp;

END IF;

IF v\_job IS NULL THEN

GOTO invalid\_emp;

END IF;

IF v\_hiredate IS NULL THEN

GOTO invalid\_emp;

END IF;

DBMS\_OUTPUT.PUT\_LINE('Employee ' || p\_empno ||

' validated without errors.');

RETURN;

\<\<invalid\_emp\>\> DBMS\_OUTPUT.PUT\_LINE('Employee ' || p\_empno ||

' is not a valid employee.');

END;

GOTO statements have the following restrictions:
 - A GOTO statement cannot jump to a declaration.
 - A GOTO statement cannot transfer control to another function or procedure.
 - A *label* should not be placed at the end of a block, function or procedure.

### CASE Expression

The CASE expression returns a value that is substituted where the CASE expression is located within an expression.

There are two formats of the CASE expression - one that is called a *searched* CASE and the other that uses a *selector*.

#### Selector CASE Expression

The selector CASE expression attempts to match an expression called the selector to the expression specified in one or more WHEN clauses. *result* is an expression that is type-compatible in the context where the CASE expression is used. If a match is found, the value given in the corresponding THEN clause is returned by the CASE expression. If there are no matches, the value following ELSE is returned. If ELSE is omitted, the CASE expression returns null.

CASE *selector-expression*

WHEN *match-expression* THEN

*result*

\[ WHEN *match-expression* THEN

*result*

\[ WHEN *match-expression* THEN

*result* \] ...\]

\[ ELSE

*result* \]

END;

*match-expression* is evaluated in the order in which it appears within the CASE expression. *result* is an expression that is type-compatible in the context where the CASE expression is used. When the first *match-expression* is encountered that equals *selector-expression*, *result* in the corresponding THEN clause is returned as the value of the CASE expression. If none of *match-expression* equals *selector-expression* then *result* following ELSE is returned. If no ELSE is specified, the CASE expression returns null.

The following example uses a selector CASE expression to assign the department name to a variable based upon the department number.

DECLARE

v\_empno emp.empno%TYPE;

v\_ename emp.ename%TYPE;

v\_deptno emp.deptno%TYPE;

v\_dname dept.dname%TYPE;

CURSOR emp\_cursor IS SELECT empno, ename, deptno FROM emp;

BEGIN

OPEN emp\_cursor;

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME DEPTNO DNAME');

DBMS\_OUTPUT.PUT\_LINE('----- ------- ------ ----------');

LOOP

FETCH emp\_cursor INTO v\_empno, v\_ename, v\_deptno;

EXIT WHEN emp\_cursor%NOTFOUND;

v\_dname :=

CASE v\_deptno

WHEN 10 THEN 'Accounting'

WHEN 20 THEN 'Research'

WHEN 30 THEN 'Sales'

WHEN 40 THEN 'Operations'

ELSE 'unknown'

END;

DBMS\_OUTPUT.PUT\_LINE(v\_empno || ' ' || RPAD(v\_ename, 10) ||

' ' || v\_deptno || ' ' || v\_dname);

END LOOP;

CLOSE emp\_cursor;

END;

The following is the output from this program.

EMPNO ENAME DEPTNO DNAME

\----- ------- ------ ----------

7369 SMITH 20 Research

7499 ALLEN 30 Sales

7521 WARD 30 Sales

7566 JONES 20 Research

7654 MARTIN 30 Sales

7698 BLAKE 30 Sales

7782 CLARK 10 Accounting

7788 SCOTT 20 Research

7839 KING 10 Accounting

7844 TURNER 30 Sales

7876 ADAMS 20 Research

7900 JAMES 30 Sales

7902 FORD 20 Research

7934 MILLER 10 Accounting

#### Searched CASE Expression

A searched CASE expression uses one or more Boolean expressions to determine the resulting value to return.

CASE WHEN *boolean-expression* THEN

*result*

\[ WHEN *boolean-expression* THEN

*result*

\[ WHEN *boolean-expression* THEN

*result* \] ...\]

\[ ELSE

*result* \]

END;

*boolean-expression* is evaluated in the order in which it appears within the CASE expression. *result* is an expression that is type-compatible in the context where the CASE expression is used. When the first *boolean-expression* is encountered that evaluates to true, *result* in the corresponding THEN clause is returned as the value of the CASE expression. If none of *boolean-expression* evaluates to true then *result* following ELSE is returned. If no ELSE is specified, the CASE expression returns null.

The following example uses a searched CASE expression to assign the department name to a variable based upon the department number.

DECLARE

v\_empno emp.empno%TYPE;

v\_ename emp.ename%TYPE;

v\_deptno emp.deptno%TYPE;

v\_dname dept.dname%TYPE;

CURSOR emp\_cursor IS SELECT empno, ename, deptno FROM emp;

BEGIN

OPEN emp\_cursor;

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME DEPTNO DNAME');

DBMS\_OUTPUT.PUT\_LINE('----- ------- ------ ----------');

LOOP

FETCH emp\_cursor INTO v\_empno, v\_ename, v\_deptno;

EXIT WHEN emp\_cursor%NOTFOUND;

v\_dname :=

CASE

WHEN v\_deptno = 10 THEN 'Accounting'

WHEN v\_deptno = 20 THEN 'Research'

WHEN v\_deptno = 30 THEN 'Sales'

WHEN v\_deptno = 40 THEN 'Operations'

ELSE 'unknown'

END;

DBMS\_OUTPUT.PUT\_LINE(v\_empno || ' ' || RPAD(v\_ename, 10) ||

' ' || v\_deptno || ' ' || v\_dname);

END LOOP;

CLOSE emp\_cursor;

END;

The following is the output from this program.

EMPNO ENAME DEPTNO DNAME

\----- ------- ------ ----------

7369 SMITH 20 Research

7499 ALLEN 30 Sales

7521 WARD 30 Sales

7566 JONES 20 Research

7654 MARTIN 30 Sales

7698 BLAKE 30 Sales

7782 CLARK 10 Accounting

7788 SCOTT 20 Research

7839 KING 10 Accounting

7844 TURNER 30 Sales

7876 ADAMS 20 Research

7900 JAMES 30 Sales

7902 FORD 20 Research

7934 MILLER 10 Accounting

### CASE Statement

The CASE statement executes a set of one or more statements when a specified search condition is true. The CASE statement is a stand-alone statement in itself while the previously discussed CASE expression must appear as part of an expression.

There are two formats of the CASE statement - one that is called a *searched* CASE and the other that uses a *selector*.

#### Selector CASE Statement

The selector CASE statement attempts to match an expression called the selector to the expression specified in one or more WHEN clauses. When a match is found one or more corresponding statements are executed.

CASE *selector-expression*

WHEN *match-expression* THEN

*statements*

\[ WHEN *match-expression* THEN

*statements*

\[ WHEN *match-expression* THEN

*statements* \] ...\]

\[ ELSE

*statements* \]

END CASE;

*selector-expression* returns a value type-compatible with each *match-expression*. *match-expression* is evaluated in the order in which it appears within the CASE statement. *statements* are one or more SPL statements, each terminated by a semi-colon. When the value of *selector-expression* equals the first *match-expression*, the statement(s) in the corresponding THEN clause are executed and control continues following the END CASE keywords. If there are no matches, the statement(s) following ELSE are executed. If there are no matches and there is no ELSE clause, an exception is thrown.

The following example uses a selector CASE statement to assign a department name and location to a variable based upon the department number.

DECLARE

v\_empno emp.empno%TYPE;

v\_ename emp.ename%TYPE;

v\_deptno emp.deptno%TYPE;

v\_dname dept.dname%TYPE;

v\_loc dept.loc%TYPE;

CURSOR emp\_cursor IS SELECT empno, ename, deptno FROM emp;

BEGIN

OPEN emp\_cursor;

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME DEPTNO DNAME '

|| ' LOC');

DBMS\_OUTPUT.PUT\_LINE('----- ------- ------ ----------'

|| ' ---------');

LOOP

FETCH emp\_cursor INTO v\_empno, v\_ename, v\_deptno;

EXIT WHEN emp\_cursor%NOTFOUND;

CASE v\_deptno

WHEN 10 THEN v\_dname := 'Accounting';

v\_loc := 'New York';

WHEN 20 THEN v\_dname := 'Research';

v\_loc := 'Dallas';

WHEN 30 THEN v\_dname := 'Sales';

v\_loc := 'Chicago';

WHEN 40 THEN v\_dname := 'Operations';

v\_loc := 'Boston';

ELSE v\_dname := 'unknown';

v\_loc := '';

END CASE;

DBMS\_OUTPUT.PUT\_LINE(v\_empno || ' ' || RPAD(v\_ename, 10) ||

' ' || v\_deptno || ' ' || RPAD(v\_dname, 14) || ' ' ||

v\_loc);

END LOOP;

CLOSE emp\_cursor;

END;

The following is the output from this program.

EMPNO ENAME DEPTNO DNAME LOC

\----- ------- ------ ---------- ---------

7369 SMITH 20 Research Dallas

7499 ALLEN 30 Sales Chicago

7521 WARD 30 Sales Chicago

7566 JONES 20 Research Dallas

7654 MARTIN 30 Sales Chicago

7698 BLAKE 30 Sales Chicago

7782 CLARK 10 Accounting New York

7788 SCOTT 20 Research Dallas

7839 KING 10 Accounting New York

7844 TURNER 30 Sales Chicago

7876 ADAMS 20 Research Dallas

7900 JAMES 30 Sales Chicago

7902 FORD 20 Research Dallas

7934 MILLER 10 Accounting New York

#### Searched CASE statement

A searched CASE statement uses one or more Boolean expressions to determine the resulting set of statements to execute.

CASE WHEN *boolean-expression* THEN

*statements*

\[ WHEN *boolean-expression* THEN

*statements*

\[ WHEN *boolean-expression* THEN

*statements* \] ...\]

\[ ELSE

*statements* \]

END CASE;

*boolean-expression* is evaluated in the order in which it appears within the CASE statement. When the first *boolean-expression* is encountered that evaluates to TRUE, the statement(s) in the corresponding THEN clause are executed and control continues following the END CASE keywords. If none of *boolean-expression* evaluates to TRUE, the statement(s) following ELSE are executed. If none of *boolean-expression* evaluates to TRUE and there is no ELSE clause, an exception is thrown.

The following example uses a searched CASE statement to assign a department name and location to a variable based upon the department number.

DECLARE

v\_empno emp.empno%TYPE;

v\_ename emp.ename%TYPE;

v\_deptno emp.deptno%TYPE;

v\_dname dept.dname%TYPE;

v\_loc dept.loc%TYPE;

CURSOR emp\_cursor IS SELECT empno, ename, deptno FROM emp;

BEGIN

OPEN emp\_cursor;

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME DEPTNO DNAME '

|| ' LOC');

DBMS\_OUTPUT.PUT\_LINE('----- ------- ------ ----------'

|| ' ---------');

LOOP

FETCH emp\_cursor INTO v\_empno, v\_ename, v\_deptno;

EXIT WHEN emp\_cursor%NOTFOUND;

CASE

WHEN v\_deptno = 10 THEN v\_dname := 'Accounting';

v\_loc := 'New York';

WHEN v\_deptno = 20 THEN v\_dname := 'Research';

v\_loc := 'Dallas';

WHEN v\_deptno = 30 THEN v\_dname := 'Sales';

v\_loc := 'Chicago';

WHEN v\_deptno = 40 THEN v\_dname := 'Operations';

v\_loc := 'Boston';

ELSE v\_dname := 'unknown';

v\_loc := '';

END CASE;

DBMS\_OUTPUT.PUT\_LINE(v\_empno || ' ' || RPAD(v\_ename, 10) ||

' ' || v\_deptno || ' ' || RPAD(v\_dname, 14) || ' ' ||

v\_loc);

END LOOP;

CLOSE emp\_cursor;

END;

The following is the output from this program.

EMPNO ENAME DEPTNO DNAME LOC

\----- ------- ------ ---------- ---------

7369 SMITH 20 Research Dallas

7499 ALLEN 30 Sales Chicago

7521 WARD 30 Sales Chicago

7566 JONES 20 Research Dallas

7654 MARTIN 30 Sales Chicago

7698 BLAKE 30 Sales Chicago

7782 CLARK 10 Accounting New York

7788 SCOTT 20 Research Dallas

7839 KING 10 Accounting New York

7844 TURNER 30 Sales Chicago

7876 ADAMS 20 Research Dallas

7900 JAMES 30 Sales Chicago

7902 FORD 20 Research Dallas

7934 MILLER 10 Accounting New York

### Loops

With the LOOP, EXIT, CONTINUE, WHILE, and FOR statements, you can arrange for your SPL program to repeat a series of commands.

#### LOOP

LOOP

*statements*

END LOOP;

LOOP defines an unconditional loop that is repeated indefinitely until terminated by an EXIT or RETURN statement.

#### EXIT

EXIT \[ WHEN *expression* \];

The innermost loop is terminated and the statement following END LOOP is executed next.

If WHEN is present, loop exit occurs only if the specified condition is true, otherwise control passes to the statement after EXIT.

EXIT can be used to cause early exit from all types of loops; it is not limited to use with unconditional loops.

The following is a simple example of a loop that iterates ten times and then uses the EXIT statement to terminate.

DECLARE

v\_counter NUMBER(2);

BEGIN

v\_counter := 1;

LOOP

EXIT WHEN v\_counter \> 10;

DBMS\_OUTPUT.PUT\_LINE('Iteration \# ' || v\_counter);

v\_counter := v\_counter + 1;

END LOOP;

END;

The following is the output from this program.

Iteration \# 1

Iteration \# 2

Iteration \# 3

Iteration \# 4

Iteration \# 5

Iteration \# 6

Iteration \# 7

Iteration \# 8

Iteration \# 9

Iteration \# 10

#### CONTINUE

The CONTINUE statement provides a way to proceed with the next iteration of a loop while skipping intervening statements.

When the CONTINUE statement is encountered, the next iteration of the innermost loop is begun, skipping all statements following the CONTINUE statement until the end of the loop. That is, control is passed back to the loop control expression, if any, and the body of the loop is re-evaluated.

If the WHEN clause is used, then the next iteration of the loop is begun only if the specified expression in the WHEN clause evaluates to true. Otherwise, control is passed to the next statement following the CONTINUE statement.

The CONTINUE statement may not be used outside of a loop.

The following is a variation of the previous example that uses the CONTINUE statement to skip the display of the odd numbers.

DECLARE

v\_counter NUMBER(2);

BEGIN

v\_counter := 0;

LOOP

v\_counter := v\_counter + 1;

EXIT WHEN v\_counter \> 10;

CONTINUE WHEN MOD(v\_counter,2) = 1;

DBMS\_OUTPUT.PUT\_LINE('Iteration \# ' || v\_counter);

END LOOP;

END;

The following is the output from above program.

Iteration \# 2

Iteration \# 4

Iteration \# 6

Iteration \# 8

Iteration \# 10

#### WHILE

WHILE *expression* LOOP

*statements*

END LOOP;

The WHILE statement repeats a sequence of statements so long as the condition expression evaluates to TRUE. The condition is checked just before each entry to the loop body.

The following example contains the same logic as in the previous example except the WHILE statement is used to take the place of the EXIT statement to determine when to exit the loop.

**Note:** The conditional expression used to determine when to exit the loop must be altered. The EXIT statement terminates the loop when its conditional expression is true. The WHILE statement terminates (or never begins the loop) when its conditional expression is false.

DECLARE

v\_counter NUMBER(2);

BEGIN

v\_counter := 1;

WHILE v\_counter \<= 10 LOOP

DBMS\_OUTPUT.PUT\_LINE('Iteration \# ' || v\_counter);

v\_counter := v\_counter + 1;

END LOOP;

END;

The same result is generated by this example as in the prior example.

Iteration \# 1

Iteration \# 2

Iteration \# 3

Iteration \# 4

Iteration \# 5

Iteration \# 6

Iteration \# 7

Iteration \# 8

Iteration \# 9

Iteration \# 10

#### FOR (integer variant)

FOR *name* IN \[REVERSE\] *expression* .. *expression* LOOP

*statements*

END LOOP;

This form of FOR creates a loop that iterates over a range of integer values. The variable *name* is automatically defined as type INTEGER and exists only inside the loop. The two expressions giving the loop range are evaluated once when entering the loop. The iteration step is +1 and *name* begins with the value of *expression* to the left of .. and terminates once *name* exceeds the value of *expression* to the right of ... Thus the two expressions take on the following roles: *start-value* .. *end-value.*

The optional REVERSE clause specifies that the loop should iterate in reverse order. The first time through the loop, *name* is set to the value of the right-most *expression*; the loop terminates when the *name* is less than the left-most *expression*.

The following example simplifies the WHILE loop example even further by using a FOR loop that iterates from 1 to 10.

BEGIN

FOR i IN 1 .. 10 LOOP

DBMS\_OUTPUT.PUT\_LINE('Iteration \# ' || i);

END LOOP;

END;

Here is the output using the FOR statement.

Iteration \# 1

Iteration \# 2

Iteration \# 3

Iteration \# 4

Iteration \# 5

Iteration \# 6

Iteration \# 7

Iteration \# 8

Iteration \# 9

Iteration \# 10

If the start value is greater than the end value the loop body is not executed at all. No error is raised as shown by the following example.

BEGIN

FOR i IN 10 .. 1 LOOP

DBMS\_OUTPUT.PUT\_LINE('Iteration \# ' || i);

END LOOP;

END;

There is no output from this example as the loop body is never executed.

**Note:** SPL also supports CURSOR FOR loops (see Section <span class="underline">3.8.7</span>).

### Exception Handling

By default, any error occurring in an SPL program aborts execution of the program. You can trap errors and recover from them by using a BEGIN block with an EXCEPTION section. The syntax is an extension of the normal syntax for a BEGIN block:

\[ DECLARE

*declarations* \]

BEGIN

*statements*

EXCEPTION

WHEN *condition* \[ OR *condition* \]... THEN

*handler\_statements*

\[ WHEN *condition* \[ OR *condition* \]... THEN

*handler\_statements* \]...

END;

If no error occurs, this form of block simply executes all the *statements*, and then control passes to the next statement after END. If an error occurs within the *statements*, further processing of the *statements* is abandoned, and control passes to the EXCEPTION list. The list is searched for the first *condition* matching the error that occurred. If a match is found, the corresponding *handler\_statements* are executed, and then control passes to the next statement after END. If no match is found, the error propagates out as though the EXCEPTION clause were not there at all. The error can be caught by an enclosing block with EXCEPTION; if there is no enclosing block, it aborts processing of the subprogram.

The special condition name OTHERS matches every error type. Condition names are not case-sensitive.

If a new error occurs within the selected *handler\_statements*, it cannot be caught by this EXCEPTION clause, but is propagated out. A surrounding EXCEPTION clause could catch it.

The following table lists the condition names that may be used:

Table 3‑2 Exception Condition Names

|                           |                                                                                                                                           |
| ------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| Condition Name            | Description                                                                                                                               |
| CASE\_NOT\_FOUND          | The application has encountered a situation where none of the cases in a CASE statement evaluates to TRUE and there is no ELSE condition. |
| COLLECTION\_IS\_NULL      | The application has attempted to invoke a collection method on a null collection such as an uninitialized nested table.                   |
| CURSOR\_ALREADY\_OPEN     | The application has attempted to open a cursor that is already open.                                                                      |
| DUP\_VAL\_ON\_INDEX       | The application has attempted to store a duplicate value that currently exists within a constrained column.                               |
| INVALID\_CURSOR           | The application has attempted to access an unopened cursor.                                                                               |
| INVALID\_NUMBER           | The application has encountered a data exception (equivalent to SQLSTATE class code 22). INVALID\_NUMBER is an alias for VALUE\_ERROR.    |
| NO\_DATA\_FOUND           | No rows satisfy the selection criteria.                                                                                                   |
| OTHERS                    | The application has encountered an exception that hasn’t been caught by a prior condition in the exception section.                       |
| SUBSCRIPT\_BEYOND\_COUNT  | The application has attempted to reference a subscript of a nested table or varray beyond its initialized or extended size.               |
| SUBSCRIPT\_OUTSIDE\_LIMIT | The application has attempted to reference a subscript or extend a varray beyond its maximum size limit.                                  |
| TOO\_MANY\_ROWS           | The application has encountered more than one row that satisfies the selection criteria (where only one row is allowed to be returned).   |
| VALUE\_ERROR              | The application has encountered a data exception (equivalent to SQLSTATE class code 22). VALUE\_ERROR is an alias for INVALID\_NUMBER.    |
| ZERO\_DIVIDE              | The application has tried to divide by zero.                                                                                              |
| *User-defined Exception*  | See Section <span class="underline">3.5.8</span>                                                                                          |

**Note:** Condition names INVALID\_NUMBER and VALUE\_ERROR are not compatible with Oracle databases for which these condition names are for exceptions resulting only from a failed conversion of a string to a numeric literal. In addition, for Oracle databases, an INVALID\_NUMBER exception is applicable only to SQL statements while a VALUE\_ERROR exception is applicable only to procedural statements.

### User-defined Exceptions

Any number of errors (referred to in PL/SQL as *exceptions*) can occur during program execution. When an exception is *thrown*, normal execution of the program stops, and control of the program transfers to the error-handling portion of the program. An *exception* may be a pre-defined error that is generated by the server, or may be a logical error that raises a user-defined exception.

User-defined exceptions are never raised by the server; they are raised explicitly by a RAISE statement. A user-defined exception is raised when a developer-defined logical rule is broken; a common example of a logical rule being broken occurs when a check is presented against an account with insufficient funds. An attempt to cash a check against an account with insufficient funds will provoke a user-defined exception.

You can define exceptions in functions, procedures, packages or anonymous blocks. While you cannot declare the same exception twice in the same block, you can declare the same exception in two different blocks.

Before implementing a user-defined exception, you must declare the exception in the declaration section of a function, procedure, package or anonymous block. You can then raise the exception using the RAISE statement:

> DECLARE
>
> *exception\_name* EXCEPTION;
>
> BEGIN
>
> ...
>
> RAISE *exception\_name*;
>
> ...
>
> END;

*exception\_name* is the name of the exception.

Unhandled exceptions propagate back through the call stack. If the exception remains unhandled, the exception is eventually reported to the client application.

User-defined exceptions declared in a block are considered to be local to that block, and global to any nested blocks within the block. To reference an exception that resides in an outer block, you must assign a label to the outer block; then, preface the name of the exception with the block name:

> *block*\_*name*.*exception*\_*name*

Conversely, outer blocks cannot reference exceptions declared in nested blocks.

The scope of a declaration is limited to the block in which it is declared *unless* it is created in a package, and when referenced, qualified by the package name. For example, to raise an exception named out\_of\_stock that resides in a package named inventory\_control a program must raise an error named:

> inventory\_control.out\_of\_stock

The following example demonstrates declaring a user-defined exception in a package. The user-defined exception does not require a package-qualifier when it is raised in check\_balance, since it resides in the same package as the exception:

> CREATE OR REPLACE PACKAGE ar AS
>
> overdrawn EXCEPTION;
>
> PROCEDURE check\_balance(p\_balance NUMBER, p\_amount NUMBER);
>
> END;
>
> CREATE OR REPLACE PACKAGE BODY ar AS
>
> PROCEDURE check\_balance(p\_balance NUMBER, p\_amount NUMBER)
>
> IS
>
> BEGIN
>
> IF (p\_amount \> p\_balance) THEN
>
> RAISE overdrawn;
>
> END IF;
>
> END;

The following procedure (purchase) calls the check\_balance procedure. If p\_amount is greater than p\_balance, check\_balance raises an exception; purchase catches the ar.overdrawn exception. purchase must refer to the exception with a package-qualified name (ar.overdrawn) because purchase is not defined within the ar package.

> CReATE PROCEDURE purchase(customerID int, amount NUMERIC)
>
> AS
>
> BEGIN
>
> ar.check\_ balance(getcustomerbalance(customerid), amount);
>
> record\_purchase(customerid, amount);
>
> EXCEPTION
>
> WHEN ar.overdrawn THEN
>
> raise\_credit\_limit(customerid, amount\*1.5);
>
> END;

When ar.check\_balance raises an exception, execution jumps to the exception handler defined in purchase:

> EXCEPTION
>
> WHEN ar.overdrawn THEN
>
> raise\_credit\_limit(customerid, amount\*1.5);

The exception handler raises the customer’s credit limit and ends. When the exception handler ends, execution resumes with the statement that follows ar.check\_balance.

### PRAGMA EXCEPTION\_INIT

PRAGMA EXCEPTION\_INIT associates a user-defined error code with an exception. A PRAGMA EXCEPTION\_INIT declaration may be included in any block, sub-block or package. You can only assign an error code to an exception (using PRAGMA EXCEPTION\_INIT) after declaring the exception. The format of a PRAGMA EXCEPTION\_INIT declaration is:

> PRAGMA EXCEPTION\_INIT(*exception*\_*name*,
>
> {*exception*\_*number | exception\_code*})

Where:

*exception\_name* is the name of the associated exception.

*exception\_number* is a user-defined error code associated with the pragma. If you specify an unmapped *exception\_number*, the server will return a warning.

*exception\_code* is the name of a pre-defined exception. For a complete list of valid exceptions, see the Postgres core documentation available at:

<https://www.postgresql.org/docs/10/static/errcodes-appendix.html>

The previous section (*User-defined Exceptions*) included an example that demonstrates declaring a user-defined exception in a package. The following example uses the same basic structure, but adds a PRAGMA EXCEPTION\_INIT declaration:

> CREATE OR REPLACE PACKAGE ar AS
>
> overdrawn EXCEPTION;
>
> PRAGMA EXCEPTION\_INIT (overdrawn, -20100);
>
> PROCEDURE check\_balance(p\_balance NUMBER, p\_amount NUMBER);
>
> END;
>
> CREATE OR REPLACE PACKAGE BODY ar AS
>
> PROCEDURE check\_balance(p\_balance NUMBER, p\_amount NUMBER)
>
> IS
>
> BEGIN
>
> IF (p\_amount \> p\_balance) THEN
>
> RAISE overdrawn;
>
> END IF;
>
> END;

The following procedure (purchase) calls the check\_balance procedure. If p\_amount is greater than p\_balance, check\_balance raises an exception; purchase catches the ar.overdrawn exception.

> CREATE PROCEDURE purchase(customerID int, amount NUMERIC)
>
> AS
>
> BEGIN
>
> ar.check\_ balance(getcustomerbalance(customerid), amount);
>
> record\_purchase(customerid, amount);
>
> EXCEPTION
>
> WHEN ar.overdrawn THEN
>
> DBMS\_OUTPUT.PUT\_LINE ('This account is overdrawn.');
>
> DBMS\_OUTPUT.PUT\_LINE ('SQLCode :'||SQLCODE||' '||SQLERRM );
>
> END;

When ar.check\_balance raises an exception, execution jumps to the exception handler defined in purchase.

> EXCEPTION
>
> WHEN ar.overdrawn THEN
>
> DBMS\_OUTPUT.PUT\_LINE ('This account is overdrawn.');
>
> DBMS\_OUTPUT.PUT\_LINE ('SQLCode :'||SQLCODE||' '||SQLERRM );

The exception handler returns an error message, followed by SQLCODE information:

> This account is overdrawn.
>
> SQLCODE: -20100 User-Defined Exception

The following example demonstrates using a pre-defined exception. The code creates a more meaningful name for the no\_data\_found exception; if the given customer does not exist, the code catches the exception, calls DBMS\_OUTPUT.PUT\_LINE to report the error, and then re-raises the original exception:

> CREATE OR REPLACE PACKAGE ar AS
>
> overdrawn EXCEPTION;
>
> PRAGMA EXCEPTION\_INIT (unknown\_customer, no\_data\_found);
>
> PROCEDURE check\_balance(p\_customer\_id NUMBER);
>
> END;
>
> CREATE OR REPLACE PACKAGE BODY ar AS
>
> PROCEDURE check\_balance(p\_customer\_id NUMBER)
>
> IS
>
> DECLARE
>
> v\_balance NUMBER;
>
> BEGIN
>
> SELECT balance INTO v\_balance FROM customer
>
> WHERE cust\_id = p\_customer\_id;
>
> EXCEPTION WHEN unknown\_customer THEN
>
> DBMS\_OUTPUT.PUT\_LINE('invalid customer id');
>
> RAISE;
>
> END;

### RAISE\_APPLICATION\_ERROR

The procedure, RAISE\_APPLICATION\_ERROR, allows a developer to intentionally abort processing within an SPL program from which it is called by causing an exception. The exception is handled in the same manner as described in Section <span class="underline">3.5.7</span>. In addition, the RAISE\_APPLICATION\_ERROR procedure makes a user-defined code and error message available to the program which can then be used to identify the exception.

RAISE\_APPLICATION\_ERROR(*error\_number*, *message*);

Where:

*error\_number* is an integer value or expression that is returned in a variable named SQLCODE when the procedure is executed. *error\_number* must be a value between ‑20000 and -20999.

*message* is a string literal or expression that is returned in a variable named SQLERRM.

For additional information on the SQLCODE and SQLERRM variables, see Section <span class="underline">3.13</span>, *Errors and Messages*.

The following example uses the RAISE\_APPLICATION\_ERROR procedure to display a different code and message depending upon the information missing from an employee.

CREATE OR REPLACE PROCEDURE verify\_emp (

p\_empno NUMBER

)

IS

v\_ename emp.ename%TYPE;

v\_job emp.job%TYPE;

v\_mgr emp.mgr%TYPE;

v\_hiredate emp.hiredate%TYPE;

BEGIN

SELECT ename, job, mgr, hiredate

INTO v\_ename, v\_job, v\_mgr, v\_hiredate FROM emp

WHERE empno = p\_empno;

IF v\_ename IS NULL THEN

RAISE\_APPLICATION\_ERROR(-20010, 'No name for ' || p\_empno);

END IF;

IF v\_job IS NULL THEN

RAISE\_APPLICATION\_ERROR(-20020, 'No job for' || p\_empno);

END IF;

IF v\_mgr IS NULL THEN

RAISE\_APPLICATION\_ERROR(-20030, 'No manager for ' || p\_empno);

END IF;

IF v\_hiredate IS NULL THEN

RAISE\_APPLICATION\_ERROR(-20040, 'No hire date for ' || p\_empno);

END IF;

DBMS\_OUTPUT.PUT\_LINE('Employee ' || p\_empno ||

' validated without errors');

EXCEPTION

WHEN OTHERS THEN

DBMS\_OUTPUT.PUT\_LINE('SQLCODE: ' || SQLCODE);

DBMS\_OUTPUT.PUT\_LINE('SQLERRM: ' || SQLERRM);

END;

The following shows the output in a case where the manager number is missing from an employee record.

EXEC verify\_emp(7839);

SQLCODE: -20030

SQLERRM: EDB-20030: No manager for 7839

## Transaction Control

There may be circumstances where it is desired that all updates to a database are to occur successfully, or none are to occur at all if any error occurs. A set of database updates that are to all occur successfully as a single unit, or are not to occur at all, is said to be a *transaction*.

A common example in banking is a funds transfer between two accounts. The two parts of the transaction are the withdrawal of funds from one account, and the deposit of the funds in another account. Both parts of this transaction must occur otherwise the bank’s books will be out of balance. The deposit and withdrawal are one transaction.

An SPL application can be created that uses a style of transaction control compatible with Oracle databases if the following conditions are met:
 - The edb\_stmt\_level\_tx parameter must be set to TRUE. This prevents the action of unconditionally rolling back all database updates within the BEGIN/END block if any exception occurs. See Section <span class="underline">1.3.4</span> for more information on the edb\_stmt\_level\_tx parameter.
 - The application must not be running in autocommit mode. If autocommit mode is on, each successful database update is immediately committed and cannot be undone. The manner in which autocommit mode is turned on or off is application dependent.

A transaction begins when the first SQL command is encountered in the SPL program. All subsequent SQL commands are included as part of that transaction. The transaction ends when one of the following occurs:
 - An unhandled exception occurs in which case the effects of all database updates made during the transaction are rolled back and the transaction is aborted.
 - A COMMIT command is encountered in which case the effect of all database updates made during the transaction become permanent.
 - A ROLLBACK command is encountered in which case the effects of all database updates made during the transaction are rolled back and the transaction is aborted. If a new SQL command is encountered, a new transaction begins.
 - Control returns to the calling application (such as Java, PSQL, etc.) in which case the action of the application determines whether the transaction is committed or rolled back.

**Note:** Unlike Oracle, DDL commands such as CREATE TABLE do not implicitly occur within their own transaction. Therefore, DDL commands do not automatically cause an immediate database commit as in Oracle, and DDL commands may be rolled back just like DML commands.

A transaction may span one or more BEGIN/END blocks, or a single BEGIN/END block may contain one or more transactions.

The following sections discuss the COMMIT and ROLLBACK commands in more detail.

### COMMIT

The COMMIT command makes all database updates made during the current transaction permanent, and ends the current transaction.

COMMIT \[ WORK \];

The COMMIT command may be used within anonymous blocks, stored procedures, or functions. Within an SPL program, it may appear in the executable section and/or the exception section.

In the following example, the third INSERT command in the anonymous block results in an error. The effect of the first two INSERT commands are retained as shown by the first SELECT command. Even after issuing a ROLLBACK command, the two rows remain in the table as shown by the second SELECT command verifying that they were indeed committed.

**Note:** The edb\_stmt\_level\_tx configuration parameter shown in the example below can be set for the entire database using the ALTER DATABASE command, or it can be set for the entire database server by changing it in the postgresql.conf file.

\\set AUTOCOMMIT off

SET edb\_stmt\_level\_tx TO on;

BEGIN

INSERT INTO dept VALUES (50, 'FINANCE', 'DALLAS');

INSERT INTO dept VALUES (60, 'MARKETING', 'CHICAGO');

COMMIT;

INSERT INTO dept VALUES (70, 'HUMAN RESOURCES', 'CHICAGO');

EXCEPTION

WHEN OTHERS THEN

DBMS\_OUTPUT.PUT\_LINE('SQLERRM: ' || SQLERRM);

DBMS\_OUTPUT.PUT\_LINE('SQLCODE: ' || SQLCODE);

END;

SQLERRM: value too long for type character varying(14)

SQLCODE: 22001

SELECT \* FROM dept;

deptno | dname | loc

\--------+------------+----------

10 | ACCOUNTING | NEW YORK

20 | RESEARCH | DALLAS

30 | SALES | CHICAGO

40 | OPERATIONS | BOSTON

50 | FINANCE | DALLAS

60 | MARKETING | CHICAGO

(6 rows)

ROLLBACK;

SELECT \* FROM dept;

deptno | dname | loc

\--------+------------+----------

10 | ACCOUNTING | NEW YORK

20 | RESEARCH | DALLAS

30 | SALES | CHICAGO

40 | OPERATIONS | BOSTON

50 | FINANCE | DALLAS

60 | MARKETING | CHICAGO

(6 rows)

### ROLLBACK

The ROLLBACK command undoes all database updates made during the current transaction, and ends the current transaction.

ROLLBACK \[ WORK \];

The ROLLBACK command may be used within anonymous blocks, stored procedures, or functions. Within an SPL program, it may appear in the executable section and/or the exception section.

In the following example, the exception section contains a ROLLBACK command. Even though the first two INSERT commands are executed successfully, the third results in an exception that results in the rollback of all the INSERT commands in the anonymous block.

\\set AUTOCOMMIT off

SET edb\_stmt\_level\_tx TO on;

BEGIN

INSERT INTO dept VALUES (50, 'FINANCE', 'DALLAS');

INSERT INTO dept VALUES (60, 'MARKETING', 'CHICAGO');

INSERT INTO dept VALUES (70, 'HUMAN RESOURCES', 'CHICAGO');

EXCEPTION

WHEN OTHERS THEN

ROLLBACK;

DBMS\_OUTPUT.PUT\_LINE('SQLERRM: ' || SQLERRM);

DBMS\_OUTPUT.PUT\_LINE('SQLCODE: ' || SQLCODE);

END;

SQLERRM: value too long for type character varying(14)

SQLCODE: 22001

SELECT \* FROM dept;

deptno | dname | loc

\--------+------------+----------

10 | ACCOUNTING | NEW YORK

20 | RESEARCH | DALLAS

30 | SALES | CHICAGO

40 | OPERATIONS | BOSTON

(4 rows)

The following is a more complex example using both COMMIT and ROLLBACK. First, the following stored procedure is created which inserts a new employee.

\\set AUTOCOMMIT off

SET edb\_stmt\_level\_tx TO on;

CREATE OR REPLACE PROCEDURE emp\_insert (

p\_empno IN emp.empno%TYPE,

p\_ename IN emp.ename%TYPE,

p\_job IN emp.job%TYPE,

p\_mgr IN emp.mgr%TYPE,

p\_hiredate IN emp.hiredate%TYPE,

p\_sal IN emp.sal%TYPE,

p\_comm IN emp.comm%TYPE,

p\_deptno IN emp.deptno%TYPE

)

IS

BEGIN

INSERT INTO emp VALUES (

p\_empno,

p\_ename,

p\_job,

p\_mgr,

p\_hiredate,

p\_sal,

p\_comm,

p\_deptno);

DBMS\_OUTPUT.PUT\_LINE('Added employee...');

DBMS\_OUTPUT.PUT\_LINE('Employee \# : ' || p\_empno);

DBMS\_OUTPUT.PUT\_LINE('Name : ' || p\_ename);

DBMS\_OUTPUT.PUT\_LINE('Job : ' || p\_job);

DBMS\_OUTPUT.PUT\_LINE('Manager : ' || p\_mgr);

DBMS\_OUTPUT.PUT\_LINE('Hire Date : ' || p\_hiredate);

DBMS\_OUTPUT.PUT\_LINE('Salary : ' || p\_sal);

DBMS\_OUTPUT.PUT\_LINE('Commission : ' || p\_comm);

DBMS\_OUTPUT.PUT\_LINE('Dept \# : ' || p\_deptno);

DBMS\_OUTPUT.PUT\_LINE('----------------------');

END;

Note that this procedure has no exception section so any error that may occur is propagated up to the calling program.

The following anonymous block is run. Note the use of the COMMIT command after all calls to the emp\_insert procedure and the ROLLBACK command in the exception section.

BEGIN

emp\_insert(9601,'FARRELL','ANALYST',7902,'03-MAR-08',5000,NULL,40);

emp\_insert(9602,'TYLER','ANALYST',7900,'25-JAN-08',4800,NULL,40);

COMMIT;

EXCEPTION

WHEN OTHERS THEN

DBMS\_OUTPUT.PUT\_LINE('SQLERRM: ' || SQLERRM);

DBMS\_OUTPUT.PUT\_LINE('An error occurred - roll back inserts');

ROLLBACK;

END;

Added employee...

Employee \# : 9601

Name : FARRELL

Job : ANALYST

Manager : 7902

Hire Date : 03-MAR-08 00:00:00

Salary : 5000

Commission :

Dept \# : 40

\----------------------

Added employee...

Employee \# : 9602

Name : TYLER

Job : ANALYST

Manager : 7900

Hire Date : 25-JAN-08 00:00:00

Salary : 4800

Commission :

Dept \# : 40

\----------------------

The following SELECT command shows that employees Farrell and Tyler were successfully added.

SELECT \* FROM emp WHERE empno \> 9600;

empno | ename | job | mgr | hiredate | sal | comm | deptno

\-------+---------+---------+------+--------------------+---------+------+--------

9601 | FARRELL | ANALYST | 7902 | 03-MAR-08 00:00:00 | 5000.00 | | 40

9602 | TYLER | ANALYST | 7900 | 25-JAN-08 00:00:00 | 4800.00 | | 40

(2 rows)

Now, execute the following anonymous block:

BEGIN

emp\_insert(9603,'HARRISON','SALESMAN',7902,'13-DEC-07',5000,3000,20);

emp\_insert(9604,'JARVIS','SALESMAN',7902,'05-MAY-08',4800,4100,11);

COMMIT;

EXCEPTION

WHEN OTHERS THEN

DBMS\_OUTPUT.PUT\_LINE('SQLERRM: ' || SQLERRM);

DBMS\_OUTPUT.PUT\_LINE('An error occurred - roll back inserts');

ROLLBACK;

END;

Added employee...

Employee \# : 9603

Name : HARRISON

Job : SALESMAN

Manager : 7902

Hire Date : 13-DEC-07 00:00:00

Salary : 5000

Commission : 3000

Dept \# : 20

\----------------------

SQLERRM: insert or update on table "emp" violates foreign key constraint "emp\_ref\_dept\_fk"

An error occurred - roll back inserts

A SELECT command run against the table yields the following:

SELECT \* FROM emp WHERE empno \> 9600;

empno | ename | job | mgr | hiredate | sal | comm | deptno

\-------+---------+---------+------+--------------------+---------+------+--------

9601 | FARRELL | ANALYST | 7902 | 03-MAR-08 00:00:00 | 5000.00 | | 40

9602 | TYLER | ANALYST | 7900 | 25-JAN-08 00:00:00 | 4800.00 | | 40

(2 rows)

The ROLLBACK command in the exception section successfully undoes the insert of employee Harrison. Also note that employees Farrell and Tyler are still in the table as their inserts were made permanent by the COMMIT command in the first anonymous block.

## Dynamic SQL

*Dynamic SQL* is a technique that provides the ability to execute SQL commands that are not known until the commands are about to be executed. Up to this point, the SQL commands that have been illustrated in SPL programs have been static SQL - the full command (with the exception of variables) must be known and coded into the program before the program, itself, can begin to execute. Thus using dynamic SQL, the executed SQL can change during program runtime.

In addition, dynamic SQL is the only method by which data definition commands, such as CREATE TABLE, can be executed from within an SPL program.

Note, however, that the runtime performance of dynamic SQL will be slower than static SQL.

The EXECUTE IMMEDIATE command is used to run SQL commands dynamically.

EXECUTE IMMEDIATE '*sql\_expression*;'

\[ INTO { *variable* \[, ...\] | *record* } \]

\[ USING *expression* \[, ...\] \]

*sql\_expression* is a string expression containing the SQL command to be dynamically executed. *variable* receives the output of the result set, typically from a SELECT command, created as a result of executing the SQL command in *sql\_expression*. The number, order, and type of variables must match the number, order, and be type-compatible with the fields of the result set. Alternatively, a record can be specified as long as the record’s fields match the number, order, and are type-compatible with the result set. When using the INTO clause, exactly one row must be returned in the result set, otherwise an exception occurs. When using the USING clause the value of *expression* is passed to a *placeholder*. Placeholders appear embedded within the SQL command in *sql\_expression* where variables may be used. Placeholders are denoted by an identifier with a colon (:) prefix - :*name*. The number, order, and resultant data types of the evaluated expressions must match the number, order and be type-compatible with the placeholders in *sql\_expression*. Note that placeholders are not declared anywhere in the SPL program – they only appear in *sql\_expression*.

The following example shows basic dynamic SQL commands as string literals.

DECLARE

v\_sql VARCHAR2(50);

BEGIN

EXECUTE IMMEDIATE 'CREATE TABLE job (jobno NUMBER(3),' ||

' jname VARCHAR2(9))';

v\_sql := 'INSERT INTO job VALUES (100, ''ANALYST'')';

EXECUTE IMMEDIATE v\_sql;

v\_sql := 'INSERT INTO job VALUES (200, ''CLERK'')';

EXECUTE IMMEDIATE v\_sql;

END;

The following example illustrates the USING clause to pass values to placeholders in the SQL string.

DECLARE

v\_sql VARCHAR2(50) := 'INSERT INTO job VALUES ' ||

'(:p\_jobno, :p\_jname)';

v\_jobno job.jobno%TYPE;

v\_jname job.jname%TYPE;

BEGIN

v\_jobno := 300;

v\_jname := 'MANAGER';

EXECUTE IMMEDIATE v\_sql USING v\_jobno, v\_jname;

v\_jobno := 400;

v\_jname := 'SALESMAN';

EXECUTE IMMEDIATE v\_sql USING v\_jobno, v\_jname;

v\_jobno := 500;

v\_jname := 'PRESIDENT';

EXECUTE IMMEDIATE v\_sql USING v\_jobno, v\_jname;

END;

The following example shows both the INTO and USING clauses. Note the last execution of the SELECT command returns the results into a record instead of individual variables.

DECLARE

v\_sql VARCHAR2(60);

v\_jobno job.jobno%TYPE;

v\_jname job.jname%TYPE;

r\_job job%ROWTYPE;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('JOBNO JNAME');

DBMS\_OUTPUT.PUT\_LINE('----- -------');

v\_sql := 'SELECT jobno, jname FROM job WHERE jobno = :p\_jobno';

EXECUTE IMMEDIATE v\_sql INTO v\_jobno, v\_jname USING 100;

DBMS\_OUTPUT.PUT\_LINE(v\_jobno || ' ' || v\_jname);

EXECUTE IMMEDIATE v\_sql INTO v\_jobno, v\_jname USING 200;

DBMS\_OUTPUT.PUT\_LINE(v\_jobno || ' ' || v\_jname);

EXECUTE IMMEDIATE v\_sql INTO v\_jobno, v\_jname USING 300;

DBMS\_OUTPUT.PUT\_LINE(v\_jobno || ' ' || v\_jname);

EXECUTE IMMEDIATE v\_sql INTO v\_jobno, v\_jname USING 400;

DBMS\_OUTPUT.PUT\_LINE(v\_jobno || ' ' || v\_jname);

EXECUTE IMMEDIATE v\_sql INTO r\_job USING 500;

DBMS\_OUTPUT.PUT\_LINE(r\_job.jobno || ' ' || r\_job.jname);

END;

The following is the output from the previous anonymous block:

JOBNO JNAME

\----- -------

100 ANALYST

200 CLERK

300 MANAGER

400 SALESMAN

500 PRESIDENT

You can use the BULK COLLECT clause to assemble the result set from an EXECUTE IMMEDIATE statement into a named collection. See Section <span class="underline">3.12.4</span>, EXECUTE IMMEDIATE BULK COLLECT for information about using the BULK COLLECT clause.

## Static Cursors

Rather than executing a whole query at once, it is possible to set up a *cursor* that encapsulates the query, and then read the query result set one row at a time. This allows the creation of SPL program logic that retrieves a row from the result set, does some processing on the data in that row, and then retrieves the next row and repeats the process.

Cursors are most often used in the context of a FOR or WHILE loop. A conditional test should be included in the SPL logic that detects when the end of the result set has been reached so the program can exit the loop.

### Declaring a Cursor

In order to use a cursor, it must first be declared in the declaration section of the SPL program. A cursor declaration appears as follows:

CURSOR *name* IS *query*;

*name* is an identifier that will be used to reference the cursor and its result set later in the program. *query* is a SQL SELECT command that determines the result set retrievable by the cursor.

**Note:** An extension of this syntax allows the use of parameters. This is discussed in more detail in Section <span class="underline">3.8.8</span>.

The following are some examples of cursor declarations:

CREATE OR REPLACE PROCEDURE cursor\_example

IS

CURSOR emp\_cur\_1 IS SELECT \* FROM emp;

CURSOR emp\_cur\_2 IS SELECT empno, ename FROM emp;

CURSOR emp\_cur\_3 IS SELECT empno, ename FROM emp WHERE deptno = 10

ORDER BY empno;

BEGIN

...

END;

### Opening a Cursor

Before a cursor can be used to retrieve rows, it must first be opened. This is accomplished with the OPEN statement.

OPEN *name*;

*name* is the identifier of a cursor that has been previously declared in the declaration section of the SPL program. The OPEN statement must not be executed on a cursor that has already been, and still is open.

The following shows an OPEN statement with its corresponding cursor declaration.

CREATE OR REPLACE PROCEDURE cursor\_example

IS

CURSOR emp\_cur\_3 IS SELECT empno, ename FROM emp WHERE deptno = 10

ORDER BY empno;

BEGIN

OPEN emp\_cur\_3;

...

END;

### Fetching Rows From a Cursor

Once a cursor has been opened, rows can be retrieved from the cursor’s result set by using the FETCH statement.

FETCH *name* INTO { *record* | *variable* \[, *variable\_2* \]... };

*name* is the identifier of a previously opened cursor. *record* is the identifier of a previously defined record (for example, using *table*%ROWTYPE). *variable*, *variable\_2*... are SPL variables that will receive the field data from the fetched row. The fields in *record* or *variable*, *variable\_2*... must match in number and order, the fields returned in the SELECT list of the query given in the cursor declaration. The data types of the fields in the SELECT list must match, or be implicitly convertible to the data types of the fields in *record* or the data types of *variable*, *variable\_2*...

**Note:** There is a variation of FETCH INTO using the BULK COLLECT clause that can return multiple rows at a time into a collection. See Section <span class="underline">3.12.4</span> for more information on using the BULK COLLECT clause with the FETCH INTO statement.

The following shows the FETCH statement.

CREATE OR REPLACE PROCEDURE cursor\_example

IS

v\_empno NUMBER(4);

v\_ename VARCHAR2(10);

CURSOR emp\_cur\_3 IS SELECT empno, ename FROM emp WHERE deptno = 10

ORDER BY empno;

BEGIN

OPEN emp\_cur\_3;

FETCH emp\_cur\_3 INTO v\_empno, v\_ename;

...

END;

Instead of explicitly declaring the data type of a target variable, %TYPE can be used instead. In this way, if the data type of the database column is changed, the target variable declaration in the SPL program does not have to be changed. %TYPE will automatically pick up the new data type of the specified column.

CREATE OR REPLACE PROCEDURE cursor\_example

IS

v\_empno emp.empno%TYPE;

v\_ename emp.ename%TYPE;

CURSOR emp\_cur\_3 IS SELECT empno, ename FROM emp WHERE deptno = 10

ORDER BY empno;

BEGIN

OPEN emp\_cur\_3;

FETCH emp\_cur\_3 INTO v\_empno, v\_ename;

...

END;

If all the columns in a table are retrieved in the order defined in the table, %ROWTYPE can be used to define a record into which the FETCH statement will place the retrieved data. Each field within the record can then be accessed using dot notation.

CREATE OR REPLACE PROCEDURE cursor\_example

IS

v\_emp\_rec emp%ROWTYPE;

CURSOR emp\_cur\_1 IS SELECT \* FROM emp;

BEGIN

OPEN emp\_cur\_1;

FETCH emp\_cur\_1 INTO v\_emp\_rec;

DBMS\_OUTPUT.PUT\_LINE('Employee Number: ' || v\_emp\_rec.empno);

DBMS\_OUTPUT.PUT\_LINE('Employee Name : ' || v\_emp\_rec.ename);

...

END;

### Closing a Cursor

Once all the desired rows have been retrieved from the cursor result set, the cursor must be closed. Once closed, the result set is no longer accessible. The CLOSE statement appears as follows:

CLOSE *name*;

*name* is the identifier of a cursor that is currently open. Once a cursor is closed, it must not be closed again. However, once the cursor is closed, the OPEN statement can be issued again on the closed cursor and the query result set will be rebuilt after which the FETCH statement can then be used to retrieve the rows of the new result set.

The following example illustrates the use of the CLOSE statement:

CREATE OR REPLACE PROCEDURE cursor\_example

IS

v\_emp\_rec emp%ROWTYPE;

CURSOR emp\_cur\_1 IS SELECT \* FROM emp;

BEGIN

OPEN emp\_cur\_1;

FETCH emp\_cur\_1 INTO v\_emp\_rec;

DBMS\_OUTPUT.PUT\_LINE('Employee Number: ' || v\_emp\_rec.empno);

DBMS\_OUTPUT.PUT\_LINE('Employee Name : ' || v\_emp\_rec.ename);

CLOSE emp\_cur\_1;

END;

This procedure produces the following output when invoked. Employee number 7369, SMITH is the first row of the result set.

EXEC cursor\_example;

Employee Number: 7369

Employee Name : SMITH

### Using %ROWTYPE With Cursors

Using the %ROWTYPE attribute, a record can be defined that contains fields corresponding to all columns fetched from a cursor or cursor variable. Each field takes on the data type of its corresponding column. The %ROWTYPE attribute is prefixed by a cursor name or cursor variable name.

*record* *cursor*%ROWTYPE;

*record* is an identifier assigned to the record. *cursor* is an explicitly declared cursor within the current scope.

The following example shows how you can use a cursor with %ROWTYPE to get information about which employee works in which department.

CREATE OR REPLACE PROCEDURE emp\_info

IS

CURSOR empcur IS SELECT ename, deptno FROM emp;

myvar empcur%ROWTYPE;

BEGIN

OPEN empcur;

LOOP

FETCH empcur INTO myvar;

EXIT WHEN empcur%NOTFOUND;

DBMS\_OUTPUT.PUT\_LINE( myvar.ename || ' works in department '

|| myvar.deptno );

END LOOP;

CLOSE empcur;

END;

The following is the output from this procedure.

EXEC emp\_info;

SMITH works in department 20

ALLEN works in department 30

WARD works in department 30

JONES works in department 20

MARTIN works in department 30

BLAKE works in department 30

CLARK works in department 10

SCOTT works in department 20

KING works in department 10

TURNER works in department 30

ADAMS works in department 20

JAMES works in department 30

FORD works in department 20

MILLER works in department 10

### Cursor Attributes

Each cursor has a set of attributes associated with it that allows the program to test the state of the cursor. These attributes are %ISOPEN, %FOUND, %NOTFOUND, and %ROWCOUNT. These attributes are described in the following sections.

#### %ISOPEN

The %ISOPEN attribute is used to test whether or not a cursor is open.

*cursor\_name*%ISOPEN

*cursor\_name* is the name of the cursor for which a BOOLEAN data type of TRUE will be returned if the cursor is open, FALSE otherwise.

The following is an example of using %ISOPEN.

CREATE OR REPLACE PROCEDURE cursor\_example

IS

...

CURSOR emp\_cur\_1 IS SELECT \* FROM emp;

...

BEGIN

...

IF emp\_cur\_1%ISOPEN THEN

NULL;

ELSE

OPEN emp\_cur\_1;

END IF;

FETCH emp\_cur\_1 INTO ...

...

END;

#### %FOUND

The %FOUND attribute is used to test whether or not a row is retrieved from the result set of the specified cursor after a FETCH on the cursor.

*cursor\_name*%FOUND

*cursor\_name* is the name of the cursor for which a BOOLEAN data type of TRUE will be returned if a row is retrieved from the result set of the cursor after a FETCH.

After the last row of the result set has been FETCHed the next FETCH results in %FOUND returning FALSE. FALSE is also returned after the first FETCH if there are no rows in the result set to begin with.

Referencing %FOUND on a cursor before it is opened or after it is closed results in an INVALID\_CURSOR exception being thrown.

%FOUND returns null if it is referenced when the cursor is open, but before the first FETCH.

The following example uses %FOUND.

CREATE OR REPLACE PROCEDURE cursor\_example

IS

v\_emp\_rec emp%ROWTYPE;

CURSOR emp\_cur\_1 IS SELECT \* FROM emp;

BEGIN

OPEN emp\_cur\_1;

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME');

DBMS\_OUTPUT.PUT\_LINE('----- -------');

FETCH emp\_cur\_1 INTO v\_emp\_rec;

WHILE emp\_cur\_1%FOUND LOOP

DBMS\_OUTPUT.PUT\_LINE(v\_emp\_rec.empno || ' ' || v\_emp\_rec.ename);

FETCH emp\_cur\_1 INTO v\_emp\_rec;

END LOOP;

CLOSE emp\_cur\_1;

END;

When the previous procedure is invoked, the output appears as follows:

EXEC cursor\_example;

EMPNO ENAME

\----- ------

7369 SMITH

7499 ALLEN

7521 WARD

7566 JONES

7654 MARTIN

7698 BLAKE

7782 CLARK

7788 SCOTT

7839 KING

7844 TURNER

7876 ADAMS

7900 JAMES

7902 FORD

7934 MILLER

#### %NOTFOUND

The %NOTFOUND attribute is the logical opposite of %FOUND.

*cursor\_name*%NOTFOUND

*cursor\_name* is the name of the cursor for which a BOOLEAN data type of FALSE will be returned if a row is retrieved from the result set of the cursor after a FETCH.

After the last row of the result set has been FETCHed the next FETCH results in %NOTFOUND returning TRUE. TRUE is also returned after the first FETCH if there are no rows in the result set to begin with.

Referencing %NOTFOUND on a cursor before it is opened or after it is closed, results in an INVALID\_CURSOR exception being thrown.

%NOTFOUND returns null if it is referenced when the cursor is open, but before the first FETCH.

The following example uses %NOTFOUND.

CREATE OR REPLACE PROCEDURE cursor\_example

IS

v\_emp\_rec emp%ROWTYPE;

CURSOR emp\_cur\_1 IS SELECT \* FROM emp;

BEGIN

OPEN emp\_cur\_1;

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME');

DBMS\_OUTPUT.PUT\_LINE('----- -------');

LOOP

FETCH emp\_cur\_1 INTO v\_emp\_rec;

EXIT WHEN emp\_cur\_1%NOTFOUND;

DBMS\_OUTPUT.PUT\_LINE(v\_emp\_rec.empno || ' ' || v\_emp\_rec.ename);

END LOOP;

CLOSE emp\_cur\_1;

END;

Similar to the prior example, this procedure produces the same output when invoked.

EXEC cursor\_example;

EMPNO ENAME

\----- ------

7369 SMITH

7499 ALLEN

7521 WARD

7566 JONES

7654 MARTIN

7698 BLAKE

7782 CLARK

7788 SCOTT

7839 KING

7844 TURNER

7876 ADAMS

7900 JAMES

7902 FORD

7934 MILLER

#### %ROWCOUNT

The %ROWCOUNT attribute returns an integer showing the number of rows FETCHed so far from the specified cursor.

*cursor\_name*%ROWCOUNT

*cursor\_name* is the name of the cursor for which %ROWCOUNT returns the number of rows retrieved thus far. After the last row has been retrieved, %ROWCOUNT remains set to the total number of rows returned until the cursor is closed at which point %ROWCOUNT will throw an INVALID\_CURSOR exception if referenced.

Referencing %ROWCOUNT on a cursor before it is opened or after it is closed, results in an INVALID\_CURSOR exception being thrown.

%ROWCOUNT returns 0 if it is referenced when the cursor is open, but before the first FETCH. %ROWCOUNT also returns 0 after the first FETCH when there are no rows in the result set to begin with.

The following example uses %ROWCOUNT.

CREATE OR REPLACE PROCEDURE cursor\_example

IS

v\_emp\_rec emp%ROWTYPE;

CURSOR emp\_cur\_1 IS SELECT \* FROM emp;

BEGIN

OPEN emp\_cur\_1;

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME');

DBMS\_OUTPUT.PUT\_LINE('----- -------');

LOOP

FETCH emp\_cur\_1 INTO v\_emp\_rec;

EXIT WHEN emp\_cur\_1%NOTFOUND;

DBMS\_OUTPUT.PUT\_LINE(v\_emp\_rec.empno || ' ' || v\_emp\_rec.ename);

END LOOP;

DBMS\_OUTPUT.PUT\_LINE('\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*');

DBMS\_OUTPUT.PUT\_LINE(emp\_cur\_1%ROWCOUNT || ' rows were retrieved');

CLOSE emp\_cur\_1;

END;

This procedure prints the total number of rows retrieved at the end of the employee list as follows:

EXEC cursor\_example;

EMPNO ENAME

\----- -------

7369 SMITH

7499 ALLEN

7521 WARD

7566 JONES

7654 MARTIN

7698 BLAKE

7782 CLARK

7788 SCOTT

7839 KING

7844 TURNER

7876 ADAMS

7900 JAMES

7902 FORD

7934 MILLER

\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

14 rows were retrieved

#### Summary of Cursor States and Attributes

The following table summarizes the possible cursor states and the values returned by the cursor attributes.

Table 3‑3 Cursor Attributes

|                                         |         |                           |                           |                           |
| --------------------------------------- | ------- | ------------------------- | ------------------------- | ------------------------- |
| Cursor State                            | %ISOPEN | %FOUND                    | %NOTFOUND                 | %ROWCOUNT                 |
| Before OPEN                             | False   | INVALID\_CURSOR Exception | INVALID\_CURSOR Exception | INVALID\_CURSOR Exception |
| After OPEN & Before 1st FETCH           | True    | Null                      | Null                      | 0                         |
| After 1st Successful FETCH              | True    | True                      | False                     | 1                         |
| After *n*th Successful FETCH (last row) | True    | True                      | False                     | n                         |
| After *n*+1st FETCH (after last row)    | True    | False                     | True                      | n                         |
| After CLOSE                             | False   | INVALID\_CURSOR Exception | INVALID\_CURSOR Exception | INVALID\_CURSOR Exception |

### Cursor FOR Loop

In the cursor examples presented so far, the programming logic required to process the result set of a cursor included a statement to open the cursor, a loop construct to retrieve each row of the result set, a test for the end of the result set, and finally a statement to close the cursor. The *cursor FOR loop* is a loop construct that eliminates the need to individually code the statements just listed.

The cursor FOR loop opens a previously declared cursor, fetches all rows in the cursor result set, and then closes the cursor.

The syntax for creating a cursor FOR loop is as follows.

FOR *record* IN *cursor*

LOOP

*statements*

END LOOP;

*record* is an identifier assigned to an implicitly declared record with definition, *cursor*%ROWTYPE. *cursor* is the name of a previously declared cursor. *statements* are one or more SPL statements. There must be at least one statement.

The following example shows the example from Section <span class="underline">3.8.6.3</span>, modified to use a cursor FOR loop.

CREATE OR REPLACE PROCEDURE cursor\_example

IS

CURSOR emp\_cur\_1 IS SELECT \* FROM emp;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME');

DBMS\_OUTPUT.PUT\_LINE('----- -------');

FOR v\_emp\_rec IN emp\_cur\_1 LOOP

DBMS\_OUTPUT.PUT\_LINE(v\_emp\_rec.empno || ' ' || v\_emp\_rec.ename);

END LOOP;

END;

The same results are achieved as shown in the output below.

EXEC cursor\_example;

EMPNO ENAME

\----- -------

7369 SMITH

7499 ALLEN

7521 WARD

7566 JONES

7654 MARTIN

7698 BLAKE

7782 CLARK

7788 SCOTT

7839 KING

7844 TURNER

7876 ADAMS

7900 JAMES

7902 FORD

7934 MILLER

### Parameterized Cursors

A user can also declare a static cursor that accepts parameters, and can pass values for those parameters when opening that cursor. In the following example we have created a parameterized cursor which will display the name and salary of all employees from the emp table that have a salary less than a specified value which is passed as a parameter.

DECLARE

my\_record emp%ROWTYPE;

CURSOR c1 (max\_wage NUMBER) IS

SELECT \* FROM emp WHERE sal \< max\_wage;

BEGIN

OPEN c1(2000);

LOOP

FETCH c1 INTO my\_record;

EXIT WHEN c1%NOTFOUND;

DBMS\_OUTPUT.PUT\_LINE('Name = ' || my\_record.ename || ', salary = '

|| my\_record.sal);

END LOOP;

CLOSE c1;

END;

So for example if we pass the value 2000 as max\_wage, then we will only be shown the name and salary of all employees that have a salary less than 2000. The result of the above query is the following:

Name = SMITH, salary = 800.00

Name = ALLEN, salary = 1600.00

Name = WARD, salary = 1250.00

Name = MARTIN, salary = 1250.00

Name = TURNER, salary = 1500.00

Name = ADAMS, salary = 1100.00

Name = JAMES, salary = 950.00

Name = MILLER, salary = 1300.00

## REF CURSORs and Cursor Variables

This section discusses another type of cursor that provides far greater flexibility than the previously discussed static cursors.

### REF CURSOR Overview

A *cursor variable* is a cursor that actually contains a pointer to a query result set. The result set is determined by the execution of the OPEN FOR statement using the cursor variable.

A cursor variable is not tied to a single particular query like a static cursor. The same cursor variable may be opened a number of times with OPEN FOR statements containing different queries. Each time, a new result set is created from that query and made available via the cursor variable.

REF CURSOR types may be passed as parameters to or from stored procedures and functions. The return type of a function may also be a REF CURSOR type. This provides the capability to modularize the operations on a cursor into separate programs by passing a cursor variable between programs.

### Declaring a Cursor Variable

SPL supports the declaration of a cursor variable using both the SYS\_REFCURSOR built-in data type as well as creating a type of REF CURSOR and then declaring a variable of that type. SYS\_REFCURSOR is a REF CURSOR type that allows any result set to be associated with it. This is known as a *weakly-typed* REF CURSOR.

Only the declaration of SYS\_REFCURSOR and user-defined REF CURSOR variables are different. The remaining usage like opening the cursor, selecting into the cursor and closing the cursor is the same across both the cursor types. For the rest of this chapter our examples will primarily be making use of the SYS\_REFCURSOR cursors. All you need to change in the examples to make them work for user defined REF CURSORs is the declaration section.

**Note:** *Strongly-typed* REF CURSORs require the result set to conform to a declared number and order of fields with compatible data types and can also optionally return a result set.

#### Declaring a SYS\_REFCURSOR Cursor Variable

The following is the syntax for declaring a SYS\_REFCURSOR cursor variable:

*name* SYS\_REFCURSOR;

*name* is an identifier assigned to the cursor variable.

The following is an example of a SYS\_REFCURSOR variable declaration.

DECLARE

emp\_refcur SYS\_REFCURSOR;

...

#### Declaring a User Defined REF CURSOR Type Variable

You must perform two distinct declaration steps in order to use a user defined REF CURSOR variable:
 - Create a referenced cursor TYPE
 - Declare the actual cursor variable based on that TYPE

The syntax for creating a user defined REF CURSOR type is as follows:

TYPE *cursor\_type\_name* IS REF CURSOR \[RETURN *return\_type*\];

The following is an example of a cursor variable declaration.

DECLARE

TYPE emp\_cur\_type IS REF CURSOR RETURN emp%ROWTYPE;

my\_rec emp\_cur\_type;

...

### Opening a Cursor Variable

Once a cursor variable is declared, it must be opened with an associated SELECT command. The OPEN FOR statement specifies the SELECT command to be used to create the result set.

OPEN *name* FOR *query*;

*name* is the identifier of a previously declared cursor variable. *query* is a SELECT command that determines the result set when the statement is executed. The value of the cursor variable after the OPEN FOR statement is executed identifies the result set.

In the following example, the result set is a list of employee numbers and names from a selected department. Note that a variable or parameter can be used in the SELECT command anywhere an expression can normally appear. In this case a parameter is used in the equality test for department number.

CREATE OR REPLACE PROCEDURE emp\_by\_dept (

p\_deptno emp.deptno%TYPE

)

IS

emp\_refcur SYS\_REFCURSOR;

BEGIN

OPEN emp\_refcur FOR SELECT empno, ename FROM emp WHERE deptno = p\_deptno;

...

### Fetching Rows From a Cursor Variable

After a cursor variable is opened, rows may be retrieved from the result set using the FETCH statement. See Section <span class="underline">3.8.3</span> for details on using the FETCH statement to retrieve rows from a result set.

In the example below, a FETCH statement has been added to the previous example so now the result set is returned into two variables and then displayed. Note that the cursor attributes used to determine cursor state of static cursors can also be used with cursor variables. See Section <span class="underline">3.8.6</span> for details on cursor attributes.

CREATE OR REPLACE PROCEDURE emp\_by\_dept (

p\_deptno emp.deptno%TYPE

)

IS

emp\_refcur SYS\_REFCURSOR;

v\_empno emp.empno%TYPE;

v\_ename emp.ename%TYPE;

BEGIN

OPEN emp\_refcur FOR SELECT empno, ename FROM emp WHERE deptno = p\_deptno;

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME');

DBMS\_OUTPUT.PUT\_LINE('----- -------');

LOOP

FETCH emp\_refcur INTO v\_empno, v\_ename;

EXIT WHEN emp\_refcur%NOTFOUND;

DBMS\_OUTPUT.PUT\_LINE(v\_empno || ' ' || v\_ename);

END LOOP;

...

### Closing a Cursor Variable

Use the CLOSE statement described in Section <span class="underline">3.8.4</span> to release the result set.

**Note:** Unlike static cursors, a cursor variable does not have to be closed before it can be re-opened again. The result set from the previous open will be lost.

The example is completed with the addition of the CLOSE statement.

CREATE OR REPLACE PROCEDURE emp\_by\_dept (

p\_deptno emp.deptno%TYPE

)

IS

emp\_refcur SYS\_REFCURSOR;

v\_empno emp.empno%TYPE;

v\_ename emp.ename%TYPE;

BEGIN

OPEN emp\_refcur FOR SELECT empno, ename FROM emp WHERE deptno = p\_deptno;

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME');

DBMS\_OUTPUT.PUT\_LINE('----- -------');

LOOP

FETCH emp\_refcur INTO v\_empno, v\_ename;

EXIT WHEN emp\_refcur%NOTFOUND;

DBMS\_OUTPUT.PUT\_LINE(v\_empno || ' ' || v\_ename);

END LOOP;

CLOSE emp\_refcur;

END;

The following is the output when this procedure is executed.

EXEC emp\_by\_dept(20)

EMPNO ENAME

\----- -------

7369 SMITH

7566 JONES

7788 SCOTT

7876 ADAMS

7902 FORD

### Usage Restrictions

The following are restrictions on cursor variable usage.
 - Comparison operators cannot be used to test cursor variables for equality, inequality, null, or not null
 - Null cannot be assigned to a cursor variable
 - The value of a cursor variable cannot be stored in a database column
 - Static cursors and cursor variables are not interchangeable. For example, a static cursor cannot be used in an OPEN FOR statement.

In addition the following table shows the permitted parameter modes for a cursor variable used as a procedure or function parameter depending upon the operations on the cursor variable within the procedure or function.

Table 3‑4 Permitted Cursor Variable Parameter Modes

|           |     |        |     |
| --------- | --- | ------ | --- |
| Operation | IN  | IN OUT | OUT |
| OPEN      | No  | Yes    | No  |
| FETCH     | Yes | Yes    | No  |
| CLOSE     | Yes | Yes    | No  |

So for example, if a procedure performs all three operations, OPEN FOR, FETCH, and CLOSE on a cursor variable declared as the procedure’s formal parameter, then that parameter must be declared with IN OUT mode.

### Examples

The following examples demonstrate cursor variable usage.

#### Returning a REF CURSOR From a Function

In the following example the cursor variable is opened with a query that selects employees with a given job. Note that the cursor variable is specified in this function’s RETURN statement so the result set is made available to the caller of the function.

CREATE OR REPLACE FUNCTION emp\_by\_job (p\_job VARCHAR2)

RETURN SYS\_REFCURSOR

IS

emp\_refcur SYS\_REFCURSOR;

BEGIN

OPEN emp\_refcur FOR SELECT empno, ename FROM emp WHERE job = p\_job;

RETURN emp\_refcur;

END;

This function is invoked in the following anonymous block by assigning the function’s return value to a cursor variable declared in the anonymous block’s declaration section. The result set is fetched using this cursor variable and then it is closed.

DECLARE

v\_empno emp.empno%TYPE;

v\_ename emp.ename%TYPE;

v\_job emp.job%TYPE := 'SALESMAN';

v\_emp\_refcur SYS\_REFCURSOR;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('EMPLOYEES WITH JOB ' || v\_job);

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME');

DBMS\_OUTPUT.PUT\_LINE('----- -------');

v\_emp\_refcur := emp\_by\_job(v\_job);

LOOP

FETCH v\_emp\_refcur INTO v\_empno, v\_ename;

EXIT WHEN v\_emp\_refcur%NOTFOUND;

DBMS\_OUTPUT.PUT\_LINE(v\_empno || ' ' || v\_ename);

END LOOP;

CLOSE v\_emp\_refcur;

END;

The following is the output when the anonymous block is executed.

EMPLOYEES WITH JOB SALESMAN

EMPNO ENAME

\----- -------

7499 ALLEN

7521 WARD

7654 MARTIN

7844 TURNER

#### Modularizing Cursor Operations

The following example illustrates how the various operations on cursor variables can be modularized into separate programs.

The following procedure opens the given cursor variable with a SELECT command that retrieves all rows.

CREATE OR REPLACE PROCEDURE open\_all\_emp (

p\_emp\_refcur IN OUT SYS\_REFCURSOR

)

IS

BEGIN

OPEN p\_emp\_refcur FOR SELECT empno, ename FROM emp;

END;

This variation opens the given cursor variable with a SELECT command that retrieves all rows, but of a given department.

CREATE OR REPLACE PROCEDURE open\_emp\_by\_dept (

p\_emp\_refcur IN OUT SYS\_REFCURSOR,

p\_deptno emp.deptno%TYPE

)

IS

BEGIN

OPEN p\_emp\_refcur FOR SELECT empno, ename FROM emp

WHERE deptno = p\_deptno;

END;

This third variation opens the given cursor variable with a SELECT command that retrieves all rows, but from a different table. Also note that the function’s return value is the opened cursor variable.

CREATE OR REPLACE FUNCTION open\_dept (

p\_dept\_refcur IN OUT SYS\_REFCURSOR

) RETURN SYS\_REFCURSOR

IS

v\_dept\_refcur SYS\_REFCURSOR;

BEGIN

v\_dept\_refcur := p\_dept\_refcur;

OPEN v\_dept\_refcur FOR SELECT deptno, dname FROM dept;

RETURN v\_dept\_refcur;

END;

This procedure fetches and displays a cursor variable result set consisting of employee number and name.

CREATE OR REPLACE PROCEDURE fetch\_emp (

p\_emp\_refcur IN OUT SYS\_REFCURSOR

)

IS

v\_empno emp.empno%TYPE;

v\_ename emp.ename%TYPE;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME');

DBMS\_OUTPUT.PUT\_LINE('----- -------');

LOOP

FETCH p\_emp\_refcur INTO v\_empno, v\_ename;

EXIT WHEN p\_emp\_refcur%NOTFOUND;

DBMS\_OUTPUT.PUT\_LINE(v\_empno || ' ' || v\_ename);

END LOOP;

END;

This procedure fetches and displays a cursor variable result set consisting of department number and name.

CREATE OR REPLACE PROCEDURE fetch\_dept (

p\_dept\_refcur IN SYS\_REFCURSOR

)

IS

v\_deptno dept.deptno%TYPE;

v\_dname dept.dname%TYPE;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('DEPT DNAME');

DBMS\_OUTPUT.PUT\_LINE('---- ---------');

LOOP

FETCH p\_dept\_refcur INTO v\_deptno, v\_dname;

EXIT WHEN p\_dept\_refcur%NOTFOUND;

DBMS\_OUTPUT.PUT\_LINE(v\_deptno || ' ' || v\_dname);

END LOOP;

END;

This procedure closes the given cursor variable.

CREATE OR REPLACE PROCEDURE close\_refcur (

p\_refcur IN OUT SYS\_REFCURSOR

)

IS

BEGIN

CLOSE p\_refcur;

END;

The following anonymous block executes all the previously described programs.

DECLARE

gen\_refcur SYS\_REFCURSOR;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('ALL EMPLOYEES');

open\_all\_emp(gen\_refcur);

fetch\_emp(gen\_refcur);

DBMS\_OUTPUT.PUT\_LINE('\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*');

DBMS\_OUTPUT.PUT\_LINE('EMPLOYEES IN DEPT \#10');

open\_emp\_by\_dept(gen\_refcur, 10);

fetch\_emp(gen\_refcur);

DBMS\_OUTPUT.PUT\_LINE('\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*');

DBMS\_OUTPUT.PUT\_LINE('DEPARTMENTS');

fetch\_dept(open\_dept(gen\_refcur));

DBMS\_OUTPUT.PUT\_LINE('\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*');

close\_refcur(gen\_refcur);

END;

The following is the output from the anonymous block.

ALL EMPLOYEES

EMPNO ENAME

\----- -------

7369 SMITH

7499 ALLEN

7521 WARD

7566 JONES

7654 MARTIN

7698 BLAKE

7782 CLARK

7788 SCOTT

7839 KING

7844 TURNER

7876 ADAMS

7900 JAMES

7902 FORD

7934 MILLER

\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

EMPLOYEES IN DEPT \#10

EMPNO ENAME

\----- -------

7782 CLARK

7839 KING

7934 MILLER

\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

DEPARTMENTS

DEPT DNAME

\---- ---------

10 ACCOUNTING

20 RESEARCH

30 SALES

40 OPERATIONS

\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

### Dynamic Queries With REF CURSORs

Advanced Server also supports dynamic queries via the OPEN FOR USING statement. A string literal or string variable is supplied in the OPEN FOR USING statement to the SELECT command.

OPEN *name* FOR *dynamic\_string*

\[ USING *bind\_arg* \[, *bind\_arg\_2* \] ...\];

*name* is the identifier of a previously declared cursor variable. *dynamic\_string* is a string literal or string variable containing a SELECT command (without the terminating semi-colon). *bind\_arg*, *bind\_arg\_2*... are bind arguments that are used to pass variables to corresponding placeholders in the SELECT command when the cursor variable is opened. The placeholders are identifiers prefixed by a colon character.

The following is an example of a dynamic query using a string literal.

CREATE OR REPLACE PROCEDURE dept\_query

IS

emp\_refcur SYS\_REFCURSOR;

v\_empno emp.empno%TYPE;

v\_ename emp.ename%TYPE;

BEGIN

OPEN emp\_refcur FOR 'SELECT empno, ename FROM emp WHERE deptno = 30' ||

' AND sal \>= 1500';

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME');

DBMS\_OUTPUT.PUT\_LINE('----- -------');

LOOP

FETCH emp\_refcur INTO v\_empno, v\_ename;

EXIT WHEN emp\_refcur%NOTFOUND;

DBMS\_OUTPUT.PUT\_LINE(v\_empno || ' ' || v\_ename);

END LOOP;

CLOSE emp\_refcur;

END;

The following is the output when the procedure is executed.

EXEC dept\_query;

EMPNO ENAME

\----- -------

7499 ALLEN

7698 BLAKE

7844 TURNER

In the next example, the previous query is modified to use bind arguments to pass the query parameters.

CREATE OR REPLACE PROCEDURE dept\_query (

p\_deptno emp.deptno%TYPE,

p\_sal emp.sal%TYPE

)

IS

emp\_refcur SYS\_REFCURSOR;

v\_empno emp.empno%TYPE;

v\_ename emp.ename%TYPE;

BEGIN

OPEN emp\_refcur FOR 'SELECT empno, ename FROM emp WHERE deptno = :dept'

|| ' AND sal \>= :sal' USING p\_deptno, p\_sal;

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME');

DBMS\_OUTPUT.PUT\_LINE('----- -------');

LOOP

FETCH emp\_refcur INTO v\_empno, v\_ename;

EXIT WHEN emp\_refcur%NOTFOUND;

DBMS\_OUTPUT.PUT\_LINE(v\_empno || ' ' || v\_ename);

END LOOP;

CLOSE emp\_refcur;

END;

The following is the resulting output.

EXEC dept\_query(30, 1500);

EMPNO ENAME

\----- -------

7499 ALLEN

7698 BLAKE

7844 TURNER

Finally, a string variable is used to pass the SELECT providing the most flexibility.

CREATE OR REPLACE PROCEDURE dept\_query (

p\_deptno emp.deptno%TYPE,

p\_sal emp.sal%TYPE

)

IS

emp\_refcur SYS\_REFCURSOR;

v\_empno emp.empno%TYPE;

v\_ename emp.ename%TYPE;

p\_query\_string VARCHAR2(100);

BEGIN

p\_query\_string := 'SELECT empno, ename FROM emp WHERE ' ||

'deptno = :dept AND sal \>= :sal';

OPEN emp\_refcur FOR p\_query\_string USING p\_deptno, p\_sal;

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME');

DBMS\_OUTPUT.PUT\_LINE('----- -------');

LOOP

FETCH emp\_refcur INTO v\_empno, v\_ename;

EXIT WHEN emp\_refcur%NOTFOUND;

DBMS\_OUTPUT.PUT\_LINE(v\_empno || ' ' || v\_ename);

END LOOP;

CLOSE emp\_refcur;

END;

EXEC dept\_query(20, 1500);

EMPNO ENAME

\----- -------

7566 JONES

7788 SCOTT

7902 FORD

## Collections

A *collection* is a set of ordered data items with the same data type. Generally, the data item is a scalar field, but may also be a user-defined type such as a record type or an object type as long as the structure and the data types that comprise each field of the user-defined type are the same for each element in the set. Each particular data item in the set is referenced by using subscript notation within a pair of parentheses.

**Note:** Multilevel collections (that is, where the data item of a collection is another collection) are not supported.

The most commonly known type of collection is an array. In Advanced Server, the supported collection types are *associative arrays* (formerly called *index-by-tables* in Oracle), *nested tables*, and *varrays*.

The general steps for using a collection are the following:
 - A collection of the desired type must be defined. This can be done in the declaration section of an SPL program, which results in a *local type* that is accessible only within that program. For nested table and varray types this can also be done using the CREATE TYPE command, which creates a persistent, *standalone type* that can be referenced by any SPL program in the database.
 - Variables of the collection type are declared. The collection associated with the declared variable is said to be *uninitialized* at this point if there is no value assignment made as part of the variable declaration.
 - Uninitialized collections of nested tables and varrays are null. A *null collection* does not yet exist. Generally, a COLLECTION\_IS\_NULL exception is thrown if a collection method is invoked on a null collection.
 - Uninitialized collections of associative arrays exist, but have no elements. An existing collection with no elements is called an *empty collection*.
 - To initialize a null collection, you must either make it an empty collection or assign a non-null value to it. Generally, a null collection is initialized by using its *constructor*.
 - To add elements to an empty associative array, you can simply assign values to its keys. For nested tables and varrays, generally its constructor is used to assign initial values to the nested table or varray. For nested tables and varrays, the EXTEND method is then used to grow the collection beyond its initial size established by the constructor.

The specific process for each collection type is described in the following sections.

### Associative Arrays

An *associative array* is a type of collection that associates a unique key with a value. The key does not have to be numeric, but can be character data as well.

An associative array has the following characteristics:
 - An *associative array type* must be defined after which *array variables* can be declared of that array type. Data manipulation occurs using the array variable.
 - When an array variable is declared, the associative array is created, but it is empty - just start assigning values to key values.
 - The key can be any negative integer, positive integer, or zero if INDEX BY BINARY\_INTEGER or PLS\_INTEGER is specified.
 - The key can be character data if INDEX BY VARCHAR2 is specified.
 - There is no pre-defined limit on the number of elements in the array - it grows dynamically as elements are added.
 - The array can be sparse - there may be gaps in the assignment of values to keys.
 - An attempt to reference an array element that has not been assigned a value will result in an exception.

The TYPE IS TABLE OF ... INDEX BY statement is used to define an associative array type.

TYPE *assoctype* IS TABLE OF { *datatype* | *rectype* | *objtype* }

INDEX BY { BINARY\_INTEGER | PLS\_INTEGER | VARCHAR2(*n*) };

*assoctype* is an identifier assigned to the array type. *datatype* is a scalar data type such as VARCHAR2 or NUMBER. *rectype* is a previously defined record type. *objtype* is a previously defined object type. *n* is the maximum length of a character key.

In order to make use of the array, a *variable* must be declared with that array type. The following is the syntax for declaring an array variable.

*array* *assoctype*

*array* is an identifier assigned to the associative array. *assoctype* is the identifier of a previously defined array type.

An element of the array is referenced using the following syntax.

*array*(*n*)\[.*field* \]

*array* is the identifier of a previously declared array. *n* is the key value, type-compatible with the data type given in the INDEX BY clause. If the array type of *array* is defined from a record type or object type, then \[.*field* \] must reference an individual field within the record type or attribute within the object type from which the array type is defined. Alternatively, the entire record can be referenced by omitting \[.*field* \].

The following example reads the first ten employee names from the emp table, stores them in an array, then displays the results from the array.

DECLARE

TYPE emp\_arr\_typ IS TABLE OF VARCHAR2(10) INDEX BY BINARY\_INTEGER;

emp\_arr emp\_arr\_typ;

CURSOR emp\_cur IS SELECT ename FROM emp WHERE ROWNUM \<= 10;

i INTEGER := 0;

BEGIN

FOR r\_emp IN emp\_cur LOOP

i := i + 1;

emp\_arr(i) := r\_emp.ename;

END LOOP;

FOR j IN 1..10 LOOP

DBMS\_OUTPUT.PUT\_LINE(emp\_arr(j));

END LOOP;

END;

The above example produces the following output:

SMITH

ALLEN

WARD

JONES

MARTIN

BLAKE

CLARK

SCOTT

KING

TURNER

The previous example is now modified to use a record type in the array definition.

DECLARE

TYPE emp\_rec\_typ IS RECORD (

empno NUMBER(4),

ename VARCHAR2(10)

);

TYPE emp\_arr\_typ IS TABLE OF emp\_rec\_typ INDEX BY BINARY\_INTEGER;

emp\_arr emp\_arr\_typ;

CURSOR emp\_cur IS SELECT empno, ename FROM emp WHERE ROWNUM \<= 10;

i INTEGER := 0;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME');

DBMS\_OUTPUT.PUT\_LINE('----- -------');

FOR r\_emp IN emp\_cur LOOP

i := i + 1;

emp\_arr(i).empno := r\_emp.empno;

emp\_arr(i).ename := r\_emp.ename;

END LOOP;

FOR j IN 1..10 LOOP

DBMS\_OUTPUT.PUT\_LINE(emp\_arr(j).empno || ' ' ||

emp\_arr(j).ename);

END LOOP;

END;

The following is the output from this anonymous block.

EMPNO ENAME

\----- -------

7369 SMITH

7499 ALLEN

7521 WARD

7566 JONES

7654 MARTIN

7698 BLAKE

7782 CLARK

7788 SCOTT

7839 KING

7844 TURNER

The emp%ROWTYPE attribute could be used to define emp\_arr\_typ instead of using the emp\_rec\_typ record type as shown in the following.

DECLARE

TYPE emp\_arr\_typ IS TABLE OF emp%ROWTYPE INDEX BY BINARY\_INTEGER;

emp\_arr emp\_arr\_typ;

CURSOR emp\_cur IS SELECT empno, ename FROM emp WHERE ROWNUM \<= 10;

i INTEGER := 0;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME');

DBMS\_OUTPUT.PUT\_LINE('----- -------');

FOR r\_emp IN emp\_cur LOOP

i := i + 1;

emp\_arr(i).empno := r\_emp.empno;

emp\_arr(i).ename := r\_emp.ename;

END LOOP;

FOR j IN 1..10 LOOP

DBMS\_OUTPUT.PUT\_LINE(emp\_arr(j).empno || ' ' ||

emp\_arr(j).ename);

END LOOP;

END;

The results are the same as in the prior example.

Instead of assigning each field of the record individually, a record level assignment can be made from r\_emp to emp\_arr.

DECLARE

TYPE emp\_rec\_typ IS RECORD (

empno NUMBER(4),

ename VARCHAR2(10)

);

TYPE emp\_arr\_typ IS TABLE OF emp\_rec\_typ INDEX BY BINARY\_INTEGER;

emp\_arr emp\_arr\_typ;

CURSOR emp\_cur IS SELECT empno, ename FROM emp WHERE ROWNUM \<= 10;

i INTEGER := 0;

BEGIN

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME');

DBMS\_OUTPUT.PUT\_LINE('----- -------');

FOR r\_emp IN emp\_cur LOOP

i := i + 1;

emp\_arr(i) := r\_emp;

END LOOP;

FOR j IN 1..10 LOOP

DBMS\_OUTPUT.PUT\_LINE(emp\_arr(j).empno || ' ' ||

emp\_arr(j).ename);

END LOOP;

END;

The key of an associative array can be character data as shown in the following example.

DECLARE

TYPE job\_arr\_typ IS TABLE OF NUMBER INDEX BY VARCHAR2(9);

job\_arr job\_arr\_typ;

BEGIN

job\_arr('ANALYST') := 100;

job\_arr('CLERK') := 200;

job\_arr('MANAGER') := 300;

job\_arr('SALESMAN') := 400;

job\_arr('PRESIDENT') := 500;

DBMS\_OUTPUT.PUT\_LINE('ANALYST : ' || job\_arr('ANALYST'));

DBMS\_OUTPUT.PUT\_LINE('CLERK : ' || job\_arr('CLERK'));

DBMS\_OUTPUT.PUT\_LINE('MANAGER : ' || job\_arr('MANAGER'));

DBMS\_OUTPUT.PUT\_LINE('SALESMAN : ' || job\_arr('SALESMAN'));

DBMS\_OUTPUT.PUT\_LINE('PRESIDENT: ' || job\_arr('PRESIDENT'));

END;

ANALYST : 100

CLERK : 200

MANAGER : 300

SALESMAN : 400

PRESIDENT: 500

### Nested Tables

A *nested table* is a type of collection that associates a positive integer with a value. A nested table has the following characteristics:
 - A *nested table type* must be defined after which *nested table variables* can be declared of that nested table type. Data manipulation occurs using the nested table variable, or simply, “table” for short.
 - When a nested table variable is declared, the nested table initially does not exist (it is a null collection). The null table must be initialized with a *constructor*. You can also initialize the table by using an assignment statement where the right-hand side of the assignment is an initialized table of the same type. **Note:** Initialization of a nested table is mandatory in Oracle, but optional in SPL.
 - The key is a positive integer.
 - The constructor establishes the number of elements in the table. The EXTEND method adds additional elements to the table. See Section <span class="underline">3.11</span> for information on collection methods. **Note:** Usage of the constructor to establish the number of elements in the table and usage of the EXTEND method to add additional elements to the table are mandatory in Oracle, but optional in SPL.
 - The table can be sparse - there may be gaps in the assignment of values to keys.
 - An attempt to reference a table element beyond its initialized or extended size will result in a SUBSCRIPT\_BEYOND\_COUNT exception.

The TYPE IS TABLE statement is used to define a nested table type within the declaration section of an SPL program.

TYPE *tbltype* IS TABLE OF { *datatype* | *rectype* | *objtype* };

*tbltype* is an identifier assigned to the nested table type. *datatype* is a scalar data type such as VARCHAR2 or NUMBER. *rectype* is a previously defined record type. *objtype* is a previously defined object type.

Note: You can use the CREATE TYPE command to define a nested table type that is available to all SPL programs in the database. See the Database Compatibility for Oracle Developers Reference Guide for more information about the CREATE TYPE command.

In order to make use of the table, a *variable* must be declared of that nested table type. The following is the syntax for declaring a table variable.

*table* *tbltype*

*table* is an identifier assigned to the nested table. *tbltype* is the identifier of a previously defined nested table type.

A nested table is initialized using the nested table type’s constructor.

*tbltype* (\[ { *expr1* | NULL } \[, { *expr2* | NULL } \] \[, ...\] \])

*tbltype* is the identifier of the nested table type’s constructor, which has the same name as the nested table type. *expr1*, *expr2*, … are expressions that are type-compatible with the element type of the table. If NULL is specified, the corresponding element is set to null. If the parameter list is empty, then an empty nested table is returned, which means there are no elements in the table. If the table is defined from an object type, then *exprn* must return an object of that object type. The object can be the return value of a function or the object type’s constructor, or the object can be an element of another nested table of the same type.

If a collection method other than EXISTS is applied to an uninitialized nested table, a COLLECTION\_IS\_NULL exception is thrown. See Section <span class="underline">3.11</span> for information on collection methods.

The following is an example of a constructor for a nested table:

DECLARE

TYPE nested\_typ IS TABLE OF CHAR(1);

v\_nested nested\_typ := nested\_typ('A','B');

An element of the table is referenced using the following syntax.

*table*(*n*)\[.*element* \]

*table* is the identifier of a previously declared table. *n* is a positive integer. If the table type of *table* is defined from a record type or object type, then \[.*element* \] must reference an individual field within the record type or attribute within the object type from which the nested table type is defined. Alternatively, the entire record or object can be referenced by omitting \[.*element* \].

The following is an example of a nested table where it is known that there will be four elements.

DECLARE

TYPE dname\_tbl\_typ IS TABLE OF VARCHAR2(14);

dname\_tbl dname\_tbl\_typ;

CURSOR dept\_cur IS SELECT dname FROM dept ORDER BY dname;

i INTEGER := 0;

BEGIN

dname\_tbl := dname\_tbl\_typ(NULL, NULL, NULL, NULL);

FOR r\_dept IN dept\_cur LOOP

i := i + 1;

dname\_tbl(i) := r\_dept.dname;

END LOOP;

DBMS\_OUTPUT.PUT\_LINE('DNAME');

DBMS\_OUTPUT.PUT\_LINE('----------');

FOR j IN 1..i LOOP

DBMS\_OUTPUT.PUT\_LINE(dname\_tbl(j));

END LOOP;

END;

The above example produces the following output:

DNAME

\----------

ACCOUNTING

OPERATIONS

RESEARCH

SALES

The following example reads the first ten employee names from the emp table, stores them in a nested table, then displays the results from the table. The SPL code is written to assume that the number of employees to be returned is not known beforehand.

DECLARE

TYPE emp\_rec\_typ IS RECORD (

empno NUMBER(4),

ename VARCHAR2(10)

);

TYPE emp\_tbl\_typ IS TABLE OF emp\_rec\_typ;

emp\_tbl emp\_tbl\_typ;

CURSOR emp\_cur IS SELECT empno, ename FROM emp WHERE ROWNUM \<= 10;

i INTEGER := 0;

BEGIN

emp\_tbl := emp\_tbl\_typ();

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME');

DBMS\_OUTPUT.PUT\_LINE('----- -------');

FOR r\_emp IN emp\_cur LOOP

i := i + 1;

emp\_tbl.EXTEND;

emp\_tbl(i) := r\_emp;

END LOOP;

FOR j IN 1..10 LOOP

DBMS\_OUTPUT.PUT\_LINE(emp\_tbl(j).empno || ' ' ||

emp\_tbl(j).ename);

END LOOP;

END;

Note the creation of an empty table with the constructor emp\_tbl\_typ() as the first statement in the executable section of the anonymous block. The EXTEND collection method is then used to add an element to the table for each employee returned from the result set. See Section <span class="underline">3.11.4</span> for information on EXTEND.

The following is the output.

EMPNO ENAME

\----- -------

7369 SMITH

7499 ALLEN

7521 WARD

7566 JONES

7654 MARTIN

7698 BLAKE

7782 CLARK

7788 SCOTT

7839 KING

7844 TURNER

The following example shows how a nested table of an object type can be used. First, an object type is created with attributes for the department name and location.

CREATE TYPE dept\_obj\_typ AS OBJECT (

dname VARCHAR2(14),

loc VARCHAR2(13)

);

The following anonymous block defines a nested table type whose element consists of the dept\_obj\_typ object type. A nested table variable is declared, initialized, and then populated from the dept table. Finally, the elements from the nested table are displayed.

DECLARE

TYPE dept\_tbl\_typ IS TABLE OF dept\_obj\_typ;

dept\_tbl dept\_tbl\_typ;

CURSOR dept\_cur IS SELECT dname, loc FROM dept ORDER BY dname;

i INTEGER := 0;

BEGIN

dept\_tbl := dept\_tbl\_typ(

dept\_obj\_typ(NULL,NULL),

dept\_obj\_typ(NULL,NULL),

dept\_obj\_typ(NULL,NULL),

dept\_obj\_typ(NULL,NULL)

);

FOR r\_dept IN dept\_cur LOOP

i := i + 1;

dept\_tbl(i).dname := r\_dept.dname;

dept\_tbl(i).loc := r\_dept.loc;

END LOOP;

DBMS\_OUTPUT.PUT\_LINE('DNAME LOC');

DBMS\_OUTPUT.PUT\_LINE('---------- ----------');

FOR j IN 1..i LOOP

DBMS\_OUTPUT.PUT\_LINE(RPAD(dept\_tbl(j).dname,14) || ' ' ||

dept\_tbl(j).loc);

END LOOP;

END;

**Note:** The parameters comprising the nested table’s constructor, dept\_tbl\_typ, are calls to the object type’s constructor dept\_obj\_typ.

The following is the output from the anonymous block.

DNAME LOC

\---------- ----------

ACCOUNTING NEW YORK

OPERATIONS BOSTON

RESEARCH DALLAS

SALES CHICAGO

### Varrays

A *varray* or *variable-size array* is a type of collection that associates a positive integer with a value. In many respects, it is similar to a nested table.

A varray has the following characteristics:
 - A *varray type* must be defined along with a maximum size limit. After the varray type is defined, *varray variables* can be declared of that varray type. Data manipulation occurs using the varray variable, or simply, “varray” for short. The number of elements in the varray cannot exceed the maximum size limit established in the varray type definition.
 - When a varray variable is declared, the varray initially does not exist (it is a null collection). The null varray must be initialized with a *constructor*. You can also initialize the varray by using an assignment statement where the right-hand side of the assignment is an initialized varray of the same type.
 - The key is a positive integer.
 - The constructor establishes the number of elements in the varray, which must not exceed the maximum size limit. The EXTEND method can add additional elements to the varray up to the maximum size limit. See Section <span class="underline">3.11</span> for information on collection methods.
 - Unlike a nested table, a varray cannot be sparse - there are no gaps in the assignment of values to keys.
 - An attempt to reference a varray element beyond its initialized or extended size, but within the maximum size limit will result in a SUBSCRIPT\_BEYOND\_COUNT exception.
 - An attempt to reference a varray element beyond the maximum size limit or extend a varray beyond the maximum size limit will result in a SUBSCRIPT\_OUTSIDE\_LIMIT exception.

The TYPE IS VARRAY statement is used to define a varray type within the declaration section of an SPL program.

TYPE *varraytype* IS { VARRAY | VARYING ARRAY }(*maxsize*)

OF { *datatype* | *objtype* };

*varraytype* is an identifier assigned to the varray type. *datatype* is a scalar data type such as VARCHAR2 or NUMBER. *maxsize* is the maximum number of elements permitted in varrays of that type. *objtype* is a previously defined object type.

Note: The CREATE TYPE command can be used to define a varray type that is available to all SPL programs in the database. In order to make use of the varray, a *variable* must be declared of that varray type. The following is the syntax for declaring a varray variable.

*varray* *varraytype*

*varray* is an identifier assigned to the varray. *varraytype* is the identifier of a previously defined varray type.

A varray is initialized using the varray type’s constructor.

*varraytype* (\[ { *expr1* | NULL } \[, { *expr2* | NULL } \]

\[, ...\] \])

*varraytype* is the identifier of the varray type’s constructor, which has the same name as the varray type. *expr1*, *expr2*, … are expressions that are type-compatible with the element type of the varray. If NULL is specified, the corresponding element is set to null. If the parameter list is empty, then an empty varray is returned, which means there are no elements in the varray. If the varray is defined from an object type, then *exprn* must return an object of that object type. The object can be the return value of a function or the return value of the object type’s constructor. The object can also be an element of another varray of the same varray type.

If a collection method other than EXISTS is applied to an uninitialized varray, a COLLECTION\_IS\_NULL exception is thrown. See Section <span class="underline">3.11</span> for information on collection methods.

The following is an example of a constructor for a varray:

DECLARE

TYPE varray\_typ IS VARRAY(2) OF CHAR(1);

v\_varray varray\_typ := varray\_typ('A','B');

An element of the varray is referenced using the following syntax.

*varray*(*n*)\[.*element* \]

*varray* is the identifier of a previously declared varray. *n* is a positive integer. If the varray type of *varray* is defined from an object type, then \[.*element* \] must reference an attribute within the object type from which the varray type is defined. Alternatively, the entire object can be referenced by omitting \[.*element* \].

The following is an example of a varray where it is known that there will be four elements.

DECLARE

TYPE dname\_varray\_typ IS VARRAY(4) OF VARCHAR2(14);

dname\_varray dname\_varray\_typ;

CURSOR dept\_cur IS SELECT dname FROM dept ORDER BY dname;

i INTEGER := 0;

BEGIN

dname\_varray := dname\_varray\_typ(NULL, NULL, NULL, NULL);

FOR r\_dept IN dept\_cur LOOP

i := i + 1;

dname\_varray(i) := r\_dept.dname;

END LOOP;

DBMS\_OUTPUT.PUT\_LINE('DNAME');

DBMS\_OUTPUT.PUT\_LINE('----------');

FOR j IN 1..i LOOP

DBMS\_OUTPUT.PUT\_LINE(dname\_varray(j));

END LOOP;

END;

The above example produces the following output:

DNAME

\----------

ACCOUNTING

OPERATIONS

RESEARCH

SALES

## Collection Methods

*Collection methods* are functions and procedures that provide useful information about a collection that can aid in the processing of data in the collection. The following sections discuss the collection methods supported by Advanced Server.

### COUNT

COUNT is a method that returns the number of elements in a collection. The syntax for using COUNT is as follows:

*collection*.COUNT

*collection* is the name of a collection.

For a varray, COUNT always equals LAST.

The following example shows that an associative array can be sparsely populated (i.e., there are “gaps” in the sequence of assigned elements). COUNT includes only the elements that have been assigned a value.

DECLARE

TYPE sparse\_arr\_typ IS TABLE OF NUMBER INDEX BY BINARY\_INTEGER;

sparse\_arr sparse\_arr\_typ;

BEGIN

sparse\_arr(-100) := -100;

sparse\_arr(-10) := -10;

sparse\_arr(0) := 0;

sparse\_arr(10) := 10;

sparse\_arr(100) := 100;

DBMS\_OUTPUT.PUT\_LINE('COUNT: ' || sparse\_arr.COUNT);

END;

The following output shows that there are five populated elements included in COUNT.

COUNT: 5

### DELETE

The DELETE method deletes entries from a collection. You can call the DELETE method in three different ways.

Use the first form of the DELETE method to remove all entries from a collection:

> *collection*.DELETE

Use the second form of the DELETE method to remove the specified entry from a collection:

> *collection*.DELETE(*subscript*)

Use the third form of the DELETE method to remove the entries that are within the range specified by *first\_subscript* and *last\_subscript* (including the entries for the *first\_subscript* and the *last\_subscript*) from a collection.

> *collection*.DELETE(*first*\_*subscript*, *last*\_*subscript*)

If first\_subscript and last\_subscript refer to non-existent elements, elements that are in the range between the specified subscripts are deleted. If first\_subscript is greater than last\_subscript, or if you specify a value of NULL for one of the arguments, DELETE has no effect.

Note that when you delete an entry, the subscript remains in the collection; you can re-use the subscript with an alternate entry. If you specify a subscript that does not exist in the call to the DELETE method, DELETE does not raise an exception.

The following example demonstrates using the DELETE method to remove the element with subscript 0 from the collection:

DECLARE

TYPE sparse\_arr\_typ IS TABLE OF NUMBER INDEX BY BINARY\_INTEGER;

sparse\_arr sparse\_arr\_typ;

v\_results VARCHAR2(50);

v\_sub NUMBER;

BEGIN

sparse\_arr(-100) := -100;

sparse\_arr(-10) := -10;

sparse\_arr(0) := 0;

sparse\_arr(10) := 10;

sparse\_arr(100) := 100;

DBMS\_OUTPUT.PUT\_LINE('COUNT: ' || sparse\_arr.COUNT);

sparse\_arr.DELETE(0);

DBMS\_OUTPUT.PUT\_LINE('COUNT: ' || sparse\_arr.COUNT);

v\_sub := sparse\_arr.FIRST;

WHILE v\_sub IS NOT NULL LOOP

IF sparse\_arr(v\_sub) IS NULL THEN

v\_results := v\_results || 'NULL ';

ELSE

v\_results := v\_results || sparse\_arr(v\_sub) || ' ';

END IF;

v\_sub := sparse\_arr.NEXT(v\_sub);

END LOOP;

DBMS\_OUTPUT.PUT\_LINE('Results: ' || v\_results);

END;

COUNT: 5

COUNT: 4

Results: -100 -10 10 100

COUNT indicates that before the DELETE method, there were 5 elements in the collection; after the DELETE method was invoked, the collection contains 4 elements.

### EXISTS

The EXISTS method verifies that a subscript exists within a collection. EXISTS returns TRUE if the subscript exists; if the subscript does not exist, EXISTS returns FALSE. The method takes a single argument; the subscript that you are testing for. The syntax is:

> *collection*.EXISTS(*subscript*)

*collection* is the name of the collection.

*subscript* is the value that you are testing for. If you specify a value of NULL, EXISTS returns false.

The following example verifies that subscript number 10 exists within the associative array:

DECLARE

TYPE sparse\_arr\_typ IS TABLE OF NUMBER INDEX BY BINARY\_INTEGER;

sparse\_arr sparse\_arr\_typ;

BEGIN

sparse\_arr(-100) := -100;

sparse\_arr(-10) := -10;

sparse\_arr(0) := 0;

sparse\_arr(10) := 10;

sparse\_arr(100) := 100;

DBMS\_OUTPUT.PUT\_LINE('The index exists: ' ||

CASE WHEN sparse\_arr.exists(10) = TRUE THEN 'true' ELSE 'false' END);

END;

The index exists: true

Some collection methods raise an exception if you call them with a subscript that does not exist within the specified collection. Rather than raising an error, the EXISTS method returns a value of FALSE.

### EXTEND

The EXTEND method increases the size of a collection. There are three variations of the EXTEND method. The first variation appends a single NULL element to a collection; the syntax for the first variation is:

> *collection*.EXTEND

*collection* is the name of a collection.

The following example demonstrates using the EXTEND method to append a single, null element to a collection:

DECLARE

TYPE sparse\_arr\_typ IS TABLE OF NUMBER;

sparse\_arr sparse\_arr\_typ := sparse\_arr\_typ(-100,-10,0,10,100);

v\_results VARCHAR2(50);

BEGIN

DBMS\_OUTPUT.PUT\_LINE('COUNT: ' || sparse\_arr.COUNT);

sparse\_arr.EXTEND;

DBMS\_OUTPUT.PUT\_LINE('COUNT: ' || sparse\_arr.COUNT);

FOR i IN sparse\_arr.FIRST .. sparse\_arr.LAST LOOP

IF sparse\_arr(i) IS NULL THEN

v\_results := v\_results || 'NULL ';

ELSE

v\_results := v\_results || sparse\_arr(i) || ' ';

END IF;

END LOOP;

DBMS\_OUTPUT.PUT\_LINE('Results: ' || v\_results);

END;

COUNT: 5

COUNT: 6

Results: -100 -10 0 10 100 NULL

COUNT indicates that before the EXTEND method, there were 5 elements in the collection; after the EXTEND method was invoked, the collection contains 6 elements.

The second variation of the EXTEND method appends a specified number of elements to the end of a collection.

> *collection*.EXTEND(*count*)

*collection* is the name of a collection.

*count* is the number of null elements added to the end of the collection.

The following example demonstrates using the EXTEND method to append multiple null elements to a collection:

DECLARE

TYPE sparse\_arr\_typ IS TABLE OF NUMBER;

sparse\_arr sparse\_arr\_typ := sparse\_arr\_typ(-100,-10,0,10,100);

v\_results VARCHAR2(50);

BEGIN

DBMS\_OUTPUT.PUT\_LINE('COUNT: ' || sparse\_arr.COUNT);

sparse\_arr.EXTEND(3);

DBMS\_OUTPUT.PUT\_LINE('COUNT: ' || sparse\_arr.COUNT);

FOR i IN sparse\_arr.FIRST .. sparse\_arr.LAST LOOP

IF sparse\_arr(i) IS NULL THEN

v\_results := v\_results || 'NULL ';

ELSE

v\_results := v\_results || sparse\_arr(i) || ' ';

END IF;

END LOOP;

DBMS\_OUTPUT.PUT\_LINE('Results: ' || v\_results);

END;

COUNT: 5

COUNT: 8

Results: -100 -10 0 10 100 NULL NULL NULL

COUNT indicates that before the EXTEND method, there were 5 elements in the collection; after the EXTEND method was invoked, the collection contains 8 elements.

The third variation of the EXTEND method appends a specified number of copies of a particular element to the end of a collection.

> *collection*.EXTEND(*count*, *index\_number*)

*collection* is the name of a collection.

*count* is the number of elements added to the end of the collection.

*index\_number* is the subscript of the element that is being copied to the collection.

The following example demonstrates using the EXTEND method to append multiple copies of the second element to the collection:

DECLARE

TYPE sparse\_arr\_typ IS TABLE OF NUMBER;

sparse\_arr sparse\_arr\_typ := sparse\_arr\_typ(-100,-10,0,10,100);

v\_results VARCHAR2(50);

BEGIN

DBMS\_OUTPUT.PUT\_LINE('COUNT: ' || sparse\_arr.COUNT);

sparse\_arr.EXTEND(3, 2);

DBMS\_OUTPUT.PUT\_LINE('COUNT: ' || sparse\_arr.COUNT);

FOR i IN sparse\_arr.FIRST .. sparse\_arr.LAST LOOP

IF sparse\_arr(i) IS NULL THEN

v\_results := v\_results || 'NULL ';

ELSE

v\_results := v\_results || sparse\_arr(i) || ' ';

END IF;

END LOOP;

DBMS\_OUTPUT.PUT\_LINE('Results: ' || v\_results);

END;

COUNT: 5

COUNT: 8

Results: -100 -10 0 10 100 -10 -10 -10

COUNT indicates that before the EXTEND method, there were 5 elements in the collection; after the EXTEND method was invoked, the collection contains 8 elements.

**Note:** The EXTEND method cannot be used on a null or empty collection.

### FIRST

FIRST is a method that returns the subscript of the first element in a collection. The syntax for using FIRST is as follows:

*collection*.FIRST

*collection* is the name of a collection.

The following example displays the first element of the associative array.

DECLARE

TYPE sparse\_arr\_typ IS TABLE OF NUMBER INDEX BY BINARY\_INTEGER;

sparse\_arr sparse\_arr\_typ;

BEGIN

sparse\_arr(-100) := -100;

sparse\_arr(-10) := -10;

sparse\_arr(0) := 0;

sparse\_arr(10) := 10;

sparse\_arr(100) := 100;

DBMS\_OUTPUT.PUT\_LINE('FIRST element: ' || sparse\_arr(sparse\_arr.FIRST));

END;

FIRST element: -100

### LAST

LAST is a method that returns the subscript of the last element in a collection. The syntax for using LAST is as follows:

*collection*.LAST

*collection* is the name of a collection.

The following example displays the last element of the associative array.

DECLARE

TYPE sparse\_arr\_typ IS TABLE OF NUMBER INDEX BY BINARY\_INTEGER;

sparse\_arr sparse\_arr\_typ;

BEGIN

sparse\_arr(-100) := -100;

sparse\_arr(-10) := -10;

sparse\_arr(0) := 0;

sparse\_arr(10) := 10;

sparse\_arr(100) := 100;

DBMS\_OUTPUT.PUT\_LINE('LAST element: ' || sparse\_arr(sparse\_arr.LAST));

END;

LAST element: 100

### LIMIT

LIMIT is a method that returns the maximum number of elements permitted in a collection. LIMIT is applicable only to varrays. The syntax for using LIMIT is as follows:

*collection*.LIMIT

*collection* is the name of a collection.

For an initialized varray, LIMIT returns the maximum size limit determined by the varray type definition. If the varray is uninitialized (that is, it is a null varray), an exception is thrown.

For an associative array or an initialized nested table, LIMIT returns NULL. If the nested table is uninitialized (that is, it is a null nested table), an exception is thrown.

### NEXT

NEXT is a method that returns the subscript that follows a specified subscript. The method takes a single argument; the subscript that you are testing for.

*collection*.NEXT(*subscript*)

*collection* is the name of the collection.

If the specified subscript is less than the first subscript in the collection, the function returns the first subscript. If the subscript does not have a successor, NEXT returns NULL. If you specify a NULL subscript, PRIOR does not return a value.

The following example demonstrates using NEXT to return the subscript that follows subscript 10 in the associative array, sparse\_arr:

DECLARE

TYPE sparse\_arr\_typ IS TABLE OF NUMBER INDEX BY BINARY\_INTEGER;

sparse\_arr sparse\_arr\_typ;

BEGIN

sparse\_arr(-100) := -100;

sparse\_arr(-10) := -10;

sparse\_arr(0) := 0;

sparse\_arr(10) := 10;

sparse\_arr(100) := 100;

DBMS\_OUTPUT.PUT\_LINE('NEXT element: ' || sparse\_arr.next(10));

END;

NEXT element: 100

### PRIOR

The PRIOR method returns the subscript that precedes a specified subscript in a collection. The method takes a single argument; the subscript that you are testing for. The syntax is:

> *collection*.PRIOR(*subscript*)

*collection* is the name of the collection.

If the subscript specified does not have a predecessor, PRIOR returns NULL. If the specified subscript is greater than the last subscript in the collection, the method returns the last subscript. If you specify a NULL subscript, PRIOR does not return a value.

The following example returns the subscript that precedes subscript 100 in the associative array, sparse\_arr:

DECLARE

TYPE sparse\_arr\_typ IS TABLE OF NUMBER INDEX BY BINARY\_INTEGER;

sparse\_arr sparse\_arr\_typ;

BEGIN

sparse\_arr(-100) := -100;

sparse\_arr(-10) := -10;

sparse\_arr(0) := 0;

sparse\_arr(10) := 10;

sparse\_arr(100) := 100;

DBMS\_OUTPUT.PUT\_LINE('PRIOR element: ' || sparse\_arr.prior(100));

END;

PRIOR element: 10

### TRIM

The TRIM method removes an element or elements from the end of a collection. The syntax for the TRIM method is:

> *collection*.TRIM\[(*count*)\]

*collection* is the name of a collection.

*count* is the number of elements removed from the end of the collection. Advanced Server will return an error if *count* is less than 0 or greater than the number of elements in the collection.

The following example demonstrates using the TRIM method to remove an element from the end of a collection:

DECLARE

TYPE sparse\_arr\_typ IS TABLE OF NUMBER;

sparse\_arr sparse\_arr\_typ := sparse\_arr\_typ(-100,-10,0,10,100);

BEGIN

DBMS\_OUTPUT.PUT\_LINE('COUNT: ' || sparse\_arr.COUNT);

sparse\_arr.TRIM;

DBMS\_OUTPUT.PUT\_LINE('COUNT: ' || sparse\_arr.COUNT);

END;

COUNT: 5

COUNT: 4

COUNT indicates that before the TRIM method, there were 5 elements in the collection; after the TRIM method was invoked, the collection contains 4 elements.

You can also specify the number of elements to remove from the end of the collection with the TRIM method:

DECLARE

TYPE sparse\_arr\_typ IS TABLE OF NUMBER;

sparse\_arr sparse\_arr\_typ := sparse\_arr\_typ(-100,-10,0,10,100);

v\_results VARCHAR2(50);

BEGIN

DBMS\_OUTPUT.PUT\_LINE('COUNT: ' || sparse\_arr.COUNT);

sparse\_arr.TRIM(2);

DBMS\_OUTPUT.PUT\_LINE('COUNT: ' || sparse\_arr.COUNT);

FOR i IN sparse\_arr.FIRST .. sparse\_arr.LAST LOOP

IF sparse\_arr(i) IS NULL THEN

v\_results := v\_results || 'NULL ';

ELSE

v\_results := v\_results || sparse\_arr(i) || ' ';

END IF;

END LOOP;

DBMS\_OUTPUT.PUT\_LINE('Results: ' || v\_results);

END;

COUNT: 5

COUNT: 3

Results: -100 -10 0

COUNT indicates that before the TRIM method, there were 5 elements in the collection; after the TRIM method was invoked, the collection contains 3 elements.

## Working with Collections

Collection operators allow you to transform, query and manipulate the contents of a collection.

### TABLE()

Use the TABLE() function to transform the members of an array into a set of rows. The signature is:

> TABLE(*collection\_value*)

Where:

*collection\_value*

> *collection\_value* is an expression that evaluates to a value of collection type.

The TABLE() function expands the nested contents of a collection into a table format. You can use the TABLE() function anywhere you use a regular table expression.

The TABLE() function returns a SETOF ANYELEMENT (a set of values of any type). For example, if the argument passed to this function is an array of dates, TABLE() will return a SETOF dates. If the argument passed to this function is an array of paths, TABLE() will return a SETOF paths.

You can use the TABLE() function to expand the contents of a collection into table form:

postgres=\# SELECT \* FROM TABLE(monthly\_balance(445.00, 980.20, 552.00));

monthly\_balance

\----------------

445.00

980.20

552.00

(3 rows)

### Using the MULTISET UNION Operator

The MULTISET UNION operator combines two collections to form a third collection. The signature is:

> *coll\_1* MULTISET UNION \[ALL | DISTINCT\] *coll\_2*

*coll\_1* and *coll\_2* specify the names of the collections to combine.

Include the ALL keyword to specify that duplicate elements (elements that are present in both *coll\_1* and *coll\_2*) should be represented in the result, once for each time they are present in the original collections. This is the default behavior of MULTISET UNION.

Include the DISTINCT keyword to specify that duplicate elements should be included in the result only once.

The following example demonstrates using the MULTISET UNION operator to combine two collections (collection\_1 and collection\_2) into a third collection (collection\_3):

DECLARE

TYPE int\_arr\_typ IS TABLE OF NUMBER(2);

collection\_1 int\_arr\_typ;

collection\_2 int\_arr\_typ;

collection\_3 int\_arr\_typ;

v\_results VARCHAR2(50);

BEGIN

collection\_1 := int\_arr\_typ(10,20,30);

collection\_2 := int\_arr\_typ(30,40);

collection\_3 := collection\_1 MULTISET UNION ALL collection\_2;

DBMS\_OUTPUT.PUT\_LINE('COUNT: ' || collection\_3.COUNT);

FOR i IN collection\_3.FIRST .. collection\_3.LAST LOOP

IF collection\_3(i) IS NULL THEN

v\_results := v\_results || 'NULL ';

ELSE

v\_results := v\_results || collection\_3(i) || ' ';

END IF;

END LOOP;

DBMS\_OUTPUT.PUT\_LINE('Results: ' || v\_results);

END;

COUNT: 5

Results: 10 20 30 30 40

The resulting collection includes one entry for each element in collection\_1 and collection\_2. If the DISTINCT keyword is used, the results are the following:

DECLARE

TYPE int\_arr\_typ IS TABLE OF NUMBER(2);

collection\_1 int\_arr\_typ;

collection\_2 int\_arr\_typ;

collection\_3 int\_arr\_typ;

v\_results VARCHAR2(50);

BEGIN

collection\_1 := int\_arr\_typ(10,20,30);

collection\_2 := int\_arr\_typ(30,40);

collection\_3 := collection\_1 MULTISET UNION DISTINCT collection\_2;

DBMS\_OUTPUT.PUT\_LINE('COUNT: ' || collection\_3.COUNT);

FOR i IN collection\_3.FIRST .. collection\_3.LAST LOOP

IF collection\_3(i) IS NULL THEN

v\_results := v\_results || 'NULL ';

ELSE

v\_results := v\_results || collection\_3(i) || ' ';

END IF;

END LOOP;

DBMS\_OUTPUT.PUT\_LINE('Results: ' || v\_results);

END;

COUNT: 4

Results: 10 20 30 40

The resulting collection includes only those members with distinct values. Note in the following example that the MULTISET UNION DISTINCT operator also removes duplicate entries that are stored within the same collection:

DECLARE

TYPE int\_arr\_typ IS TABLE OF NUMBER(2);

collection\_1 int\_arr\_typ;

collection\_2 int\_arr\_typ;

collection\_3 int\_arr\_typ;

v\_results VARCHAR2(50);

BEGIN

collection\_1 := int\_arr\_typ(10,20,30,30);

collection\_2 := int\_arr\_typ(40,50);

collection\_3 := collection\_1 MULTISET UNION DISTINCT collection\_2;

DBMS\_OUTPUT.PUT\_LINE('COUNT: ' || collection\_3.COUNT);

FOR i IN collection\_3.FIRST .. collection\_3.LAST LOOP

IF collection\_3(i) IS NULL THEN

v\_results := v\_results || 'NULL ';

ELSE

v\_results := v\_results || collection\_3(i) || ' ';

END IF;

END LOOP;

DBMS\_OUTPUT.PUT\_LINE('Results: ' || v\_results);

END;

COUNT: 5

Results: 10 20 30 40 50

### Using the FORALL Statement

Collections can be used to more efficiently process DML commands by passing all the values to be used for repetitive execution of a DELETE, INSERT, or UPDATE command in one pass to the database server rather than re-iteratively invoking the DML command with new values. The DML command to be processed in such a manner is specified with the FORALL statement. In addition, one or more collections are given in the DML command where different values are to be substituted each time the command is executed.

FORALL *index* IN *lower\_bound* .. *upper\_bound*

{ *insert\_stmt* | *update\_stmt* | *delete\_stmt* };

*index* is the position in the collection given in the *insert\_stmt*, *update\_stmt*, or *delete\_stmt* DML command that iterates from the integer value given as *lower\_bound* up to and including *upper\_bound*.

**Note:** If an exception occurs during any iteration of the FORALL statement, all updates that occurred since the start of the execution of the FORALL statement are automatically rolled back. This behavior is not compatible with Oracle databases. Oracle allows explicit use of the COMMIT or ROLLBACK commands to control whether or not to commit or roll back updates that occurred prior to the exception.

The FORALL statement creates a loop – each iteration of the loop increments the *index* variable (you typically use the *index* within the loop to select a member of a collection). The number of iterations is controlled by the *lower\_bound .. upper\_bound* clause. The loop is executes once for each integer between the *lower\_bound* and *upper\_bound* (inclusive) and the index is incremented by one for each iteration. For example:

FORALL i IN 2 .. 5

Creates a loop that executes four times – in the first iteration, the index (i) is set to the value 2; in the second iteration, the index is set to the value 3, and so on. The loop executes for the value 5 and then terminates.

The following example creates a table (emp\_copy) that is an empty copy of the emp table. The example declares a type (emp\_tbl) that is an array where each element in the array is of composite type, composed of the column definitions used to create the table, emp. The example also creates an index on the emp\_tbl type.

t\_emp is an associative array, of type emp\_tbl. The SELECT statement uses the BULK COLLECT INTO command to populate the t\_emp array. After the t\_emp array is populated, the FORALL statement iterates through the values (i) in the t\_emp array index and inserts a row for each record into emp\_copy.

CREATE TABLE emp\_copy(LIKE emp);

DECLARE

TYPE emp\_tbl IS TABLE OF emp%ROWTYPE INDEX BY BINARY\_INTEGER;

t\_emp emp\_tbl;

BEGIN

  SELECT \* FROM emp BULK COLLECT INTO t\_emp;

 FORALL i IN t\_emp.FIRST .. t\_emp.LAST

    INSERT INTO emp\_copy VALUES t\_emp(i);

END;

The following example uses a FORALL statement to update the salary of three employees:

DECLARE

TYPE empno\_tbl IS TABLE OF emp.empno%TYPE INDEX BY BINARY\_INTEGER;

TYPE sal\_tbl IS TABLE OF emp.ename%TYPE INDEX BY BINARY\_INTEGER;

t\_empno EMPNO\_TBL;

t\_sal SAL\_TBL;

BEGIN

t\_empno(1) := 9001;

t\_sal(1) := 3350.00;

t\_empno(2) := 9002;

t\_sal(2) := 2000.00;

t\_empno(3) := 9003;

t\_sal(3) := 4100.00;

FORALL i IN t\_empno.FIRST..t\_empno.LAST

UPDATE emp SET sal = t\_sal(i) WHERE empno = t\_empno(i);

END;

SELECT \* FROM emp WHERE empno \> 9000;

empno | ename | job | mgr | hiredate | sal | comm | deptno

\-------+--------+---------+-----+----------+---------+------+--------

9001 | JONES | ANALYST | | | 3350.00 | | 40

9002 | LARSEN | CLERK | | | 2000.00 | | 40

9003 | WILSON | MANAGER | | | 4100.00 | | 40

(3 rows)

The following example deletes three employees in a FORALL statement:

DECLARE

TYPE empno\_tbl IS TABLE OF emp.empno%TYPE INDEX BY BINARY\_INTEGER;

t\_empno EMPNO\_TBL;

BEGIN

t\_empno(1) := 9001;

t\_empno(2) := 9002;

t\_empno(3) := 9003;

FORALL i IN t\_empno.FIRST..t\_empno.LAST

DELETE FROM emp WHERE empno = t\_empno(i);

END;

SELECT \* FROM emp WHERE empno \> 9000;

empno | ename | job | mgr | hiredate | sal | comm | deptno

\-------+-------+-----+-----+----------+-----+------+--------

(0 rows)

### Using the BULK COLLECT Clause

SQL commands that return a result set consisting of a large number of rows may not be operating as efficiently as possible due to the constant context switching that must occur between the database server and the client in order to transfer the entire result set. This inefficiency can be mitigated by using a collection to gather the entire result set in memory which the client can then access. The BULK COLLECT clause is used to specify the aggregation of the result set into a collection.

The BULK COLLECT clause can be used with the SELECT INTO, FETCH INTO and EXECUTE IMMEDIATE commands, and with the RETURNING INTO clause of the DELETE, INSERT, and UPDATE commands. Each of these is illustrated in the following sections.

#### SELECT BULK COLLECT

The BULK COLLECT clause can be used with the SELECT INTO statement as follows. (Refer to Section <span class="underline">3.4.3</span> for additional information on the SELECT INTO statement.)

SELECT *select\_expressions* BULK COLLECT INTO *collection*

\[, ...\] FROM ...;

If a single collection is specified, then *collection* may be a collection of a single field, or it may be a collection of a record type. If more than one collection is specified, then each *collection* must consist of a single field. *select\_expressions* must match in number, order, and type-compatibility all fields in the target collections.

The following example shows the use of the BULK COLLECT clause where the target collections are associative arrays consisting of a single field.

DECLARE

TYPE empno\_tbl IS TABLE OF emp.empno%TYPE INDEX BY BINARY\_INTEGER;

TYPE ename\_tbl IS TABLE OF emp.ename%TYPE INDEX BY BINARY\_INTEGER;

TYPE job\_tbl IS TABLE OF emp.job%TYPE INDEX BY BINARY\_INTEGER;

TYPE hiredate\_tbl IS TABLE OF emp.hiredate%TYPE INDEX BY BINARY\_INTEGER;

TYPE sal\_tbl IS TABLE OF emp.sal%TYPE INDEX BY BINARY\_INTEGER;

TYPE comm\_tbl IS TABLE OF emp.comm%TYPE INDEX BY BINARY\_INTEGER;

TYPE deptno\_tbl IS TABLE OF emp.deptno%TYPE INDEX BY BINARY\_INTEGER;

t\_empno EMPNO\_TBL;

t\_ename ENAME\_TBL;

t\_job JOB\_TBL;

t\_hiredate HIREDATE\_TBL;

t\_sal SAL\_TBL;

t\_comm COMM\_TBL;

t\_deptno DEPTNO\_TBL;

BEGIN

SELECT empno, ename, job, hiredate, sal, comm, deptno BULK COLLECT

INTO t\_empno, t\_ename, t\_job, t\_hiredate, t\_sal, t\_comm, t\_deptno

FROM emp;

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME JOB HIREDATE ' ||

'SAL ' || 'COMM DEPTNO');

DBMS\_OUTPUT.PUT\_LINE('----- ------- --------- --------- ' ||

'-------- ' || '-------- ------');

FOR i IN 1..t\_empno.COUNT LOOP

DBMS\_OUTPUT.PUT\_LINE(t\_empno(i) || ' ' ||

RPAD(t\_ename(i),8) || ' ' ||

RPAD(t\_job(i),10) || ' ' ||

TO\_CHAR(t\_hiredate(i),'DD-MON-YY') || ' ' ||

TO\_CHAR(t\_sal(i),'99,999.99') || ' ' ||

TO\_CHAR(NVL(t\_comm(i),0),'99,999.99') || ' ' ||

t\_deptno(i));

END LOOP;

END;

EMPNO ENAME JOB HIREDATE SAL COMM DEPTNO

\----- ------- --------- --------- -------- -------- ------

7369 SMITH CLERK 17-DEC-80 800.00 .00 20

7499 ALLEN SALESMAN 20-FEB-81 1,600.00 300.00 30

7521 WARD SALESMAN 22-FEB-81 1,250.00 500.00 30

7566 JONES MANAGER 02-APR-81 2,975.00 .00 20

7654 MARTIN SALESMAN 28-SEP-81 1,250.00 1,400.00 30

7698 BLAKE MANAGER 01-MAY-81 2,850.00 .00 30

7782 CLARK MANAGER 09-JUN-81 2,450.00 .00 10

7788 SCOTT ANALYST 19-APR-87 3,000.00 .00 20

7839 KING PRESIDENT 17-NOV-81 5,000.00 .00 10

7844 TURNER SALESMAN 08-SEP-81 1,500.00 .00 30

7876 ADAMS CLERK 23-MAY-87 1,100.00 .00 20

7900 JAMES CLERK 03-DEC-81 950.00 .00 30

7902 FORD ANALYST 03-DEC-81 3,000.00 .00 20

7934 MILLER CLERK 23-JAN-82 1,300.00 .00 10

The following example produces the same result, but uses an associative array on a record type defined with the %ROWTYPE attribute.

DECLARE

TYPE emp\_tbl IS TABLE OF emp%ROWTYPE INDEX BY BINARY\_INTEGER;

t\_emp EMP\_TBL;

BEGIN

SELECT \* BULK COLLECT INTO t\_emp FROM emp;

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME JOB HIREDATE ' ||

'SAL ' || 'COMM DEPTNO');

DBMS\_OUTPUT.PUT\_LINE('----- ------- --------- --------- ' ||

'-------- ' || '-------- ------');

FOR i IN 1..t\_emp.COUNT LOOP

DBMS\_OUTPUT.PUT\_LINE(t\_emp(i).empno || ' ' ||

RPAD(t\_emp(i).ename,8) || ' ' ||

RPAD(t\_emp(i).job,10) || ' ' ||

TO\_CHAR(t\_emp(i).hiredate,'DD-MON-YY') || ' ' ||

TO\_CHAR(t\_emp(i).sal,'99,999.99') || ' ' ||

TO\_CHAR(NVL(t\_emp(i).comm,0),'99,999.99') || ' ' ||

t\_emp(i).deptno);

END LOOP;

END;

EMPNO ENAME JOB HIREDATE SAL COMM DEPTNO

\----- ------- --------- --------- -------- -------- ------

7369 SMITH CLERK 17-DEC-80 800.00 .00 20

7499 ALLEN SALESMAN 20-FEB-81 1,600.00 300.00 30

7521 WARD SALESMAN 22-FEB-81 1,250.00 500.00 30

7566 JONES MANAGER 02-APR-81 2,975.00 .00 20

7654 MARTIN SALESMAN 28-SEP-81 1,250.00 1,400.00 30

7698 BLAKE MANAGER 01-MAY-81 2,850.00 .00 30

7782 CLARK MANAGER 09-JUN-81 2,450.00 .00 10

7788 SCOTT ANALYST 19-APR-87 3,000.00 .00 20

7839 KING PRESIDENT 17-NOV-81 5,000.00 .00 10

7844 TURNER SALESMAN 08-SEP-81 1,500.00 .00 30

7876 ADAMS CLERK 23-MAY-87 1,100.00 .00 20

7900 JAMES CLERK 03-DEC-81 950.00 .00 30

7902 FORD ANALYST 03-DEC-81 3,000.00 .00 20

7934 MILLER CLERK 23-JAN-82 1,300.00 .00 10

#### FETCH BULK COLLECT

The BULK COLLECT clause can be used with a FETCH statement. (See Section <span class="underline">3.8.3</span> for information on the FETCH statement.) Instead of returning a single row at a time from the result set, the FETCH BULK COLLECT will return all rows at once from the result set into the specified collection unless restricted by the LIMIT clause.

FETCH *name* BULK COLLECT INTO *collection* \[, ...\] \[ LIMIT *n* \];

If a single collection is specified, then *collection* may be a collection of a single field, or it may be a collection of a record type. If more than one collection is specified, then each *collection* must consist of a single field. The expressions in the SELECT list of the cursor identified by *name* must match in number, order, and type-compatibility all fields in the target collections. If LIMIT *n* is specified, the number of rows returned into the collection on each FETCH will not exceed *n*.

The following example uses the FETCH BULK COLLECT statement to retrieve rows into an associative array.

DECLARE

TYPE emp\_tbl IS TABLE OF emp%ROWTYPE INDEX BY BINARY\_INTEGER;

t\_emp EMP\_TBL;

CURSOR emp\_cur IS SELECT \* FROM emp;

BEGIN

OPEN emp\_cur;

FETCH emp\_cur BULK COLLECT INTO t\_emp;

CLOSE emp\_cur;

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME JOB HIREDATE ' ||

'SAL ' || 'COMM DEPTNO');

DBMS\_OUTPUT.PUT\_LINE('----- ------- --------- --------- ' ||

'-------- ' || '-------- ------');

FOR i IN 1..t\_emp.COUNT LOOP

DBMS\_OUTPUT.PUT\_LINE(t\_emp(i).empno || ' ' ||

RPAD(t\_emp(i).ename,8) || ' ' ||

RPAD(t\_emp(i).job,10) || ' ' ||

TO\_CHAR(t\_emp(i).hiredate,'DD-MON-YY') || ' ' ||

TO\_CHAR(t\_emp(i).sal,'99,999.99') || ' ' ||

TO\_CHAR(NVL(t\_emp(i).comm,0),'99,999.99') || ' ' ||

t\_emp(i).deptno);

END LOOP;

END;

EMPNO ENAME JOB HIREDATE SAL COMM DEPTNO

\----- ------- --------- --------- -------- -------- ------

7369 SMITH CLERK 17-DEC-80 800.00 .00 20

7499 ALLEN SALESMAN 20-FEB-81 1,600.00 300.00 30

7521 WARD SALESMAN 22-FEB-81 1,250.00 500.00 30

7566 JONES MANAGER 02-APR-81 2,975.00 .00 20

7654 MARTIN SALESMAN 28-SEP-81 1,250.00 1,400.00 30

7698 BLAKE MANAGER 01-MAY-81 2,850.00 .00 30

7782 CLARK MANAGER 09-JUN-81 2,450.00 .00 10

7788 SCOTT ANALYST 19-APR-87 3,000.00 .00 20

7839 KING PRESIDENT 17-NOV-81 5,000.00 .00 10

7844 TURNER SALESMAN 08-SEP-81 1,500.00 .00 30

7876 ADAMS CLERK 23-MAY-87 1,100.00 .00 20

7900 JAMES CLERK 03-DEC-81 950.00 .00 30

7902 FORD ANALYST 03-DEC-81 3,000.00 .00 20

7934 MILLER CLERK 23-JAN-82 1,300.00 .00 10

#### EXECUTE IMMEDIATE BULK COLLECT

The BULK COLLECT clause can be used with a EXECUTE IMMEDIATE statement to specify a collection to receive the returned rows.

EXECUTE IMMEDIATE '*sql\_expression;*'

BULK COLLECT INTO *collection* \[,...\]

\[USING {\[*bind*\_*type*\] *bind*\_*argument*} \[, ...\]}\];

*collection* specifies the name of a collection.

*bind\_type* specifies the parameter mode of the *bind\_argument*.
 - A *bind*\_*type* of IN specifies that the *bind*\_*argument* contains a value that is passed to the *sql*\_*expression*.
 - A *bind*\_*type* of OUT specifies that the *bind*\_*argument* receives a value from the *sql*\_*expression*.
 - A *bind*\_*type* of IN OUT specifies that the *bind\_argument* is passed to *sql\_expression*, and then stores the value returned by *sql*\_*expression*.

*bind\_argument* specifies a parameter that contains a value that is either passed to the *sql\_expression* (specified with a *bind\_type* of IN), or that receives a value from the *sql\_expression* (specified with a *bind\_type* of OUT), or both (specified with a *bind\_type* of IN OUT).

If a single collection is specified, then *collection* may be a collection of a single field, or a collection of a record type; if more than one collection is specified, each *collection* must consist of a single field.

#### RETURNING BULK COLLECT

The BULK COLLECT clause can be added to the RETURNING INTO clause of a DELETE, INSERT, or UPDATE command. (See Section <span class="underline">3.4.7</span> for information on the RETURNING INTO clause.)

{ *insert* | *update* | *delete* }

RETURNING { \* | *expr\_1* \[, *expr\_2* \] ...}

BULK COLLECT INTO *collection* \[, ...\];

*insert*, *update*, and *delete* are the INSERT, UPDATE, and DELETE commands as described in Sections <span class="underline">3.4.4</span>, <span class="underline">3.4.5</span>, and <span class="underline">3.4.6</span>, respectively. If a single collection is specified, then *collection* may be a collection of a single field, or it may be a collection of a record type. If more than one collection is specified, then each *collection* must consist of a single field. The expressions following the RETURNING keyword must match in number, order, and type-compatibility all fields in the target collections. If \* is specified, then all columns in the affected table are returned. (Note that the use of \* is an Advanced Server extension and is not compatible with Oracle databases.)

The clerkemp table created by copying the emp table is used in the remaining examples in this section as shown below.

CREATE TABLE clerkemp AS SELECT \* FROM emp WHERE job = 'CLERK';

SELECT \* FROM clerkemp;

empno | ename | job | mgr | hiredate | sal | comm | deptno

\-------+--------+-------+------+--------------------+---------+------+--------

7369 | SMITH | CLERK | 7902 | 17-DEC-80 00:00:00 | 800.00 | | 20

7876 | ADAMS | CLERK | 7788 | 23-MAY-87 00:00:00 | 1100.00 | | 20

7900 | JAMES | CLERK | 7698 | 03-DEC-81 00:00:00 | 950.00 | | 30

7934 | MILLER | CLERK | 7782 | 23-JAN-82 00:00:00 | 1300.00 | | 10

(4 rows)

The following example increases everyone’s salary by 1.5, stores the employees’ numbers, names, and new salaries in three associative arrays, and finally, displays the contents of these arrays.

DECLARE

TYPE empno\_tbl IS TABLE OF emp.empno%TYPE INDEX BY BINARY\_INTEGER;

TYPE ename\_tbl IS TABLE OF emp.ename%TYPE INDEX BY BINARY\_INTEGER;

TYPE sal\_tbl IS TABLE OF emp.sal%TYPE INDEX BY BINARY\_INTEGER;

t\_empno EMPNO\_TBL;

t\_ename ENAME\_TBL;

t\_sal SAL\_TBL;

BEGIN

UPDATE clerkemp SET sal = sal \* 1.5 RETURNING empno, ename, sal

BULK COLLECT INTO t\_empno, t\_ename, t\_sal;

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME SAL ');

DBMS\_OUTPUT.PUT\_LINE('----- ------- -------- ');

FOR i IN 1..t\_empno.COUNT LOOP

DBMS\_OUTPUT.PUT\_LINE(t\_empno(i) || ' ' || RPAD(t\_ename(i),8) ||

' ' || TO\_CHAR(t\_sal(i),'99,999.99'));

END LOOP;

END;

EMPNO ENAME SAL

\----- ------- --------

7369 SMITH 1,200.00

7876 ADAMS 1,650.00

7900 JAMES 1,425.00

7934 MILLER 1,950.00

The following example performs the same functionality as the previous example, but uses a single collection defined with a record type to store the employees’ numbers, names, and new salaries.

DECLARE

TYPE emp\_rec IS RECORD (

empno emp.empno%TYPE,

ename emp.ename%TYPE,

sal emp.sal%TYPE

);

TYPE emp\_tbl IS TABLE OF emp\_rec INDEX BY BINARY\_INTEGER;

t\_emp EMP\_TBL;

BEGIN

UPDATE clerkemp SET sal = sal \* 1.5 RETURNING empno, ename, sal

BULK COLLECT INTO t\_emp;

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME SAL ');

DBMS\_OUTPUT.PUT\_LINE('----- ------- -------- ');

FOR i IN 1..t\_emp.COUNT LOOP

DBMS\_OUTPUT.PUT\_LINE(t\_emp(i).empno || ' ' ||

RPAD(t\_emp(i).ename,8) || ' ' ||

TO\_CHAR(t\_emp(i).sal,'99,999.99'));

END LOOP;

END;

EMPNO ENAME SAL

\----- ------- --------

7369 SMITH 1,200.00

7876 ADAMS 1,650.00

7900 JAMES 1,425.00

7934 MILLER 1,950.00

The following example deletes all rows from the clerkemp table, and returns information on the deleted rows into an associative array, which is then displayed.

DECLARE

TYPE emp\_rec IS RECORD (

empno emp.empno%TYPE,

ename emp.ename%TYPE,

job emp.job%TYPE,

hiredate emp.hiredate%TYPE,

sal emp.sal%TYPE,

comm emp.comm%TYPE,

deptno emp.deptno%TYPE

);

TYPE emp\_tbl IS TABLE OF emp\_rec INDEX BY BINARY\_INTEGER;

r\_emp EMP\_TBL;

BEGIN

DELETE FROM clerkemp RETURNING empno, ename, job, hiredate, sal,

comm, deptno BULK COLLECT INTO r\_emp;

DBMS\_OUTPUT.PUT\_LINE('EMPNO ENAME JOB HIREDATE ' ||

'SAL ' || 'COMM DEPTNO');

DBMS\_OUTPUT.PUT\_LINE('----- ------- --------- --------- ' ||

'-------- ' || '-------- ------');

FOR i IN 1..r\_emp.COUNT LOOP

DBMS\_OUTPUT.PUT\_LINE(r\_emp(i).empno || ' ' ||

RPAD(r\_emp(i).ename,8) || ' ' ||

RPAD(r\_emp(i).job,10) || ' ' ||

TO\_CHAR(r\_emp(i).hiredate,'DD-MON-YY') || ' ' ||

TO\_CHAR(r\_emp(i).sal,'99,999.99') || ' ' ||

TO\_CHAR(NVL(r\_emp(i).comm,0),'99,999.99') || ' ' ||

r\_emp(i).deptno);

END LOOP;

END;

EMPNO ENAME JOB HIREDATE SAL COMM DEPTNO

\----- ------- --------- --------- -------- -------- ------

7369 SMITH CLERK 17-DEC-80 1,200.00 .00 20

7876 ADAMS CLERK 23-MAY-87 1,650.00 .00 20

7900 JAMES CLERK 03-DEC-81 1,425.00 .00 30

7934 MILLER CLERK 23-JAN-82 1,950.00 .00 10

## Errors and Messages

Use the DBMS\_OUTPUT.PUT\_LINE statement to report messages.

DBMS\_OUTPUT.PUT\_LINE ( *message* );

*message* is any expression evaluating to a string.

This example displays the message on the user’s output display:

DBMS\_OUTPUT.PUT\_LINE('My name is John');

The special variables SQLCODE and SQLERRM contain a numeric code and a text message, respectively, that describe the outcome of the last SQL command issued. If any other error occurs in the program such as division by zero, these variables contain information pertaining to the error.

