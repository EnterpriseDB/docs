---
title: Performance Analysis and Tuning
---


Advanced Server provides various tools for performance analysis and tuning. These features are described in this chapter.

## Dynatune

Advanced Server supports dynamic tuning of the database server to make the optimal usage of the system resources available on the host machine on which it is installed. The two parameters that control this functionality are located in the postgresql.conf file. These parameters are:
 - edb\_dynatune
 - edb\_dynatune\_profile

### edb\_dynatune

edb\_dynatune determines how much of the host system's resources are to be used by the database server based upon the host machine's total available resources and the intended usage of the host machine.

When Advanced Server is initially installed, the edb\_dynatune parameter is set in accordance with the selected usage of the host machine on which it was installed - i.e., development machine, mixed use machine, or dedicated server. For most purposes, there is no need for the database administrator to adjust the various configuration parameters in the postgresql.conf file in order to improve performance.

You can change the value of the edb\_dynatune parameter after the initial installation of Advanced Server by editing the postgresql.conf file. The postmaster must be restarted in order for the new configuration to take effect.

The edb\_dynatune parameter can be set to any integer value between 0 and 100, inclusive. A value of 0, turns off the dynamic tuning feature thereby leaving the database server resource usage totally under the control of the other configuration parameters in the postgresql.conf file.

A low non-zero, value (e.g., 1 - 33) dedicates the least amount of the host machine's resources to the database server. This setting would be used for a development machine where many other applications are being used.

A value in the range of 34 - 66 dedicates a moderate amount of resources to the database server. This setting might be used for a dedicated application server that may have a fixed number of other applications running on the same machine as Advanced Server.

The highest values (e.g., 67 - 100) dedicate most of the server's resources to the database server. This setting would be used for a host machine that is totally dedicated to running Advanced Server.

Once a value of edb\_dynatune is selected, database server performance can be further fine-tuned by adjusting the other configuration parameters in the postgresql.conf file. Any adjusted setting overrides the corresponding value chosen by edb\_dynatune. You can change the value of a parameter by un-commenting the configuration parameter, specifying the desired value, and restarting the database server.

### edb\_dynatune\_profile

The edb\_dynatune\_profile parameter is used to control tuning aspects based upon the expected workload profile on the database server. This parameter takes effect upon startup of the database server.

The possible values for edb\_dynatune\_profile are:

| Value     | Usage                                                                                             |
| --------- | ------------------------------------------------------------------------------------------------- |
| oltp      | Recommended when the database server is processing heavy online transaction processing workloads. |
| reporting | Recommended for database servers used for heavy data reporting.                                   |
| mixed     | Recommended for servers that provide a mix of transaction processing and data reporting.          |

## Infinite Cache

**Note:** Infinite Cache has been deprecated and may be removed in a future release. Please contact your EnterpriseDB Account Manager or [mailto:sales@enterprisedb.com](mailto:sales@enterprisedb.com) for more information.

Database performance is typically governed by two competing factors:
 - Memory access is fast; disk access is slow.
 - Memory space is scarce; disk space is abundant.

Advanced Server tries very hard to minimize disk I/O by keeping frequently used data in memory. When the first server process starts, it creates an in-memory data structure known as the *buffer cache*. The buffer cache is organized as a collection of 8K (8192 byte) pages: each page in the buffer cache corresponds to a page in some table or index. The buffer cache is shared between all processes servicing a given database.

When you select a row from a table, Advanced Server reads the page that contains the row into the shared buffer cache. If there isn't enough free space in the cache, Advanced Server *evicts* some other page from the cache. If Advanced Server evicts a page that has been modified, that data is written back out to disk; otherwise, it is simply discarded. Index pages are cached in the shared buffer cache as well.

Figure 1.1 demonstrates the flow of data in a typical Advanced Server session:

![::EDB graphics:IC1.jpg](./images/image31.jpeg)

Figure 1.1 – Data Flow

A client application sends a query to the Postgres server and the server searches the shared buffer cache for the required data. If the requested data is found in the cache, the server immediately sends the data back to the client. If not, the server reads the page that holds the data into the shared buffer cache, evicting one or more pages if necessary. If the server decides to evict a page that has been modified, that page is written to disk.

As you can see, a query will execute much faster if the required data is found in the shared buffer cache.

One way to improve performance is to increase the amount of memory that you can devote to the shared buffer cache. However, most computers impose a strict limit on the amount of RAM that you can install. To help circumvent this limit, Infinite Cache lets you utilize memory from other computers connected to your network.

With Infinite Cache properly configured, Advanced Server will dedicate a portion of the memory installed on each *cache server* as a secondary memory cache. When a client application sends a query to the server, the server first searches the shared buffer cache for the required data; if the requested data is not found in the cache, the server searches for the necessary page in one of the cache servers.

Figure 1.2 shows the flow of data in an Advanced Server session with Infinite Cache:

![::EDB graphics:IC2.jpg](./images/image32.jpeg)

Figure 1.2 – Data flow with Infinite Cache

When a client application sends a query to the server, the server searches the shared buffer cache for the required data. If the requested data is found in the cache, the server immediately sends the data back to the client. If not, the server sends a request for the page to a specific cache server; if the cache server holds a copy of the page it sends the data back to the server and the server copies the page into the shared buffer cache. If the required page is not found in the primary cache (the shared buffer cache) or in the secondary cache (the cloud of cache servers), Advanced Server must read the page from disk. Infinite Cache improves performance by utilizing RAM from other computers on your network in order to avoid reading frequently accessed data from disk.

**Updating the Cache Node Configuration**

You can add or remove cache servers without restarting the database server by adding or deleting cache nodes from the list defined in the edb\_icache\_servers configuration parameter. For more information about changing the configuration parameter, see Section <span class="underline">8.2.2.2</span>.

When you add one or more cache nodes, the server re-allocates the cache, dividing the cache evenly amongst the servers; each of the existing cache servers loses a percentage of the information that they have cached. You can calculate the percentage of the cache that remains valid with the following formula:

(*existing\_nodes* \* 100) / (*existing\_nodes* + *new\_nodes*)

For example, if an Advanced Server installation with three existing cache nodes adds an additional cache node, 75% of the existing cache remains valid after the reconfiguration.

If cache nodes are removed from a server, the data that has been stored on the remaining cache nodes is preserved. If one cache server is removed from a set of five cache servers, Advanced Server preserves the 80% of the distributed cache that is stored on the four remaining cache nodes.

When you change the cache server configuration (by adding or removing cache servers), the portion of the cache configuration that is preserved is not re-written unless the cache is completely re-warmed using the edb\_icache\_warm() function or edb\_icache\_warm utility. If you do not re-warm the cache servers, new cache servers will accrue cache data as queries are performed on the server.

**Infinite Cache Offers a Second Performance Advantage: Compression.**

Without Infinite Cache, Advanced Server will read each page from disk as an 8K chunk; when a page resides in the shared buffer cache, it consumes 8K of RAM. With Infinite Cache, Postgres can *compress* each page before sending it to a cache server. A compressed page can take significantly less room in the secondary cache, making more space available for other data and effectively increasing the size of the cache. A compressed page consumes less network bandwidth as well, decreasing the amount of time required to retrieve a page from the secondary cache.

The fact that Infinite Cache can compress each page may make it attractive to configure a secondary cache server on the same computer that runs your Postgres server. If, for example, your computer is configured with 6GB of RAM, you may want to allocate a smaller amount (say 1GB) for the primary cache (the shared buffer cache) and a larger amount (4GB) to the secondary cache (Infinite Cache), reserving 1GB for the operating system. Since the secondary cache resides on the same computer, there is very little overhead involved in moving data between the primary and secondary cache. All data stored in the Infinite Cache is compressed so the secondary cache can hold many more pages than would fit into the (uncompressed) shared buffer cache. If you had allocated 5GB to the shared buffer cache, the cache could hold no more than 65000 pages (approximately). By assigning 4GB of memory to Infinite Cache, the cache may be able to hold 130000 pages (at 2x compression), 195000 pages (at 3x compression) or more. The compression factor that you achieve is determined by the amount of redundancy in the data itself and the edb\_icache\_compression\_level parameter.

To use Infinite Cache, you must specify a list of one or more cache servers (computers on your network) and start the edb\_icache daemon on each of those servers.

Infinite Cache is supported on Linux, HPUX and Solaris systems only.

Please Note: Infinite Cache and the effective\_io\_concurrency parameter can potentially interfere with each other. You should disable asynchronous I/O requests (by setting the value of effective\_io\_concurrency to 0 in the postgresql.conf file) if you enable the Infinite Cache feature.

### Installing Infinite Cache

Advanced Server includes Infinite Cache functionality as part of a standard installation with either the graphical installer or the RPM installer. You can also optionally install only the Infinite Cache daemon on a supporting cache server.

For information about using the RPM packages to install Infinite Cache, please see the EDB Postgres Advanced Server Installation Guide available at:

<http://www.enterprisedb.com/products-services-training/products/documentation/enterpriseedition>

To use the graphical installer to install Advanced Server with Infinite Cache functionality, confirm that the box next to the Database Server option (located on the Setup: Select Components window, shown in Figure 8.3) is selected when running the installation wizard.

![select\_components](./images/image33.png)

*Figure 8.3: The Setup: Select Components window.*

The Database Server option installs the following Infinite Cache components:
 - The ppas-infinitecache service script.
 - The Infinite Cache configuration file (ppas-infinitecache).
 - A command line tool that allows you to pre-load the cache servers (edb-icache-warm).
 - The edb\_icache libraries (code libraries required by the edb-icache daemon).

The graphical installation wizard can selectively install only the Infinite Cache daemon on a cache server. To install the edb-icache daemon on a cache server, deploy the installation wizard on the machine hosting the cache; when the Setup: Select Components window opens, de-select all options except Infinite Cache (as shown in Figure 8.4).

![icone](./images/image34.png)

*Figure 8.4: Installing only the Infinite Cache Daemon.*

The Infinite Cache Daemon option installs the following:
 - The ppas-infinitecache service script.
 - The Infinite Cache configuration file (ppas-infinitecache).
 - A command line tool that allows you to pre-load the cache servers (edb-icache-warm).
 - The edb\_icache libraries (code libraries required by the edb-icache daemon).

### Configuring the Infinite Cache Server

Configuring Infinite Cache is a three-step process:
 - Specify Infinite Cache server settings in the Infinite Cache configuration file.
 - Modify the Advanced Server postgresql.conf file, enabling Infinite Cache, and specifying connection and compression settings.
 - Start the Infinite Cache service.

#### Modifying Infinite Cache Settings

The Infinite Cache configuration file is named ppas-infinitecache, and contains two parameters and their associated values:

PORT=11211

CACHESIZE=500

To modify a parameter, open the ppas-infinitecache file (located in the /opt/PostgresPlus/infinitecache/etc directory) with your editor of choice, and modify the parameter values:

PORT

> Use the PORT variable to specify the port where Infinite Cache will listen for connections from Advanced Server.

CACHESIZE

> Use the CACHESIZE variable to specify the size of the cache (in MB).

#### Enabling Infinite Cache

The postgresql.conf file includes three configuration parameters that control the behavior of Infinite Cache. The postgresql.conf file is read each time you start the Advanced Server database server. To modify a parameter, open the postgresql.conf file (located in the $PGDATA directory) with your editor of choice, and edit the section of the configuration file shown below:

\# - Infinite Cache

\#edb\_enable\_icache = off

\#edb\_icache\_servers = '' \#'host1:port1,host2,ip3:port3,ip4'

\#edb\_icache\_compression\_level = 6

Lines that begin with a pound sign (\#) are treated as comments; to enable a given parameter, remove the pound sign and specify a value for the parameter. When you've updated and saved the configuration file, restart the database server for the changes to take effect.

edb\_enable\_icache

> Use the edb\_enable\_icache parameter to enable or disable Infinite Cache. When edb\_enable\_icache is set to on, Infinite Cache is enabled; if the parameter is set to off, Infinite Cache is disabled.
>
> If you set edb\_enable\_icache to on, you must also specify a list of cache servers by setting the edb\_icache\_servers parameter (described in the next section).
>
> The default value of edb\_enable\_icache is off.

edb\_icache\_servers

> The edb\_icache\_servers parameter specifies a list of one or more servers with active edb-icache daemons. edb\_icache\_servers is a string value that takes the form of a comma-separated list of *hostname:port* pairs. You can specify each pair in any of the following forms:
 - > *hostname*
 - > *IP-address*
 - > *hostname:portnumber*
 - > *IP-address:portnumber*

> If you do not specify a port number, Infinite Cache assumes that the cache server is listening at port 11211. This configuration parameter will take effect only if edb\_enable\_icache is set to on. Use the edb\_icache\_servers parameter to specify a maximum of 128 cache nodes.

edb\_icache\_compression\_level

> The edb\_icache\_compression\_level parameter controls the compression level that is applied to each page before storing it in the distributed Infinite Cache. This parameter must be an integer in the range 0 to 9.
 - > A compression level of 0 disables compression; it uses no CPU time for compression, but requires more storage space and network resources to process.
 - > A compression level of 9 invokes the maximum amount of compression; it increases the load on the CPU, but less data flows across the network, so network demand is reduced. Each page takes less room on the Infinite Cache server, so memory requirements are reduced.
 - > A compression level of 5 or 6 is a reasonable compromise between the amount of compression received and the amount of CPU time invested.

> By default, edb\_icache\_compression\_level is set to 6.
>
> When Advanced Server reads data from disk, it typically reads the data in 8K increments. If edb\_icache\_compression\_level is set to 0, each time Advanced Server sends an 8K page to the Infinite Cache server that page is stored (uncompressed) in 8K of cache memory. If the edb\_icache\_compression\_level parameter is set to 9, Advanced Server applies the maximum compression possible before sending it to the Infinite Cache server, so a page that previously took 8K of cached memory might take 2K of cached memory. Exact compression numbers are difficult to predict, as they are dependent on the nature of the data on each page.
>
> The compression level must be set by the superuser and can be changed for the current session while the server is running. The following command disables the compression mechanism for the currently active session:

SET edb\_icache\_compression\_level = 0

The following example shows a typical collection of Infinite Cache settings:

edb\_enable\_icache = on

edb\_icache\_servers = 'localhost,192.168.2.1:11200,192.168.2.2'

edb\_icache\_compression\_level = 6

Please Note: Infinite Cache and the effective\_io\_concurrency parameter can potentially interfere with each other. You should disable asynchronous I/O requests (by setting the value of effective\_io\_concurrency to 0 in the postgresql.conf file) if you enable the Infinite Cache feature. By default, effective\_io\_concurrency is set to 1.

#### Controlling the Infinite Cache Server

**Linux**

On Linux, the Infinite Cache service script is named ppas-infinitecache. The service script resides in the /etc/init.d directory. You can control the Infinite Cache service, or check the status of the service with the following command:

> /etc/init.d/ppas-infinitecache *action*

Where *action* specifies:
 - start to start the service.
 - stop to stop the service
 - restart to stop and then start the service.
 - status to return the status of the service.

### Dynamically Modifying Infinite Cache Server Nodes

You can dynamically modify the Infinite Cache server nodes; to change the Infinite Cache server configuration, use the edb\_icache\_servers parameter in the postgresql.conf file to:
 - specify additional cache information to add a server/s.
 - delete server information to remove a server/s.
 - specify additional server information and delete existing server information to both add and delete servers during the same reload operation.

After updating the edb\_icache\_servers parameter in the postgresql.conf file, you must reload the configuration parameters for the changes to take effect.

To reload the configuration parameters, navigate through the Postgres Plus Advanced Server 9.4 menu to the Expert Configuration menu, and select the Reload Configuration option. If prompted, enter your password to reload the configuration parameters.

Alternatively, you can use the pg\_ctl reload command to update the server's configuration parameters at the command line:

> pg\_ctl reload -D *data*\_*directory*

Where *data*\_*directory* specifies the complete path to the data directory.

Please Note: If the server detects a problem with the value specified for the edb\_icache\_servers parameter during a server reload, it will ignore changes to the parameter and use the last valid parameter value. If you are performing a server restart, and the parameter contains an invalid value, the server will return an error.

### Controlling the edb-icache Daemons

edb-icache is a high-performance memory caching daemon that distributes and stores data in shared buffers. The server transparently interacts with edb-icache daemons to store and retrieve data.

Before starting the database server, the edb-icache daemons must be running on each server node. Log into each server and start the edb-icache server (on that host) by issuing the following command:

\# edb-icache -u enterprisedb -d -m 1024

Where:

\-u

> \-u specifies the user name

\-m

> \-m specifies the amount of memory to be used by edb-icache. The default is 64MB.

\-d

> \-d designates that the service should run in the background

To gracefully kill an edb-icache daemon (close any in-use files, flush buffers, and exit), execute the command:

> \# killall -TERM edb-icache

If the edb-icache daemon refuses to die, you may need to use the following command:

> \# killall -KILL edb-icache

#### Command Line Options

To view the command line options for the edb-icache daemon, use the following command from the edb\_Infinite Cache subdirectory, located in the Advanced Server installation directory:

\# edb-icache -h

The command line options are:

<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-p &lt;port_number&gt;</td>
<td>The TCP port number the Infinite Cache daemon is listening on. The default is 11211.</td>
</tr>
<tr class="even">
<td>-U &lt;UDP_number&gt;</td>
<td>The UDP port number the Infinite Cache daemon is listening on. The default is 0 (off).</td>
</tr>
<tr class="odd">
<td>-s &lt;pathname&gt;</td>
<td>The Unix socket pathname the Infinite Cache daemon is listening on. If included, the server limits access to the host on which the Infinite Cache daemon is running, and disables network support for Infinite Cache.</td>
</tr>
<tr class="even">
<td>-a &lt;mask&gt;</td>
<td>The access mask for the Unix socket, in octal form. The default value is 0700.</td>
</tr>
<tr class="odd">
<td>-l &lt;ip_addr&gt;</td>
<td>Specifies the IP address that the daemon is listening on. If an individual address is not specified, the default value is INDRR_ANY; all IP addresses assigned to the resource are available to the daemon.</td>
</tr>
<tr class="even">
<td>-d</td>
<td>Run as a daemon.</td>
</tr>
<tr class="odd">
<td>-r</td>
<td>Maximize core file limit.</td>
</tr>
<tr class="even">
<td>-u &lt;username&gt;</td>
<td>Assume the identity of the specified user (when run as root).</td>
</tr>
<tr class="odd">
<td>-m &lt;numeric&gt;</td>
<td>Max memory to use for items in megabytes. Default is 64 MB.</td>
</tr>
<tr class="even">
<td>-M</td>
<td>Return error on memory exhausted (rather than removing items).</td>
</tr>
<tr class="odd">
<td>-c &lt;numeric&gt;</td>
<td>Max simultaneous connections. Default is 1024.</td>
</tr>
<tr class="even">
<td>-k</td>
<td>Lock down all paged memory. Note that there is a limit on how much memory you may lock. Trying to allocate more than that would fail, so be sure you set the limit correctly for the user you started the daemon with (not for -u &lt;username&gt; user; under sh this is done with 'ulimit -S -l NUM_KB').</td>
</tr>
<tr class="odd">
<td>-v</td>
<td>Verbose (print errors/warnings while in event loop).</td>
</tr>
<tr class="even">
<td>-vv</td>
<td>Very verbose (include client commands and responses).</td>
</tr>
<tr class="odd">
<td>-vvv</td>
<td>Extremely verbose (also print internal state transitions).</td>
</tr>
<tr class="even">
<td>-h</td>
<td>Print the help text and exit.</td>
</tr>
<tr class="odd">
<td>-i</td>
<td>Print memcached and libevent licenses.</td>
</tr>
<tr class="even">
<td>-P &lt;file&gt;</td>
<td>Save PID in &lt;file&gt;, only used with -d option.</td>
</tr>
<tr class="odd">
<td>-f &lt;factor&gt;</td>
<td>Chunk size growth factor. Default value is 1.25.</td>
</tr>
<tr class="even">
<td>-n &lt;bytes&gt;</td>
<td>Minimum space allocated for key+value+flags. Default is 48.</td>
</tr>
<tr class="odd">
<td>-L</td>
<td>Use large memory pages (if available). Increasing the memory page size could reduce the number of transition look-aside buffer misses and improve the performance. To get large pages from the OS, Infinite Cache will allocate the total item-cache in one large chunk.</td>
</tr>
<tr class="even">
<td>-D &lt;char&gt;</td>
<td><p>Use &lt;char&gt; as the delimiter between key prefixes and IDs. This is used for per-prefix stats reporting. The default is":" (colon).</p>
<p>If this option is specified, stats collection is enabled automatically; if not, then it may be enabled by sending the stats detail on command to the server.</p></td>
</tr>
<tr class="odd">
<td>-t &lt;num&gt;</td>
<td>Specifies the number of threads to use. Default is 4.</td>
</tr>
<tr class="even">
<td>-R</td>
<td>Maximum number of requests per event; this parameter limits the number of requests process for a given connection to prevent starvation, default is 20.</td>
</tr>
<tr class="odd">
<td>-C</td>
<td>Disable use of CAS (check and set).</td>
</tr>
<tr class="even">
<td>-b</td>
<td>Specifies the backlog queue limit, default is 1024.</td>
</tr>
<tr class="odd">
<td>-B</td>
<td>Specifies the binding protocol. Possible values are ascii, binary or auto; default value is auto.</td>
</tr>
<tr class="even">
<td>-I</td>
<td>Override the size of each slab page. Specifies the max item size; default 1 MB, minimum size is 1 k, maximum is 128 MB).</td>
</tr>
</tbody>
</table>

#### edb-icache-tool

edb-icache-tool provides a command line interface that queries the edb-icache daemon to retrieve statistical information about a specific cache node. The syntax is:

edb-icache-tool \<*host*\[:*port*\]\> stats

*host* specifies the address of the host that you are querying.

*port* specifies the port that the daemon is listening on.

edb-icache-tool retrieves the statistics described in the following table:

| Statistic              | Description                                                                                                                             |
| ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| accepting\_conns       | Will this server accept new connection(s)? 1 if yes, otherwise 0.                                                                       |
| auth\_cmds             | Number of authentication commands handled by this server, success or failure.                                                           |
| auth\_errors           | Number of failed authentications.                                                                                                       |
| bytes                  | Total number of bytes in use.                                                                                                           |
| bytes\_read            | Total number of bytes received by this server (from the network).                                                                       |
| bytes\_written         | Total number of bytes sent by this server (to the network).                                                                             |
| cas\_badval            | Number of keys that have been compared and swapped by this server but the comparison (original) value did not match the supplied value. |
| cas\_hits              | Number of keys that have been compared and swapped by this server and found present.                                                    |
| cas\_misses            | Number of keys that have been compared and swapped by this server and not found.                                                        |
| cmd\_flush             | Cumulative number of flush requests sent to this server.                                                                                |
| cmd\_get               | Cumulative number of read requests sent to this server.                                                                                 |
| cmd\_set               | Cumulative number of write requests sent to this server.                                                                                |
| conn\_yields           | Number of times any connection yielded to another due to hitting the edb-icache -R limit.                                               |
| connection\_structures | Number of connection structures allocated by the server.                                                                                |
| curr\_connections      | Number of open connections.                                                                                                             |
| curr\_items            | Number of items currently stored by the server.                                                                                         |
| decr\_hits             | Number of decrement requests satisfied by this server.                                                                                  |
| decr\_misses           | Number of decrement requests not satisfied by this server.                                                                              |
| delete\_hits           | Number of delete requests satisfied by this server.                                                                                     |
| delete\_misses         | Number of delete requests not satisfied by this server.                                                                                 |
| evictions              | Number of valid items removed from cache to free memory for new items.                                                                  |
| get\_hits              | Number of read requests satisfied by this server.                                                                                       |
| get\_misses            | Number of read requests not satisfied by this server.                                                                                   |
| incr\_hits             | Number of increment requests satisfied by this server.                                                                                  |
| incr\_misses           | Number of increment requests not satisfied by this server.                                                                              |
| limit\_maxbytes        | Number of bytes allocated on this server for storage.                                                                                   |
| listen\_disabled\_num  | Cumulative number of times this server has hit its connection limit.                                                                    |
| pid                    | Process ID (on cache server).                                                                                                           |
| pointer\_size          | Default pointer size on host OS (usually 32 or 64).                                                                                     |
| reclaimed              | Number of times an entry was stored using memory from an expired entry.                                                                 |
| rusage\_user           | Accumulated user time for this process (seconds.microseconds).                                                                          |
| rusage\_system         | Accumulated system time for this process (seconds.microseconds).                                                                        |
| threads                | Number of worker threads requested.                                                                                                     |
| total\_time            | Number of seconds since this server's base date (usually midnight, January 1, 1970, UTC).                                               |
| total\_connections     | Total number of connections opened since the server started running.                                                                    |
| total\_items           | Total number of items stored by this server (cumulative).                                                                               |
| uptime                 | Amount of time that server has been active.                                                                                             |
| version                | edb-icache version.                                                                                                                     |

In the following example, edb-icache-tool retrieves statistical information about an Infinite Cache server located at the address, 192.168.23.85 and listening on port 11213:

\# edb-icache-tool 192.168.23.85:11213 stats

Field Value

accepting\_conns 1

auth\_cmds 0

auth\_errors 0

bytes 52901223

bytes\_read 188383848

bytes\_written 60510385

cas\_badval 0

cas\_hits 0

cas\_misses 0

cmd\_flush 1

cmd\_get 53139

cmd\_set 229120

conn\_yields 0

connection\_structures 34

curr\_connections 13

curr\_items 54953

decr\_hits 0

decr\_misses 0

delete\_hits 0

delete\_misses 0

evictions 0

get\_hits 52784

get\_misses 355

incr\_hits 0

incr\_misses 0

limit\_maxbytes 314572800

listen\_disabled\_num 0

pid 7226

pointer\_size 32

reclaimed 0

rusage\_system 10.676667

rusage\_user 3.068191

threads 4

time 1320919080

total\_connections 111

total\_items 229120

uptime 7649

version 1.4.5

### Warming the edb-icache Servers

When the server starts, the primary and secondary caches are empty. When Advanced Server processes a client request, the server reads the required data from disk and stores a copy in each cache. You can improve server performance by *warming* (or pre-loading) the data into the memory cache before a client asks for it.

There are two advantages to warming the cache. Advanced Server will find data in the cache the first time it is requested by a client application, instead of waiting for it to be read from disk. Also, manually warming the cache with the data that your applications are most likely to need saves time by avoiding future random disk reads. If you don't warm the cache at startup, Advanced Server performance may not reach full speed until the client applications happen to load commonly used data into the cache.

There are several ways to load pages to warm the Infinite Cache server nodes. You can:
 - Use the edb\_icache\_warm utility to warm the caches from the command line.
 - Use the edb\_icache\_warm() function from within edb-psql.
 - Use the edb\_icache\_warm() function via scripts to warm the cache.

While it is not necessary to re-warm the cache after making changes to an existing cache configuration, re-warming the cache can improve performance by bringing the new configuration of cache servers up-to-date.

#### The edb\_icache\_warm() Function

The edb\_icache\_warm() function comes in two variations; the first variation warms not only the table, but any indexes associated with the table. If you use the second variation, you must make additional calls to warm any associated indexes.

The first form of the edb\_icache\_warm() function warms the given table and any associated indexes into the cache. The signature is:

edb\_icache\_warm(table\_name)

You may specify table\_name as a table name, OID, or regclass value.

\# edb-psql edb -c "select edb\_icache\_warm('accounts')"

When you call the first form of edb\_icache\_warm(), Advanced Server reads each page in the given table, compresses the page (if configured to do so), and then sends the compressed data to an Infinite Cache server. edb\_icache\_warm() also reads, compresses, and caches each page in each index defined for the given table.

The second form of the edb\_icache\_warm() function warms the pages that contain the specified range of bytes into the cache. The signature of the second form is:

edb\_icache\_warm(table-spec, startbyte, endbyte):

You must make subsequent calls to specify indexes separately when using this form of the edb\_icache\_warm() function.

\# edb-psql edb -c "select edb\_icache\_warm('accounts', 1, 10000)"

The edb\_icache\_warm() function is typically called by a utility program (such as the edb\_icache\_warm utility) to spread the warming process among multiple processes that operate in parallel.

#### Using the edb\_icache\_warm Utility

You can use the edb\_icache\_warm command-line utility to load the cache servers with specified tables, allowing fast access to relevant data from the cache.

The syntax for edb\_icache\_warm is:

\# edb\_icache\_warm –d *database* –t *tablename*

The only required parameter is *tablename*. *tablename* can be specified with or without the -t option. All other parameters are optional; if omitted, default values are inferred from Advanced Server environment variables.

The options for edb\_icache\_warm are:

<table>
<thead>
<tr class="header">
<th>Option</th>
<th>Variable</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-h</td>
<td><em>Hostname</em></td>
<td><p>The name of the host running Advanced Server. Include this parameter if you are running Advanced Server on a remote host.</p>
<p>The default value is PGHOST.</p></td>
</tr>
<tr class="even">
<td>-p</td>
<td><em>Portname</em></td>
<td>Port in use by Advanced Server. Default value is PGPORT.</td>
</tr>
<tr class="odd">
<td>-j</td>
<td><em>process count</em></td>
<td>Number of (parallel) processes used to warm the cache. The default value is 1.</td>
</tr>
<tr class="even">
<td>-U</td>
<td><em>Username</em></td>
<td>The Advanced Server username. Unless specified, this defaults to PGUSER.</td>
</tr>
<tr class="odd">
<td>-d</td>
<td><em>Database</em></td>
<td>The name of database containing the tables to be warmed. Default value is PGDATABASE.</td>
</tr>
<tr class="even">
<td>-t</td>
<td><em>Tablename</em></td>
<td>Name of table to be warmed. The index for the table is also warmed. Required.</td>
</tr>
</tbody>
</table>

### Retrieving Statistics from Infinite Cache

#### Using edb\_icache\_stats()

You can view Infinite Cache statistics by using the edb\_icache\_stats() function at the edb-psql command line (or any other query tool). The edb\_icache\_stats() function returns a result set that reflects the state of an Infinite Cache node or nodes and the related usage statistics. The result set includes:

| Statistic                | Description                                                                              |
| ------------------------ | ---------------------------------------------------------------------------------------- |
| *hostname*               | Host name (or IP address) of server                                                      |
| *Port*                   | Port number at which edb-icache daemon is listening                                      |
| *State*                  | Health of this server                                                                    |
| *write\_failures*        | Number of write failures                                                                 |
| *Bytes*                  | Total number of bytes in use                                                             |
| *bytes\_read*            | Total number of bytes received by this server (from the network)                         |
| *bytes\_written*         | Total number of bytes sent by this server (to the network)                               |
| *cmd\_get*               | Cumulative number of read requests sent to this server                                   |
| *cmd\_set*               | Cumulative number of write requests sent to this server                                  |
| *connection\_structures* | Number of connection structures allocated by the server                                  |
| *curr\_connections*      | Number of open connections                                                               |
| *curr\_items*            | Number of items currently stored by the server                                           |
| *Evictions*              | Number of valid items removed from cache to free memory for new items                    |
| *get\_hits*              | Number of read requests satisfied by this server                                         |
| *get\_misses*            | Number of read requests not satisfied by this server                                     |
| *limit\_maxbytes*        | Number of bytes allocated on this server for storage                                     |
| *Pid*                    | Process ID (on cache server)                                                             |
| *pointer\_size*          | Default pointer size on host OS (usually 32 or 64)                                       |
| *rusage\_user*           | Accumulated user time for this process (seconds.microseconds)                            |
| *rusage\_system*         | Accumulated system time for this process (seconds.microseconds)                          |
| *Threads*                | Number of worker threads requested                                                       |
| *total\_time*            | Number of seconds since this server's base date (usually midnight, January 1, 1970, UTC) |
| *total\_connections*     | Total number of connections opened since the server started running                      |
| *total\_items*           | Total number of items stored by this server (cumulative)                                 |
| *Uptime*                 | Amount of time that server has been active                                               |
| *Version*                | edb-icache version                                                                       |

You can use SQL queries to view Infinite Cache statistics. To view the server status of all Infinite Cache nodes:

SELECT hostname, port, state FROM edb\_icache\_stats()

hostname | port | state

\---------------+-------+--------

192.168.23.85 | 11211 | UNHEALTHY

192.168.23.85 | 11212 | ACTIVE

(2 rows)

Use the following command to view complete statistics (shown here using edb-psql's expanded display mode, \\x) for a specified node:

SELECT \* FROM edb\_icache\_stats() WHERE hostname = '192.168.23.85:11211'

\-\[RECORD 1\]-----------+--------------

hostname | 192.168.23.85

port | 11211

state | ACTIVE

write\_failures | 0

bytes | 225029460

bytes\_read | 225728252

bytes\_written | 192806774

cmd\_get | 23313

cmd\_set | 27088

connection\_structures | 53

curr\_connections | 3

curr\_items | 27088

evictions | 0

get\_hits | 23266

get\_misses | 47

limit\_maxbytes | 805306368

pid | 4240

pointer\_size | 32

rusage\_user | 0.481926

rusage\_system | 1.583759

threads | 1

total\_time | 1242199782

total\_connections | 66

total\_items | 27088

uptime | 714

version | 1.2.6

#### edb\_icache\_server\_list

The edb\_icache\_server\_list view exposes information about the status and health of all Infinite Cache servers listed in the edb\_icache\_servers GUC. The edb\_icache\_server\_list view is created using the edb\_icache stats() API. The view exposes the following information for each server:

| Statistic         | Description                                           |
| ----------------- | ----------------------------------------------------- |
| *Hostname*        | Host name (or IP address) of server                   |
| *Port*            | Port number at which edb-icache daemon is listening   |
| *State*           | Health of this server                                 |
| *write\_failures* | Number of write failures                              |
| *total\_memory*   | Number of bytes allocated to the cache on this server |
| *memory\_used*    | Number of bytes currently used by the cache           |
| *memory\_free*    | Number of unused bytes remaining in the cache         |
| *hit\_ratio*      | Percentage of cache hits                              |

The state column will contain one of the following four values, reflecting the health of the given server:

| Server State   | Description                                                                                                                      |
| -------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| Active         | The server is known to be up and running.                                                                                        |
| Unhealthy      | An error occurred while interacting with the cache server. Postgres will attempt to re-establish the connection with the server. |
| Offline        | Postgres can no longer contact the given server.                                                                                 |
| Manual Offline | You have taken the server offline with the edb\_icache\_server\_enable() function.                                               |

Use the following SELECT statement to return the health of each node in the Infinite Cache server farm:

SELECT hostname, port, state FROM edb\_icache\_server\_list

hostname | port | state

\---------------+-------+-------

192.168.23.85 | 11211 | ACTIVE

192.168.23.85 | 11212 | ACTIVE

(2 rows)

Use the following command to view complete details about a specific Infinite Cache node (shown here using edb-psql's \\x expanded-view option):

SELECT \* FROM edb\_icache\_server\_list WHERE hostname = '192.168.23.85:11211'

\-\[RECORD 1\]-----------+--------------

hostname | 192.168.23.85

port | 11211

state | ACTIVE

write\_failures | 0

total\_memory | 805306368

memory\_used | 225029460

memory\_free | 580276908

hit\_ratio | 99.79

### Retrieving Table Statistics

Advanced Server provides six system views that contain statistical information on a per-table basis. The views are:
 - pg\_statio\_all\_tables
 - pg\_statio\_sys\_tables
 - pg\_statio\_user\_tables
 - pg\_statio\_all\_indexes
 - pg\_statio\_sys\_indexes
 - pg\_statio\_user\_indexes

You can use standard SQL queries to view and compare the information stored in the views. The views contain information that will allow you to observe the effectiveness of the Advanced Server buffer cache and the icache servers.

#### pg\_statio\_all\_tables

The pg\_statio\_all\_tables view contains one row for each table in the database. The view contains the following information:

| Column Name              | Description                                                 |
| ------------------------ | ----------------------------------------------------------- |
| relid                    | The OID of the table.                                       |
| schemaname               | The name of the schema that the table resides in.           |
| relname                  | The name of the table.                                      |
| heap\_blks\_read         | The number of heap blocks read.                             |
| heap\_blks\_hit          | The number of heap blocks hit.                              |
| heap\_blks\_icache\_hit  | The number of heap blocks found on an icache server.        |
| idx\_blks\_read          | The number of index blocks read.                            |
| idx\_blks\_hit           | The number of index blocks hit.                             |
| idx\_blks\_icache\_hit   | The number of index blocks found on an icache server.       |
| toast\_blks\_read        | The number of toast blocks read.                            |
| toast\_blks\_hit         | The number of toast blocks hit.                             |
| toast\_blks\_icache\_hit | The number of toast blocks found on an icache server.       |
| tidx\_blks\_read         | The number of index toast blocks read.                      |
| tidx\_blks\_hit          | The number of index toast blocks hit.                       |
| tidx\_blks\_icache\_hit  | The number of index toast blocks found on an icache server. |

You can execute a simple query to view performance statistics for a specific table:

SELECT \* FROM pg\_statio\_all\_tables WHERE relname=’jobhist’;

\-\[ RECORD 1 \]---------+---------

relid | 16402

schemaname | public

relname | jobhist

heap\_blks\_read | 1

heap\_blks\_hit | 51

heap\_blks\_icache\_hit | 0

idx\_blks\_read | 2

idx\_blks\_hit | 17

idx\_blks\_icache\_hit | 0

toast\_blks\_read |

toast\_blks\_hit |

toast\_blks\_icache\_hit |

tidx\_blks\_read |

tidx\_blks\_hit |

tidx\_blks\_icache\_hit |

Or, you can view the statistics by activity level. The following example displays the statistics for the ten tables that have the greatest heap\_blks\_icache\_hit activity:

SELECT \* FROM pg\_statio\_all\_tables ORDER BY heap\_blks\_icache\_hit DESC LIMIT 10;

relid schemaname relname

heap\_blks\_read heap\_blks\_hit heap\_blks\_icache\_hit

idx\_blks\_read idx\_blks\_hit idx\_blks\_icache\_hit

toast\_blks\_read toast\_blks\_hit toast\_blks\_icache\_hit

tidx\_blks\_read tidx\_blks\_hit tidx\_blks\_icache\_hit

\-----------------------------------------------------------------------------

16390 public pgbench\_accounts

264105 71150 81498

13171 282541 18053

1259 pg\_catalog pg\_class

22 2904 18

14 3449 11

1249 pg\_catalog pg\_attribute

49 1619 16

17 2841 13

1255 pg\_catalog pg\_proc

38 276 11

33 682 16

0 0 0

0 0 0

2619 pg\_catalog pg\_statistic

20 295 8

4 436 4

0 0 0

0 0 0

2617 pg\_catalog pg\_operator

20 293 8

19 791 10

2602 pg\_catalog pg\_amop

10 721 6

13 1154 13

2610 pg\_catalog pg\_index

10 633 6

8 719 8

1247 pg\_catalog pg\_type

17 235 5

12 433 4

2615 pg\_catalog pg\_namespace

4 260 4

6 330 4

0 0 0

0 0 0

(10 rows)

#### pg\_statio\_sys\_tables

The pg\_statio\_sys\_tables view contains one row for each table in a system-defined schema. The statistical information included in this view is the same as for pg\_statio\_all\_tables.

#### pg\_statio\_user\_tables

The pg\_statio\_user\_tables view contains one row for each table in a user-defined schema. The statistical information in this view is the same as for pg\_statio\_all\_tables.

#### pg\_statio\_all\_indexes

The pg\_statio\_all\_indexes view contains one row for each index in the current database. The view contains the following information:

| Column Name            | Description                                           |
| ---------------------- | ----------------------------------------------------- |
| relid                  | The OID of the indexed table                          |
| indexrelid             | The OID of the index.                                 |
| schemaname             | The name of the schema that the table resides in.     |
| relname                | The name of the table.                                |
| indexrelname           | The name of the index                                 |
| idx\_blks\_read        | The number of index blocks read.                      |
| idx\_blks\_hit         | The number of index blocks hit.                       |
| idx\_blks\_icache\_hit | The number of index blocks found on an icache server. |

You can execute a simple query to view performance statistics for the indexes on a specific table:

SELECT \* FROM pg\_statio\_all\_indexes WHERE relname=’pg\_attribute’;

\-\[ RECORD 1 \]---------+---------

relid | 1249

indexrelid | 2658

schemaname | pg\_catalog

relname | pg\_attribute

indexrelname | pg\_attribute\_relid\_attnam\_index

idx\_blks\_read | 10

idx\_blks\_hit | 1200

idx\_blks\_icache\_hit | 0

\-\[ RECORD 2 \]---------+---------

relid | 1249

indexrelid | 2659

schemaname | pg\_catalog

relname | pg\_attribute

indexrelname | pg\_attribute\_relid\_attnum\_index

idx\_blks\_read | 12

idx\_blks\_hit | 3917

idx\_blks\_icache\_hit | 0

The result set from the query includes the statistical information for two indexes; the pg\_attribute table has two indexes.

You can also view the statistics by activity level. The following example displays the statistics for the ten indexes that have the greatest idx\_blks\_icache\_hit activity:

SELECT \* FROM pg\_statio\_all\_indexes ORDER BY idx\_blks\_icache\_hit DESC LIMIT 10;

relid indexrelid schemaname relname

indexrelname idx\_blks\_read idx\_blks\_hit idx\_blks\_icache\_hit

\-----------------------------------------------------------------------------

16390 16401 public pgbench\_accounts

pgbench\_accounts\_pkey 13171 282541 18053

1249 2659 pg\_catalog pg\_attribute

pg\_attr\_relid\_attnum\_index 14 2749 13

1255 2690 pg\_catalog proc

pg\_proc\_oid\_index 16 580 12

1259 2663 pg\_catalog pg\_class

pg\_class\_relname\_nsp\_index 10 2019 7

2602 2654 pg\_catalog pg\_amop

pg\_amop\_opr\_fam\_index 7 453 7

2603 2655 pg\_catalog pg\_amproc

pg\_amproc\_fam\_proc\_index 6 605 6

2617 2688 pg\_catalog pg\_operator

pg\_operator\_oid\_index 7 452 6

2602 2653 pg\_catalog pg\_amop

pg\_amop\_fam\_strat\_index 6 701 6

2615 2684 pg\_catalog pg\_namespace pg\_namespace\_nspname\_index 4 328 4

1262 2672 pg\_catalog pg\_database pg\_database\_oid\_index 4 254 4

#### pg\_statio\_sys\_indexes

The pg\_statio\_sys\_indexes view contains one row for each index on the system tables. The statistical information in this view is the same as in pg\_statio\_all\_indexes.

#### pg\_statio\_user\_indexes

The pg\_statio\_user\_indexes view contains one row for each index on a table that resides in a user-defined schema. The statistical information in this view is the same as in pg\_statio\_all\_indexes.

### edb\_icache\_server\_enable()

You can use the edb\_icache\_server\_enable() function to take the Infinite Cache server offline for maintenance or other planned downtime. The syntax is:

void edb\_icache\_server\_enable(*host* TEXT, *port* INTEGER, *online* BOOL)

*host* specifies the host that you want to disable. The host name may be specified by name or numeric address.

*port* specifies the port number that the Infinite Cache server is listening on.

*online* specifies the state of the Infinite Cache server. The value of online must be true or false.

To take a server offline, specify the host that you want to disable, the port number that the Infinite Cache server is listening on, and false. To bring the Infinite Cache server back online, specify the host name and port number, and pass a value of true.

The state of a server taken offline with the edb\_icache\_server\_enable() function is MANUAL OFFLINE. Advanced Server will not automatically reconnect to an Infinite Cache server that you have taken offline with edb\_icache\_server\_enable(..., false); you must bring the server back online by calling edb\_icache\_server\_enable(..., true).

### Infinite Cache Log Entries

When you start Advanced Server, a message that includes Infinite Cache status, cache node count and cache node size is written to the server log. The following example shows the server log for an active Infinite Cache installation with two 750 MB cache servers:

\*\* EnterpriseDB Dynamic Tuning Agent\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

\* System Utilization: 66 % \*

\* Autovacuum Naptime: 60 Seconds \*

\* Infinite Cache: on \*

\* Infinite Cache Servers: 2 \*

\* Infinite Cache Size: 1.500 GB \*

\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

### Allocating Memory to the Cache Servers

As mentioned earlier in this document, each computer imposes a limit on the amount of *physical* memory that you can install. However, modern operating systems typically simulate a larger *address* space so that programs can transparently access more memory than is actually installed. This "virtual memory" allows a computer to run multiple programs that may simultaneously require more memory than is physically available. For example, you may run an e-mail client, a web browser, and a database server which each require 1GB of memory on a machine that contains only 2GB of physical RAM. When the operating system runs out of physical memory, it starts swapping bits and pieces of the currently running programs to disk to make room to satisfy your current demand for memory.

*This can bring your system to a grinding halt.*

Since the primary goal of Infinite Cache is to improve performance by limiting disk I/O, you should avoid dedicating so much memory to Infinite Cache that the operating system must start swapping data to disk. If the operating system begins to swap to disk, you lose the benefits offered by Infinite Cache.

The overall demand for physical memory can vary throughout the day; if the server is frequently idle, you may never encounter swapping. If you have dedicated a large portion of physical memory to the cache, and system usage increases, the operating system may start swapping. To get the best performance and avoid disk swapping, dedicate a server node to Infinite Cache so other applications on that computer will not compete for physical memory.

## Index Advisor

The Index Advisor utility helps determine which columns you should index to improve performance in a given workload. Index Advisor considers B-tree (single-column or composite) index types, and does not identify other index types (GIN, GiST, Hash) that may improve performance. Index Advisor is installed with EDB Postgres Advanced Server.

Index Advisor works with Advanced Server's query planner by creating *hypothetical* *indexes* that the query planner uses to calculate execution costs as if such indexes were available. Index Advisor identifies the indexes by analyzing SQL queries supplied in the workload.

There are three ways to use Index Advisor to analyze SQL queries:
 - Invoke the Index Advisor utility program, supplying a text file containing the SQL queries that you wish to analyze; Index Advisor will generate a text file with CREATE INDEX statements for the recommended indexes.
 - Provide queries at the EDB-PSQL command line that you want Index Advisor to analyze.
 - Access Index Advisor through the Postgres Enterprise Manager client. When accessed via the PEM client, Index Advisor works with SQL Profiler, providing indexing recommendations on code captured in SQL traces. For more information about using SQL Profiler and Index Advisor with PEM, please see Section 8.4 of the *PEM Getting Started Guide* available from the EnterpriseDB website at:

> <http://www.enterprisedb.com/products-services-training/products/postgres-enterprise-manager>

Index Advisor will attempt to make indexing recommendations on INSERT, UPDATE, DELETE and SELECT statements. When invoking Index Advisor, you supply the workload in the form of a set of queries (if you are providing the command in an SQL file) or an EXPLAIN statement (if you are specifying the SQL statement at the psql command line). Index Advisor displays the query plan and estimated execution cost for the supplied query, but does not actually execute the query.

During the analysis, Index Advisor compares the query execution costs with and without hypothetical indexes. If the execution cost using a hypothetical index is less than the execution cost without it, both plans are reported in the EXPLAIN statement output, metrics that quantify the improvement are calculated, and Index Advisor generates the CREATE INDEX statement needed to create the index.

If no hypothetical index can be found that reduces the execution cost, Index Advisor displays only the original query plan output of the EXPLAIN statement.

*Index Advisor does not actually create indexes on the tables. Use the CREATE INDEX statements supplied by Index Advisor to add any recommended indexes to your tables.*

A script supplied with Advanced Server creates the table in which Index Advisor stores the indexing recommendations generated by the analysis; the script also creates a function and a view of the table to simplify the retrieval and interpretation of the results.

If you choose to forego running the script, Index Advisor will log recommendations in a temporary table that is available only for the duration of the Index Advisor session.

### Index Advisor Components

The Index Advisor shared library interacts with the query planner to make indexing recommendations. The Advanced Server installer creates the following shared library in the libdir subdirectory of your Advanced Server home directory:

On Linux:

index\_advisor.so

On Windows:

index\_advisor.dll

Please note that libraries in the libdir directory can only be loaded by a superuser. A database administrator can allow a non-superuser to use Index Advisor by manually copying the Index Advisor file from the libdir directory into the libdir/plugins directory (under your Advanced Server home directory). Only a trusted non-superuser should be allowed access to the plugin; this is an unsafe practice in a production environment.

The installer also creates the Index Advisor utility program and setup script:

pg\_advise\_index

pg\_advise\_index is a utility program that reads a user-supplied input file containing SQL queries and produces a text file containing CREATE INDEX statements that can be used to create the indexes recommended by the Index Advisor. The pg\_advise\_index program is located in the bin subdirectory of the Advanced Server home directory.

index\_advisor.sql

index\_advisor.sql is a script that creates a permanent Index Advisor log table along with a function and view to facilitate reporting of recommendations from the log table. The script is located in the share/contrib subdirectory of the Advanced Server directory.

The index\_advisor.sql script creates the index\_advisor\_log table, the show\_index\_recommendations() function and the index\_recommendations view. These database objects must be created in a schema that is accessible by, and included in the search path of the role that will invoke Index Advisor.

index\_advisor\_log

Index Advisor logs indexing recommendations in the index\_advisor\_log table. If Index Advisor does not find the index\_advisor\_log table in the user's search path, Index Advisor will store any indexing recommendations in a temporary table of the same name. The temporary table exists only for the duration of the current session.

show\_index\_recommendations()

show\_index\_recommendations() is a PL/pgSQL function that interprets and displays the recommendations made during a specific Index Advisor session (as identified by its backend process ID).

index\_recommendations

Index Advisor creates the index\_recommendations view based on information stored in the index\_advisor\_log table during a query analysis. The view produces output in the same format as the show\_index\_recommendations() function, but contains Index Advisor recommendations for all stored sessions, while the result set returned by the show\_index\_recommendations() function are limited to a specified session.

### Index Advisor Configuration

Index Advisor does not require any configuration to generate recommendations that are available only for the duration of the current session; to store the results of multiple sessions, you must create the index\_advisor\_log table (where Advanced Server will store Index Advisor recommendations). To create the index\_advisor\_log table , you must run the index\_advisor.sql script.

When selecting a storage schema for the Index Advisor table, function and view, keep in mind that all users that invoke Index Advisor (and query the result set) must have USAGE privileges on the schema. The schema must be in the search path of all users that are interacting with the Index Advisor.

1.  Place the selected schema at the start of your search\_path parameter. For example, if your search path is currently:

> search\_path=public, accounting
>
> and you want the Index Advisor objects to be created in a schema named advisor, use the command:
>
> SET search\_path = advisor, public, accounting;

2.  Run the index\_advisor.sql script to create the database objects. If you are running the psql client, you can use the command:

> \\i *full*\_*pathname*/index\_advisor.sql
>
> Specify the pathname to the index\_advisor.sql script in place of *full\_pathname*.

3.  Grant privileges on the index\_advisor\_log table to all Index Advisor users; this step is not necessary if the Index Advisor user is a superuser, or the owner of these database objects.

<!-- end list -->
 - Grant SELECT and INSERT privileges on the index\_advisor\_log table to allow a user to invoke Index Advisor.
 - Grant DELETE privileges on the index\_advisor\_log table to allow the specified user to delete the table contents.
 - Grant SELECT privilege on the index\_recommendations view.

The following example demonstrates the creation of the Index Advisor database objects in a schema named ia, which will then be accessible to an Index Advisor user with user name *ia\_user*:

$ edb-psql -d edb -U enterprisedb

edb-psql (9.5.0.0)

Type "help" for help.

edb=\# CREATE SCHEMA ia;
CREATE SCHEMA
edb=\# SET search\_path TO ia;

SET
edb=\# \\i /opt/PostgresPlus/9.5AS/share/contrib/index\_advisor.sql
CREATE TABLE
CREATE INDEX
CREATE INDEX
CREATE FUNCTION
CREATE FUNCTION
CREATE VIEW
edb=\# GRANT USAGE ON SCHEMA ia TO ia\_user;
GRANT
edb=\# GRANT SELECT, INSERT, DELETE ON index\_advisor\_log TO ia\_user;
GRANT
edb=\# GRANT SELECT ON index\_recommendations TO ia\_user;
GRANT

While using Index Advisor, the specified schema (ia) must be included in *ia\_user*'s search\_path parameter.

### Using Index Advisor

When you invoke Index Advisor, you must supply a workload; the workload is either a query (specified at the command line), or a file that contains a set of queries (executed by the pg\_advise\_index() function). After analyzing the workload, Index Advisor will either store the result set in a temporary table, or in a permanent table. You can review the indexing recommendations generated by Index Advisor and use the CREATE INDEX statements generated by Index Advisor to create the recommended indexes.

Note: You should not run Index Advisor in read-only transactions.

The following examples assume that superuser enterprisedb is the Index Advisor user, and the Index Advisor database objects have been created in a schema in the search\_path of superuser enterprisedb.

The examples in the following sections use the table created with the statement shown below:

CREATE TABLE t( a INT, b INT );
INSERT INTO t SELECT s, 99999 - s FROM generate\_series(0,99999) AS s;

ANALYZE t;

The resulting table contains the following rows:

a | b

\-------+-------

0 | 99999

1 | 99998

2 | 99997

3 | 99996

.

.

.

99997 | 2

99998 | 1

99999 | 0

#### Using the pg\_advise\_index Utility

When invoking the pg\_advise\_index utility, you must include the name of a file that contains the queries that will be executed by pg\_advise\_index; the queries may be on the same line, or on separate lines, but each query must be terminated by a semicolon. Queries within the file should not begin with the EXPLAIN keyword.

The following example shows the contents of a sample workload.sql file:

SELECT \* FROM t WHERE a = 500;

SELECT \* FROM t WHERE b \< 1000;

Run the pg\_advise\_index program as shown in the code sample below:

$ pg\_advise\_index -d edb -h localhost -U enterprisedb -s 100M -o advisory.sql workload.sql

poolsize = 102400 KB

load workload from file 'workload.sql'

Analyzing queries .. done.

size = 2184 KB, benefit = 1684.720000

size = 2184 KB, benefit = 1655.520000

/\* 1. t(a): size=2184 KB, benefit=1684.72 \*/

/\* 2. t(b): size=2184 KB, benefit=1655.52 \*/

/\* Total size = 4368KB \*/

In the code sample, the -d, -h, and -U options are psql connection options.

\-s

\-s is an optional parameter that limits the maximum size of the indexes recommended by Index Advisor. If Index Advisor does not return a result set, -s may be set too low.

\-o

The recommended indexes are written to the file specified after the -o option.

The information displayed by the pg\_advise\_index program is logged in the index\_advisor\_log table. In response to the command shown in the example, Index Advisor writes the following CREATE INDEX statements to the advisory.sql output file

create index idx\_t\_1 on t (a);
create index idx\_t\_2 on t (b);

You can create the recommended indexes at the psql command line with the CREATE INDEX statements in the file, or create the indexes by executing the advisory.sql script.

$ edb-psql -d edb -h localhost -U enterprisedb -e -f advisory.sql

create index idx\_t\_1 on t (a);

CREATE INDEX

create index idx\_t\_2 on t (b);

CREATE INDEX

#### Using Index Advisor at the psql Command Line

You can use Index Advisor to analyze SQL statements entered at the edb-psql (or psql) command line; the following steps detail loading the Index Advisor plugin and using Index Advisor:

1.  Connect to the server with the edb-psql command line utility, and load the Index Advisor plugin:

> $ edb-psql -d edb -U enterprisedb
> …
> edb=\# LOAD 'index\_advisor';
> LOAD

2.  Use the edb-psql command line to invoke each SQL command that you would like Index Advisor to analyze. Index Advisor stores any recommendations for the queries in the index\_advisor\_log table. If the index\_advisor\_log table does not exist in the user's search\_path, a temporary table is created with the same name. This temporary table exists only for the duration of the user's session.

After loading the Index Advisor plugin, Index Advisor will analyze all SQL statements and log any indexing recommendations for the duration of the session.

If you would like Index Advisor to analyze a query (and make indexing recommendations) without actually executing the query, preface the SQL statement with the EXPLAIN keyword.

If you do not preface the statement with the EXPLAIN keyword, Index Advisor will analyze the statement while the statement executes, writing the indexing recommendations to the index\_advisor\_log table for later review.

In the example that follows, the EXPLAIN statement displays the normal query plan, followed by the query plan of the same query, if the query were using the recommended hypothetical index:

edb=\# EXPLAIN SELECT \* FROM t WHERE a \< 10000;

QUERY PLAN

\-----------------------------------------------------------------------------

Seq Scan on t (cost=0.00..1693.00 rows=10105 width=8)

Filter: (a \< 10000)

Result (cost=0.00..337.10 rows=10105 width=8)

One-Time Filter: '===\[ HYPOTHETICAL PLAN \]==='::text

\-\> Index Scan using "\<hypothetical-index\>:1" on t
(cost=0.00..337.10 rows=10105 width=8)

Index Cond: (a \< 10000)

(6 rows)

edb=\# EXPLAIN SELECT \* FROM t WHERE a = 100;

QUERY PLAN

\-----------------------------------------------------------------------------

Seq Scan on t (cost=0.00..1693.00 rows=1 width=8)

Filter: (a = 100)

Result (cost=0.00..8.28 rows=1 width=8)

One-Time Filter: '===\[ HYPOTHETICAL PLAN \]==='::text

\-\> Index Scan using "\<hypothetical-index\>:3" on t
(cost=0.00..8.28 rows=1 width=8)

Index Cond: (a = 100)

(6 rows)

For information about reviewing the recommended queries, see Section <span class="underline"></span>8.3.4.

After loading the Index Advisor plugin, the default value of index\_advisor.enabled is on. The Index Advisor plugin must be loaded to use a SET or SHOW command to display the current value of index\_advisor.enabled.

You can use the index\_advisor.enabled parameter to temporarily disable Index Advisor without interrupting the psql session:

edb=\# SET index\_advisor.enabled TO off;
SET

To enable Index Advisor, set the parameter to on:

edb=\# SET index\_advisor.enabled TO on;
SET

### Reviewing the Index Advisor Recommendations

There are several ways to review the index recommendations generated by Index Advisor. You can:
 - Query the index\_advisor\_log table.
 - Run the show\_index\_recommendations function.
 - Query the index\_recommendations view.

#### Using the show\_index\_recommendations() Function

To review the recommendations of the Index Advisor utility using the show\_index\_recommendations() function, call the function, specifying the process ID of the session:

SELECT show\_index\_recommendations( *pid* );

Where *pid* is the process ID of the current session. If you do not know the process ID of your current session, passing a value of NULL will also return a result set for the current session.

The following code fragment shows an example of a row in a result set:

edb=\# SELECT show\_index\_recommendations(null);

show\_index\_recommendations

\---------------------------------------------------------------------

create index idx\_t\_a on t(a);/\* size: 2184 KB, benefit: 3040.62,

gain: 1.39222666981456 \*/

(1 row)

In the example, create index idx\_t\_a on t(a) is the SQL statement needed to create the index suggested by Index Advisor. Each row in the result set shows:
 - The command required to create the recommended index.
 - The maximum estimated size of the index.
 - The calculated benefit of using the index.
 - The estimated gain that will result from implementing the index.

You can display the results of all Index Advisor sessions from the following view:

SELECT \* FROM index\_recommendations;

#### Querying the index\_advisor\_log Table

Index Advisor stores indexing recommendations in a table named index\_advisor\_log. Each row in the index\_advisor\_log table contains the result of a query where Index Advisor determines it can recommend a hypothetical index to reduce the execution cost of that query.

| Column       | Type        | Description                                              |
| ------------ | ----------- | -------------------------------------------------------- |
| reloid       | oid         | OID of the base table for the index                      |
| relname      | name        | Name of the base table for the index                     |
| attrs        | integer\[\] | Recommended index columns (identified by column number)  |
| benefit      | real        | Calculated benefit of the index for this query           |
| index\_size  | integer     | Estimated index size in disk-pages                       |
| backend\_pid | integer     | Process ID of the process generating this recommendation |
| timestamp    | timestamp   | Date/Time when the recommendation was generated          |

You can query the index\_advisor\_log table at the psql command line. The following example shows the index\_advisor\_log table entries resulting from two Index Advisor sessions. Each session contains two queries, and can be identified (in the table below) by a different backend\_pid value. For each session, Index Advisor generated two index recommendations.

edb=\# SELECT \* FROM index\_advisor\_log;

reloid | relname | attrs | benefit | index\_size | backend\_pid | timestamp

\--------+---------+-------+---------+------------+-------------+----------------------------------

16651 | t | {1} | 1684.72 | 2184 | 3442 | 22-MAR-11 16:44:32.712638 -04:00

16651 | t | {2} | 1655.52 | 2184 | 3442 | 22-MAR-11 16:44:32.759436 -04:00

16651 | t | {1} | 1355.9 | 2184 | 3506 | 22-MAR-11 16:48:28.317016 -04:00

16651 | t | {1} | 1684.72 | 2184 | 3506 | 22-MAR-11 16:51:45.927906 -04:00

(4 rows)

Index Advisor added the first two rows to the table after analyzing the following two queries executed by the pg\_advise\_index utility:

SELECT \* FROM t WHERE a = 500;

SELECT \* FROM t WHERE b \< 1000;

The value of 3442 in column backend\_pid identifies these results as coming from the session with process ID 3442.

The value of 1 in column attrs in the first row indicates that the hypothetical index is on the first column of the table (column a of table t).

The value of 2 in column attrs in the second row indicates that the hypothetical index is on the second column of the table (column b of table t).

Index Advisor added the last two rows to the table after analyzing the following two queries (executed at the psql command line):

edb=\# EXPLAIN SELECT \* FROM t WHERE a \< 10000;

QUERY PLAN

\----------------------------------------------------------------------------------------------

Seq Scan on t (cost=0.00..1693.00 rows=10105 width=8)

Filter: (a \< 10000)

Result (cost=0.00..337.10 rows=10105 width=8)

One-Time Filter: '===\[ HYPOTHETICAL PLAN \]==='::text

\-\> Index Scan using "\<hypothetical-index\>:1" on t (cost=0.00..337.10 rows=10105 width=8)

Index Cond: (a \< 10000)

(6 rows)

edb=\# EXPLAIN SELECT \* FROM t WHERE a = 100;

QUERY PLAN

\----------------------------------------------------------------------------------------

Seq Scan on t (cost=0.00..1693.00 rows=1 width=8)

Filter: (a = 100)

Result (cost=0.00..8.28 rows=1 width=8)

One-Time Filter: '===\[ HYPOTHETICAL PLAN \]==='::text

\-\> Index Scan using "\<hypothetical-index\>:3" on t (cost=0.00..8.28 rows=1 width=8)

Index Cond: (a = 100)

(6 rows)

The values in the benefit column of the index\_advisor\_log table are calculated using the following formula:

benefit = (normal execution cost) - (execution cost with hypothetical index)

The value of the benefit column for the last row of the index\_advisor\_log table (shown in the example) is calculated using the query plan for the following SQL statement:

EXPLAIN SELECT \* FROM t WHERE a = 100;

The execution costs of the different execution plans are evaluated and compared:

benefit = (Seq Scan on t cost) - (Index Scan using \<hypothetical-index\>)

and the benefit is added to the table:

benefit = 1693.00 - 8.28
benefit = 1684.72

You can delete rows from the index\_advisor\_log table when you no longer have the need to review the results of the queries stored in the row.

#### Querying the index\_recommendations View

The index\_recommendations view contains the calculated metrics and the CREATE INDEX statements to create the recommended indexes for all sessions whose results are currently in the index\_advisor\_log table. You can display the results of all stored Index Advisor sessions by querying the index\_recommendations view as shown below:

> SELECT \* FROM index\_recommendations;

Using the example shown in the previous section (*Querying the index\_advisor\_log Table*), the index\_recommendations view displays the following:

edb=\# SELECT \* FROM index\_recommendations;

backend\_pid | show\_index\_recommendations

\-------------+---------------------------------------------------------------------------------------------

3442 | create index idx\_t\_a on t(a);/\* size: 2184 KB, benefit: 1684.72, gain: 0.771392654586624 \*/

3442 | create index idx\_t\_b on t(b);/\* size: 2184 KB, benefit: 1655.52, gain: 0.758021539820856 \*/

3506 | create index idx\_t\_a on t(a);/\* size: 2184 KB, benefit: 3040.62, gain: 1.39222666981456 \*/

(3 rows)

Within each session, the results of all queries that benefit from the same recommended index are combined to produce one set of metrics per recommended index, reflected in the fields named benefit and gain.

The formulas for the fields are as follows:

size = MAX(index size of all queries)

benefit = SUM(benefit of each query)

gain = SUM(benefit of each query) / MAX(index size of all queries)

So for example, using the following query results from the process with a backend\_pid of 3506:

reloid | relname | attrs | benefit | index\_size | backend\_pid | timestamp

\--------+---------+-------+---------+------------+-------------+----------------------------------

16651 | t | {1} | 1355.9 | 2184 | 3506 | 22-MAR-11 16:48:28.317016 -04:00

16651 | t | {1} | 1684.72 | 2184 | 3506 | 22-MAR-11 16:51:45.927906 -04:00

The metrics displayed from the index\_recommendations view for backend\_pid 3506 are:

backend\_pid | show\_index\_recommendations

\-------------+---------------------------------------------------------------------------------------------

3506 | create index idx\_t\_a on t(a);/\* size: 2184 KB, benefit: 3040.62, gain: 1.39222666981456 \*/

The metrics from the view are calculated as follows:

benefit = (benefit from 1st query) + (benefit from 2nd query)

benefit = 1355.9 + 1684.72

benefit = 3040.62

and

gain = ((benefit from 1st query) + (benefit from 2nd query)) / MAX(index size of all queries)

gain = (1355.9 + 1684.72) / MAX(2184, 2184)

gain = 3040.62 / 2184

gain = 1.39223

The gain metric is useful when comparing the relative advantage of the different recommended indexes derived during a given session. The larger the gain value, the better the cost effectiveness derived from the index weighed against the possible disk space consumption of the index.

### Limitations

Index Advisor does not consider Index Only scans; it does consider Index scans when making recommendations.

Index Advisor ignores any computations found in the WHERE clause. Effectively, the index field in the recommendations will not be any kind of expression; the field will be a simple column name.

Index Advisor does not consider inheritance when recommending hypothetical indexes. If a query references a parent table, Index Advisor does not make any index recommendations on child tables.

Restoration of a pg\_dump backup file that includes the index\_advisor\_log table or any tables for which indexing recommendations were made and stored in the index\_advisor\_log table, may result in "broken links" between the index\_advisor\_log table and the restored tables referenced by rows in the index\_advisor\_log table because of changes in object identifiers (OIDs).

If it is necessary to display the recommendations made prior to the backup, you can replace the old OIDs in the reloid column of the index\_advisor\_log table with the new OIDs of the referenced tables using the SQL UPDATE statement:

UPDATE index\_advisor\_log SET reloid = new\_oid WHERE reloid = old\_oid;

## SQL Profiler

Inefficient SQL code is one of, if not the leading cause of database performance problems. The challenge for database administrators and developers is locating and then optimizing this code in large, complex systems.

*SQL Profiler* helps you locate and optimize poorly running SQL code.

Specific features and benefits of SQL Profiler include the following:
 - **On-Demand Traces.** You can capture SQL traces at any time by manually setting up your parameters and starting the trace.
 - **Scheduled Traces.** For inconvenient times, you can also specify your trace parameters and schedule them to run at some later time.
 - **Save Traces.** Execute your traces and save them for later review.
 - **Trace Filters.** Selectively filter SQL captures by database and by user, or capture every SQL statement sent by all users against all databases.
 - **Trace Output Analyzer.** A graphical table lets you quickly sort and filter queries by duration or statement, and a graphical or text based EXPLAIN plan lays out your query paths and joins.
 - **Index Advisor Integration.** Once you have found your slow queries and optimized them, you can also let the Index Advisor recommend the creation of underlying table indices to further improve performance.

For more information about SQL Profiler and Postgres Enterprise Manager, visit the EnterpriseDB website at:

[http://www.enterprisedb.com/postgres-enterprise-manager](http://www.enterprisedb.com/products-services-training/products/postgres-enterprise-manager)

## Query Optimization Hints

When you invoke a DELETE, INSERT, SELECT or UPDATE command, the server generates a set of execution plans; after analyzing those execution plans, the server selects a plan that will (generally) return the result set in the least amount of time. The server's choice of plan is dependent upon several factors:
 - The estimated execution cost of data handling operations.
 - Parameter values assigned to parameters in the Query Tuning section of the postgresql.conf file.
 - Column statistics that have been gathered by the [ANALYZE](http://www.enterprisedb.com/docs/en/9.3/pg/sql-analyze.html) command.

As a rule, the query planner will select the least expensive plan. You can use an *optimizer hint* to influence the server as it selects a query plan. An optimizer hint is a directive (or multiple directives) embedded in a comment-like syntax that immediately follows a DELETE, INSERT, SELECT or UPDATE command. Keywords in the comment instruct the server to employ or avoid a specific plan when producing the result set.

**Synopsis**

{ DELETE | INSERT | SELECT | UPDATE } /\*+ { *hint* \[ *comment* \] } \[...\] \*/

*statement\_body*

{ DELETE | INSERT | SELECT | UPDATE } --+ { *hint* \[ *comment* \] } \[...\]

*statement\_body*

Optimizer hints may be included in either of the forms shown above. Note that in both forms, a plus sign (+) must immediately follow the /\* or -- opening comment symbols, with no intervening space, or the server will not interpret the following tokens as hints.

If you are using the first form, the hint and optional comment may span multiple lines. The second form requires all hints and comments to occupy a single line; the remainder of the statement must start on a new line.

**Description**

Please Note:
 - The database server will always try to use the specified hints if at all possible.
 - If a planner method parameter is set so as to disable a certain plan type, then this plan will not be used even if it is specified in a hint, unless there are no other possible options for the planner. Examples of planner method parameters are enable\_indexscan, enable\_seqscan, enable\_hashjoin, enable\_mergejoin, and enable\_nestloop. These are all Boolean parameters.
 - Remember that the hint is embedded within a comment. As a consequence, if the hint is misspelled or if any parameter to a hint such as view, table, or column name is misspelled, or non-existent in the SQL command, there will be no indication that any sort of error has occurred. No syntax error will be given and the entire hint is simply ignored.
 - If an alias is used for a table or view name in the SQL command, then the alias name, not the original object name, must be used in the hint. For example, in the command, SELECT /\*+ FULL(acct) \*/ \* FROM accounts acct ..., acct, the alias for accounts, must be specified in the FULL hint, not the table name, accounts.
 - Use the EXPLAIN command to ensure that the hint is correctly formed and the planner is using the hint. See the *EDB Postgres* documentation set for information on the EXPLAIN command.
 - In general, optimizer hints should not be used in production applications. Typically, the table data changes throughout the life of the application. By ensuring that the more dynamic columns are ANALYZEd frequently, the column statistics will be updated to reflect value changes and the planner will use such information to produce the least cost plan for any given command execution. Use of optimizer hints defeats the purpose of this process and will result in the same plan regardless of how the table data changes.

**Parameters**

*hint*

An optimizer hint directive.

*comment*

A string with additional information. Note that there are restrictions as to what characters may be included in the comment. Generally, *comment* may only consist of alphabetic, numeric, the underscore, dollar sign, number sign and space characters. These must also conform to the syntax of an identifier. Any subsequent hint will be ignored if the comment is not in this form.

*statement\_body*

The remainder of the DELETE, INSERT, SELECT, or UPDATE command.

The following sections describe the optimizer hint directives in more detail.

### Default Optimization Modes

There are a number of optimization modes that can be chosen as the default setting for an Advanced Server database cluster. This setting can also be changed on a per session basis by using the ALTER SESSION command as well as in individual DELETE, SELECT, and UPDATE commands within an optimizer hint. The configuration parameter that controls these default modes is named OPTIMIZER\_MODE. The following table shows the possible values.

Table 3‑8‑1 Default Optimization Modes

|                   |                                                                                                                                                                                                                        |
| ----------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Hint              | Description                                                                                                                                                                                                            |
| ALL\_ROWS         | Optimizes for retrieval of all rows of the result set.                                                                                                                                                                 |
| CHOOSE            | Does no default optimization based on assumed number of rows to be retrieved from the result set. This is the default.                                                                                                 |
| FIRST\_ROWS       | Optimizes for retrieval of only the first row of the result set.                                                                                                                                                       |
| FIRST\_ROWS\_10   | Optimizes for retrieval of the first 10 rows of the results set.                                                                                                                                                       |
| FIRST\_ROWS\_100  | Optimizes for retrieval of the first 100 rows of the result set.                                                                                                                                                       |
| FIRST\_ROWS\_1000 | Optimizes for retrieval of the first 1000 rows of the result set.                                                                                                                                                      |
| FIRST\_ROWS(*n*)  | Optimizes for retrieval of the first *n* rows of the result set. This form may not be used as the object of the ALTER SESSION SET OPTIMIZER\_MODE command. It may only be used in the form of a hint in a SQL command. |

These optimization modes are based upon the assumption that the client submitting the SQL command is interested in viewing only the first “n” rows of the result set and will then abandon the remainder of the result set. Resources allocated to the query are adjusted as such.

**Examples**

Alter the current session to optimize for retrieval of the first 10 rows of the result set.

ALTER SESSION SET OPTIMIZER\_MODE = FIRST\_ROWS\_10;

The current value of the OPTIMIZER\_MODE parameter can be shown by using the SHOW command. Note that this command is a utility dependent command. In PSQL, the SHOW command is used as follows:

SHOW OPTIMIZER\_MODE;

optimizer\_mode

\----------------

first\_rows\_10

(1 row)

The SHOW command has the following syntax:

SHOW PARAMETER OPTIMIZER\_MODE;

NAME

\--------------------------------------------------

VALUE

\--------------------------------------------------

optimizer\_mode

first\_rows\_10

The following example shows an optimization mode used in a SELECT command as a hint:

SELECT /\*+ FIRST\_ROWS(7) \*/ \* FROM emp;

empno | ename | job | mgr | hiredate | sal | comm | deptno

\-------+--------+-----------+------+--------------------+---------+---------+--------

7369 | SMITH | CLERK | 7902 | 17-DEC-80 00:00:00 | 800.00 | | 20

7499 | ALLEN | SALESMAN | 7698 | 20-FEB-81 00:00:00 | 1600.00 | 300.00 | 30

7521 | WARD | SALESMAN | 7698 | 22-FEB-81 00:00:00 | 1250.00 | 500.00 | 30

7566 | JONES | MANAGER | 7839 | 02-APR-81 00:00:00 | 2975.00 | | 20

7654 | MARTIN | SALESMAN | 7698 | 28-SEP-81 00:00:00 | 1250.00 | 1400.00 | 30

7698 | BLAKE | MANAGER | 7839 | 01-MAY-81 00:00:00 | 2850.00 | | 30

7782 | CLARK | MANAGER | 7839 | 09-JUN-81 00:00:00 | 2450.00 | | 10

7788 | SCOTT | ANALYST | 7566 | 19-APR-87 00:00:00 | 3000.00 | | 20

7839 | KING | PRESIDENT | | 17-NOV-81 00:00:00 | 5000.00 | | 10

7844 | TURNER | SALESMAN | 7698 | 08-SEP-81 00:00:00 | 1500.00 | 0.00 | 30

7876 | ADAMS | CLERK | 7788 | 23-MAY-87 00:00:00 | 1100.00 | | 20

7900 | JAMES | CLERK | 7698 | 03-DEC-81 00:00:00 | 950.00 | | 30

7902 | FORD | ANALYST | 7566 | 03-DEC-81 00:00:00 | 3000.00 | | 20

7934 | MILLER | CLERK | 7782 | 23-JAN-82 00:00:00 | 1300.00 | | 10

(14 rows)

### Access Method Hints

The following hints influence how the optimizer accesses relations to create the result set.

Table 3‑8‑2 Access Method Hints

|                                          |                                                       |
| ---------------------------------------- | ----------------------------------------------------- |
| Hint                                     | Description                                           |
| FULL(*table*)                            | Perform a full sequential scan on *table*.            |
| INDEX(*table* \[ *index* \] \[...\])     | Use *index* on *table* to access the relation.        |
| NO\_INDEX(*table* \[ *index* \] \[...\]) | Do not use *index* on *table* to access the relation. |

In addition, the ALL\_ROWS, FIRST\_ROWS, and FIRST\_ROWS(*n*) hints of Table 3‑8‑1 can be used.

**Examples**

The sample application does not have sufficient data to illustrate the effects of optimizer hints so the remainder of the examples in this section will use a banking database created by the pgbench application located in the PostgresPlus\\9.5AS\\bin subdirectory.

The following steps create a database named, bank, populated by the tables, accounts, branches, tellers, and history. The –s 5 option specifies a scaling factor of five which results in the creation of five branches, each with 100,000 accounts, resulting in a total of 500,000 rows in the accounts table and five rows in the branches table. Ten tellers are assigned to each branch resulting in a total of 50 rows in the tellers table.

Note, if using Linux use the export command instead of the SET PATH command as shown below.

> export PATH=/opt/PostgresPlus/9.5AS/bin:$PATH

The following example was run in Windows.

SET PATH=C:\\PostgresPlus\\9.5AS\\bin;%PATH%

createdb -U enterprisedb bank

CREATE DATABASE

pgbench -i -s 5 -U enterprisedb -d bank

creating tables...

10000 tuples done.

20000 tuples done.

30000 tuples done.

.

.

.

470000 tuples done.

480000 tuples done.

490000 tuples done.

500000 tuples done.

set primary key...

vacuum...done.

Ten transactions per client are then processed for eight clients for a total of 80 transactions. This will populate the history table with 80 rows.

pgbench –U enterprisedb –d bank –c 8 –t 10

.

.

.

transaction type: TPC-B (sort of)

scaling factor: 5

number of clients: 8

number of transactions per client: 10

number of transactions actually processed: 80/80

tps = 6.023189 (including connections establishing)

tps = 7.140944 (excluding connections establishing)

The table definitions are shown below:

\\d accounts

Table "public.accounts"

Column | Type | Modifiers

\----------+---------------+-----------

aid | integer | not null

bid | integer |

abalance | integer |

filler | character(84) |

Indexes:

"accounts\_pkey" PRIMARY KEY, btree (aid)

\\d branches

Table "public.branches"

Column | Type | Modifiers

\----------+---------------+-----------

bid | integer | not null

bbalance | integer |

filler | character(88) |

Indexes:

"branches\_pkey" PRIMARY KEY, btree (bid)

\\d tellers

Table "public.tellers"

Column | Type | Modifiers

\----------+---------------+-----------

tid | integer | not null

bid | integer |

tbalance | integer |

filler | character(84) |

Indexes:

"tellers\_pkey" PRIMARY KEY, btree (tid)

\\d history

Table "public.history"

Column | Type | Modifiers

\--------+-----------------------------+-----------

tid | integer |

bid | integer |

aid | integer |

delta | integer |

mtime | timestamp without time zone |

filler | character(22) |

The EXPLAIN command shows the plan selected by the query planner. In the following example, aid is the primary key column, so an indexed search is used on index, accounts\_pkey.

EXPLAIN SELECT \* FROM accounts WHERE aid = 100;

QUERY PLAN

\-------------------------------------------------------------------------------

Index Scan using accounts\_pkey on accounts (cost=0.00..8.32 rows=1 width=97)

Index Cond: (aid = 100)

(2 rows)

The FULL hint is used to force a full sequential scan instead of using the index as shown below:

EXPLAIN SELECT /\*+ FULL(accounts) \*/ \* FROM accounts WHERE aid = 100;

QUERY PLAN

\-------------------------------------------------------------

Seq Scan on accounts (cost=0.00..14461.10 rows=1 width=97)

Filter: (aid = 100)

(2 rows)

The NO\_INDEX hint also forces a sequential scan as shown below:

EXPLAIN SELECT /\*+ NO\_INDEX(accounts accounts\_pkey) \*/ \* FROM accounts WHERE aid = 100;

QUERY PLAN

\-------------------------------------------------------------

Seq Scan on accounts (cost=0.00..14461.10 rows=1 width=97)

Filter: (aid = 100)

(2 rows)

In addition to using the EXPLAIN command as shown in the prior examples, more detailed information regarding whether or not a hint was used by the planner can be obtained by setting the client\_min\_messages and trace\_hints configuration parameters as follows:

SET client\_min\_messages TO info;

SET trace\_hints TO true;

The SELECT command with the NO\_INDEX hint is repeated below to illustrate the additional information produced when the aforementioned configuration parameters are set.

EXPLAIN SELECT /\*+ NO\_INDEX(accounts accounts\_pkey) \*/ \* FROM accounts WHERE aid = 100;

INFO: \[HINTS\] Index Scan of \[accounts\].\[accounts\_pkey\] rejected because of NO\_INDEX hint.

INFO: \[HINTS\] Bitmap Heap Scan of \[accounts\].\[accounts\_pkey\] rejected because of NO\_INDEX hint.

QUERY PLAN

\-------------------------------------------------------------

Seq Scan on accounts (cost=0.00..14461.10 rows=1 width=97)

Filter: (aid = 100)

(2 rows)

Note that if a hint is ignored, the INFO: \[HINTS\] line will not appear. This may be an indication that there was a syntax error or some other misspelling in the hint as shown in the following example where the index name is misspelled.

EXPLAIN SELECT /\*+ NO\_INDEX(accounts accounts\_xxx) \*/ \* FROM accounts WHERE aid = 100;

QUERY PLAN

\-------------------------------------------------------------------------------

Index Scan using accounts\_pkey on accounts (cost=0.00..8.32 rows=1

width=97)

Index Cond: (aid = 100)

(2 rows

### Specifying a Join Order

Include the ORDERED directive to instruct the query optimizer to join tables in the order in which they are listed in the FROM clause. If you do not include the ORDERED keyword, the query optimizer will choose the order in which to join the tables.

For example, the following command allows the optimizer to choose the order in which to join the tables listed in the FROM clause:

SELECT e.ename, d.dname, h.startdate
FROM emp e, dept d, jobhist h
WHERE d.deptno = e.deptno
AND h.empno = e.empno;

The following command instructs the optimizer to join the tables in the ordered specified:

SELECT /\*+ ORDERED \*/ e.ename, d.dname, h.startdate
FROM emp e, dept d, jobhist h
WHERE d.deptno = e.deptno
AND h.empno = e.empno;

In the ORDERED version of the command, Advanced Server will first join emp e with dept d before joining the results with jobhist h. Without the ORDERED directive, the join order is selected by the query optimizer.

Please note: the ORDERED directive does not work for outer joins that contain a '+' sign.

### Joining Relations Hints

When two tables are to be joined, there are three possible plans that may be used to perform the join.
 - *Nested Loop Join* – The right table is scanned once for every row in the left table.
 - *Merge Sort Join* – Each table is sorted on the join attributes before the join starts. The two tables are then scanned in parallel and the matching rows are combined to form the join rows.
 - *Hash Join* – The right table is scanned and its join attributes are loaded into a hash table using its join attributes as hash keys. The left table is then scanned and its join attributes are used as hash keys to locate the matching rows from the right table.

The following table lists the optimizer hints that can be used to influence the planner to use one type of join plan over another.

Table 3‑8‑3 Join Hints

|                                 |                                                                                |
| ------------------------------- | ------------------------------------------------------------------------------ |
| Hint                            | Description                                                                    |
| USE\_HASH(*table* \[...\])      | Use a hash join with a hash table created from the join attributes of *table*. |
| NO\_USE\_HASH(*table* \[...\])  | Do not use a hash join created from the join attributes of *table*.            |
| USE\_MERGE(*table* \[...\])     | Use a merge sort join for *table*.                                             |
| NO\_USE\_MERGE(*table* \[...\]) | Do not use a merge sort join for *table*.                                      |
| USE\_NL(*table* \[...\])        | Use a nested loop join for *table*.                                            |
| NO\_USE\_NL(*table* \[...\])    | Do not use a nested loop join for *table*.                                     |

**Examples**

In the following example, a join is performed on the branches and accounts tables. The query plan shows that a hash join is used by creating a hash table from the join attribute of the branches table.

EXPLAIN SELECT b.bid, a.aid, abalance FROM branches b, accounts a WHERE b.bid = a.bid;

QUERY PLAN

\--------------------------------------------------------------------------

Hash Join (cost=1.11..20092.70 rows=500488 width=12)

Hash Cond: (a.bid = b.bid)

\-\> Seq Scan on accounts a (cost=0.00..13209.88 rows=500488 width=12)

\-\> Hash (cost=1.05..1.05 rows=5 width=4)

\-\> Seq Scan on branches b (cost=0.00..1.05 rows=5 width=4)

(5 rows)

By using the USE\_HASH(a) hint, the planner is forced to create the hash table from the accounts join attribute instead of from the branches table. Note the use of the alias, a, for the accounts table in the USE\_HASH hint.

EXPLAIN SELECT /\*+ USE\_HASH(a) \*/ b.bid, a.aid, abalance FROM branches b, accounts a WHERE b.bid = a.bid;

QUERY PLAN

\--------------------------------------------------------------------------------

Hash Join (cost=21909.98..30011.52 rows=500488 width=12)

Hash Cond: (b.bid = a.bid)

\-\> Seq Scan on branches b (cost=0.00..1.05 rows=5 width=4)

\-\> Hash (cost=13209.88..13209.88 rows=500488 width=12)

\-\> Seq Scan on accounts a (cost=0.00..13209.88 rows=500488 width=12)

(5 rows)

Next, the NO\_USE\_HASH(a b) hint forces the planner to use an approach other than hash tables. The result is a nested loop.

EXPLAIN SELECT /\*+ NO\_USE\_HASH(a b) \*/ b.bid, a.aid, abalance FROM branches b, accounts a WHERE b.bid = a.bid;

QUERY PLAN

\--------------------------------------------------------------------------

Nested Loop (cost=1.05..69515.84 rows=500488 width=12)

Join Filter: (b.bid = a.bid)

\-\> Seq Scan on accounts a (cost=0.00..13209.88 rows=500488 width=12)

\-\> Materialize (cost=1.05..1.11 rows=5 width=4)

\-\> Seq Scan on branches b (cost=0.00..1.05 rows=5 width=4)

(5 rows)

Finally, the USE\_MERGE hint forces the planner to use a merge join.

EXPLAIN SELECT /\*+ USE\_MERGE(a) \*/ b.bid, a.aid, abalance FROM branches b, accounts a WHERE b.bid = a.bid;

QUERY PLAN

\--------------------------------------------------------------------------------

Merge Join (cost=69143.62..76650.97 rows=500488 width=12)

Merge Cond: (b.bid = a.bid)

\-\> Sort (cost=1.11..1.12 rows=5 width=4)

Sort Key: b.bid

\-\> Seq Scan on branches b (cost=0.00..1.05 rows=5 width=4)

\-\> Sort (cost=69142.52..70393.74 rows=500488 width=12)

Sort Key: a.bid

\-\> Seq Scan on accounts a (cost=0.00..13209.88 rows=500488 width=12)

(8 rows)

In this three-table join example, the planner first performs a hash join on the branches and history tables, then finally performs a nested loop join of the result with the accounts\_pkey index of the accounts table.

EXPLAIN SELECT h.mtime, h.delta, b.bid, a.aid FROM history h, branches b, accounts a WHERE h.bid = b.bid AND h.aid = a.aid;

QUERY PLAN

\--------------------------------------------------------------------------------------

Nested Loop (cost=1.11..207.95 rows=26 width=20)

\-\> Hash Join (cost=1.11..25.40 rows=26 width=20)

Hash Cond: (h.bid = b.bid)

\-\> Seq Scan on history h (cost=0.00..20.20 rows=1020 width=20)

\-\> Hash (cost=1.05..1.05 rows=5 width=4)

\-\> Seq Scan on branches b (cost=0.00..1.05 rows=5 width=4)

\-\> Index Scan using accounts\_pkey on accounts a (cost=0.00..7.01 rows=1

width=4)

Index Cond: (h.aid = a.aid)

(8 rows)

This plan is altered by using hints to force a combination of a merge sort join and a hash join.

EXPLAIN SELECT /\*+ USE\_MERGE(h b) USE\_HASH(a) \*/ h.mtime, h.delta, b.bid, a.aid FROM history h, branches b, accounts a WHERE h.bid = b.bid AND h.aid = a.aid;

QUERY PLAN

\-------------------------------------------------------------------------------------------

Merge Join (cost=23480.11..23485.60 rows=26 width=20)

Merge Cond: (h.bid = b.bid)

\-\> Sort (cost=23479.00..23481.55 rows=1020 width=20)

Sort Key: h.bid

\-\> Hash Join (cost=21421.98..23428.03 rows=1020 width=20)

Hash Cond: (h.aid = a.aid)

\-\> Seq Scan on history h (cost=0.00..20.20 rows=1020

width=20)

\-\> Hash (cost=13209.88..13209.88 rows=500488 width=4)

\-\> Seq Scan on accounts a (cost=0.00..13209.88

rows=500488 width=4)

\-\> Sort (cost=1.11..1.12 rows=5 width=4)

Sort Key: b.bid

\-\> Seq Scan on branches b (cost=0.00..1.05 rows=5 width=4)

(12 rows)

### Global Hints

Thus far, hints have been applied directly to tables that are referenced in the SQL command. It is also possible to apply hints to tables that appear in a view when the view is referenced in the SQL command. The hint does not appear in the view, itself, but rather in the SQL command that references the view.

When specifying a hint that is to apply to a table within a view, the view and table names are given in dot notation within the hint argument list.

**Synopsis**

*hint*(*view*.*table*)

**Parameters**

*hint*

Any of the hints in Table 3‑8‑2 or Table 3‑8‑3.

*view*

The name of the view containing *table*.

*table*

The table on which the hint is to be applied.

**Examples**

A view named, tx, is created from the three-table join of history, branches, and accounts shown in the final example of Section <span class="underline"></span>8.5.3.

CREATE VIEW tx AS SELECT h.mtime, h.delta, b.bid, a.aid FROM history h, branches b, accounts a WHERE h.bid = b.bid AND h.aid = a.aid;

The query plan produced by selecting from this view is show below:

EXPLAIN SELECT \* FROM tx;

QUERY PLAN

\--------------------------------------------------------------------------------------

Nested Loop (cost=1.11..207.95 rows=26 width=20)

\-\> Hash Join (cost=1.11..25.40 rows=26 width=20)

Hash Cond: (h.bid = b.bid)

\-\> Seq Scan on history h (cost=0.00..20.20 rows=1020 width=20)

\-\> Hash (cost=1.05..1.05 rows=5 width=4)

\-\> Seq Scan on branches b (cost=0.00..1.05 rows=5 width=4)

\-\> Index Scan using accounts\_pkey on accounts a (cost=0.00..7.01 rows=1

width=4)

Index Cond: (h.aid = a.aid)

(8 rows)

The same hints that were applied to this join at the end of Section <span class="underline"></span>8.5.3 can be applied to the view as follows:

EXPLAIN SELECT /\*+ USE\_MERGE(tx.h tx.b) USE\_HASH(tx.a) \*/ \* FROM tx;

QUERY PLAN

\------------------------------------------------------------------------------------------

\-

Merge Join (cost=23480.11..23485.60 rows=26 width=20)

Merge Cond: (h.bid = b.bid)

\-\> Sort (cost=23479.00..23481.55 rows=1020 width=20)

Sort Key: h.bid

\-\> Hash Join (cost=21421.98..23428.03 rows=1020 width=20)

Hash Cond: (h.aid = a.aid)

\-\> Seq Scan on history h (cost=0.00..20.20 rows=1020

width=20)

\-\> Hash (cost=13209.88..13209.88 rows=500488 width=4)

\-\> Seq Scan on accounts a (cost=0.00..13209.88

rows=500488 width=4)

\-\> Sort (cost=1.11..1.12 rows=5 width=4)

Sort Key: b.bid

\-\> Seq Scan on branches b (cost=0.00..1.05 rows=5 width=4)

(12 rows)

In addition to applying hints to tables within stored views, hints can be applied to tables within subqueries as illustrated by the following example. In this query on the sample application emp table, employees and their managers are listed by joining the emp table with a subquery of the emp table identified by the alias, b.

SELECT a.empno, a.ename, b.empno "mgr empno", b.ename "mgr ename" FROM emp a, (SELECT \* FROM emp) b WHERE a.mgr = b.empno;

empno | ename | mgr empno | mgr ename

\-------+--------+-----------+-----------

7902 | FORD | 7566 | JONES

7788 | SCOTT | 7566 | JONES

7521 | WARD | 7698 | BLAKE

7844 | TURNER | 7698 | BLAKE

7654 | MARTIN | 7698 | BLAKE

7900 | JAMES | 7698 | BLAKE

7499 | ALLEN | 7698 | BLAKE

7934 | MILLER | 7782 | CLARK

7876 | ADAMS | 7788 | SCOTT

7782 | CLARK | 7839 | KING

7698 | BLAKE | 7839 | KING

7566 | JONES | 7839 | KING

7369 | SMITH | 7902 | FORD

(13 rows)

The plan chosen by the query planner is shown below:

EXPLAIN SELECT a.empno, a.ename, b.empno "mgr empno", b.ename "mgr ename" FROM emp a, (SELECT \* FROM emp) b WHERE a.mgr = b.empno;

QUERY PLAN

\-------------------------------------------------------------------

Merge Join (cost=2.81..3.08 rows=13 width=26)

Merge Cond: (a.mgr = emp.empno)

\-\> Sort (cost=1.41..1.44 rows=14 width=20)

Sort Key: a.mgr

\-\> Seq Scan on emp a (cost=0.00..1.14 rows=14 width=20)

\-\> Sort (cost=1.41..1.44 rows=14 width=13)

Sort Key: emp.empno

\-\> Seq Scan on emp (cost=0.00..1.14 rows=14 width=13)

(8 rows)

A hint can be applied to the emp table within the subquery to perform an index scan on index, emp\_pk, instead of a table scan. Note the difference in the query plans.

EXPLAIN SELECT /\*+ INDEX(b.emp emp\_pk) \*/ a.empno, a.ename, b.empno "mgr empno", b.ename "mgr ename" FROM emp a, (SELECT \* FROM emp) b WHERE a.mgr = b.empno;

QUERY PLAN

\---------------------------------------------------------------------------

Merge Join (cost=1.41..13.21 rows=13 width=26)

Merge Cond: (a.mgr = emp.empno)

\-\> Sort (cost=1.41..1.44 rows=14 width=20)

Sort Key: a.mgr

\-\> Seq Scan on emp a (cost=0.00..1.14 rows=14 width=20)

\-\> Index Scan using emp\_pk on emp (cost=0.00..12.46 rows=14 width=13)

(6 rows)

### Using the APPEND Optimizer Hint

By default, Advanced Server will add new data into the first available free-space in a table (vacated by vacuumed records). Include the APPEND directive after an INSERT or SELECT command to instruct the server to bypass mid-table free space, and affix new rows to the end of the table. This optimizer hint can be particularly useful when bulk loading data.

The syntax is:

/\*+APPEND\*/

For example, the following command instructs the server to append the data in the INSERT statement to the end of the sales table:

INSERT /\*+APPEND\*/ INTO sales VALUES
(10, 10, '01-Mar-2011', 10, 'OR');

Note that Advanced Server supports the APPEND hint when adding multiple rows in a single INSERT statement:

INSERT /\*+APPEND\*/ INTO sales VALUES
(20, 20, '01-Aug-2011', 20, 'NY'),
(30, 30, '01-Feb-2011', 30, 'FL'),
(40, 40, '01-Nov-2011', 40, 'TX');

The APPEND hint can also be included in the SELECT clause of an INSERT INTO statement:

INSERT INTO sales\_history SELECT /\*+APPEND\*/ FROM sales;

### Conflicting Hints

If a command includes two or more conflicting hints, the server will ignore the contradictory hints. The following table lists hints that are contradictory to each other.

Table 3‑8‑4 Conflicting Hints

<table>
<tbody>
<tr class="odd">
<td>Hint</td>
<td>Conflicting Hint</td>
</tr>
<tr class="even">
<td>ALL_ROWS</td>
<td>FIRST_ROWS - all formats</td>
</tr>
<tr class="odd">
<td>FULL(<em>table</em>)</td>
<td>INDEX(<em>table</em> [ <em>index</em> ])</td>
</tr>
<tr class="even">
<td>INDEX(<em>table</em>)</td>
<td><p>FULL(<em>table</em>)</p>
<p>NO_INDEX(<em>table</em>)</p></td>
</tr>
<tr class="odd">
<td>INDEX(<em>table</em> <em>index</em>)</td>
<td><p>FULL(<em>table</em>)</p>
<p>NO_INDEX(<em>table</em> <em>index</em>)</p></td>
</tr>
<tr class="even">
<td>USE_HASH(<em>table</em>)</td>
<td>NO_USE_HASH(<em>table</em>)</td>
</tr>
<tr class="odd">
<td>USE_MERGE(<em>table</em>)</td>
<td>NO_USE_MERGE(<em>table</em>)</td>
</tr>
<tr class="even">
<td>USE_NL(<em>table</em>)</td>
<td>NO_USE_NL(<em>table</em>)</td>
</tr>
</tbody>
</table>

## DBMS\_PROFILER

The DBMS\_PROFILER package collects and stores performance information about the PL/pgSQL and SPL statements that are executed during a profiling session; you can review the performance information in the tables and views provided by the profiler.

DBMS\_PROFILER works by recording a set of performance-related counters and timers for each line of PL/pgSQL or SPL statement that executes within a profiling session. The counters and timers are stored in a table named SYS.PLSQL\_PROFILER\_DATA. When you complete a profiling session, DBMS\_PROFILER will write a row to the performance statistics table for each line of PL/pgSQL or SPL code that executed within the session. For example, if you execute the following function:

1 - CREATE OR REPLACE FUNCTION getBalance(acctNumber INTEGER)

2 - RETURNS NUMERIC AS $$

3 - DECLARE

4 - result NUMERIC;

5 - BEGIN

6 - SELECT INTO result balance FROM acct WHERE id = acctNumber;

7 -

8 - IF (result IS NULL) THEN

9 - RAISE INFO 'Balance is null';

10- END IF;

11-

12- RETURN result;

13- END;

14- $$ LANGUAGE 'plpgsql';

DBMS\_PROFILER adds one PLSQL\_PROFILER\_DATA entry for each line of code within the getBalance() function (including blank lines and comments). The entry corresponding to the SELECT statement executed exactly one time; and required a very small amount of time to execute. On the other hand, the entry corresponding to the RAISE INFO statement executed once or not at all (depending on the value for the balance column).

Some of the lines in this function contain no executable code so the performance statistics for those lines will always contain *zero* values.

To start a profiling session, invoke the DBMS\_PROFILER.START\_PROFILER function (or procedure). Once you've invoked START\_PROFILER, Advanced Server will profile every PL/pgSQL or SPL function, procedure, trigger, or anonymous block that your session executes until you either stop or pause the profiler (by calling STOP\_PROFILER or PAUSE\_PROFILER).

It is important to note that when you start (or resume) the profiler, the profiler will only gather performance statistics for functions/procedures/triggers that *start* after the call to START\_PROFILER (or RESUME\_PROFILER).

While the profiler is active, Advanced Server records a large set of timers and counters in memory; when you invoke the STOP\_PROFILER (or FLUSH\_DATA) function/procedure, DBMS\_PROFILER writes those timers and counters to a set of three tables:
 - SYS.PLSQL\_PROFILER\_RAWDATA
    Contains the performance counters and timers for each statement executed within the session.
 - SYS.PLSQL\_PROFILER\_RUNS
    Contains a summary of each run (aggregating the information found in PLSQL\_PROFILER\_RAWDATA).
 - SYS.PLSQL\_PROFILER\_UNITS
    Contains a summary of each code unit (function, procedure, trigger, or anonymous block) executed within a session.

In addition, DBMS\_PROFILER defines a view, SYS.PLSQL\_PROFILER\_DATA, which contains a subset of the PLSQL\_PROFILER\_RAWDATA table.

Please note that a non-superuser may *gather* profiling information, but may not view that profiling information unless a superuser grants specific privileges on the profiling tables (stored in the SYS schema). This permits a non-privileged user to gather performance statistics without exposing information that the administrator may want to keep secret.

### Querying the DBMS\_PROFILER Tables and View

The following step-by-step example uses DBMS\_PROFILER to retrieve performance information for procedures, functions, and triggers included in the sample data distributed with Advanced Server.

1.  Open the EDB-PSQL command line, and establish a connection to the Advanced Server database. Use an EXEC statement to start the profiling session:

acctg=\# EXEC dbms\_profiler.start\_profiler('profile list\_emp');

EDB-SPL Procedure successfully completed

> (Note: the call to start\_profiler() includes a comment that DBMS\_PROFILER associates with the profiler session).

2.  Then call the list\_emp function:

acctg=\# SELECT list\_emp();

INFO: EMPNO ENAME

INFO: ----- -------

INFO: 7369 SMITH

INFO: 7499 ALLEN

INFO: 7521 WARD

INFO: 7566 JONES

INFO: 7654 MARTIN

INFO: 7698 BLAKE

INFO: 7782 CLARK

INFO: 7788 SCOTT

INFO: 7839 KING

INFO: 7844 TURNER

INFO: 7876 ADAMS

INFO: 7900 JAMES

INFO: 7902 FORD

INFO: 7934 MILLER

list\_emp

\----------

(1 row)

3.  Stop the profiling session with a call to dbms\_profiler.stop\_profiler:

acctg=\# EXEC dbms\_profiler.stop\_profiler;

EDB-SPL Procedure successfully completed

4.  Start a new session with the dbms\_profiler.start\_profiler function (followed by a new comment):

acctg=\# EXEC dbms\_profiler.start\_profiler('profile get\_dept\_name and emp\_sal\_trig');

EDB-SPL Procedure successfully completed

5.  Invoke the get\_dept\_name function:

acctg=\# SELECT get\_dept\_name(10);

get\_dept\_name

\---------------

ACCOUNTING

(1 row)

6.  Execute an UPDATE statement that causes a trigger to execute:

acctg=\# UPDATE memp SET sal = 500 WHERE empno = 7902;

INFO: Updating employee 7902

INFO: ..Old salary: 3000.00

INFO: ..New salary: 500.00

INFO: ..Raise : -2500.00

INFO: User enterprisedb updated employee(s) on 04-FEB-14

UPDATE 1

7.  Terminate the profiling session and flush the performance information to the profiling tables:

acctg=\# EXEC dbms\_profiler.stop\_profiler;

EDB-SPL Procedure successfully completed

8.  Now, query the plsql\_profiler\_runs table to view a list of the profiling sessions, arranged by runid:

acctg=\# SELECT \* FROM plsql\_profiler\_runs;

runid | related\_run | run\_owner | run\_date | run\_comment | run\_total\_time | run\_system\_info | run\_comment1 | spare1

\-------+-------------+--------------+---------------------------+----------------------------------------+----------------+-----------------+--------------+--------

1 | | enterprisedb | 04-FEB-14 09:32:48.874315 | profile list\_emp | 4154 | | |

2 | | enterprisedb | 04-FEB-14 09:41:30.546503 | profile get\_dept\_name and emp\_sal\_trig | 2088 | | |

(2 rows)

9.  Query the plsql\_profiler\_units table to view the amount of time consumed by each unit (each function, procedure, or trigger):

acctg=\# SELECT \* FROM plsql\_profiler\_units;

runid | unit\_number | unit\_type | unit\_owner | unit\_name | unit\_timestamp | total\_time | spare1 | spare2

\-------+-------------+-----------+--------------+---------------------------------+----------------+------------+--------+--------

1 | 16999 | FUNCTION | enterprisedb | list\_emp() | | 4 | |

2 | 17002 | FUNCTION | enterprisedb | user\_audit\_trig() | | 1 | |

2 | 17000 | FUNCTION | enterprisedb | get\_dept\_name(p\_deptno numeric) | | 1 | |

2 | 17004 | FUNCTION | enterprisedb | emp\_sal\_trig() | | 1 | |

(4 rows)

10. Query the plsql\_profiler\_rawdata table to view a list of the wait event counters and wait event times:

acctg=\# SELECT runid, sourcecode, func\_oid, line\_number, exec\_count, tuples\_returned, time\_total FROM plsql\_profiler\_rawdata;

runid | sourcecode | func\_oid | line\_number | exec\_count | tuples\_returned | time\_total

\-------+------------------------------------------------------------------+----------+-------------+------------+-----------------+------------

1 | DECLARE | 16999 | 1 | 0 | 0 | 0

1 | v\_empno NUMERIC(4); | 16999 | 2 | 0 | 0 | 0

1 | v\_ename VARCHAR(10); | 16999 | 3 | 0 | 0 | 0

1 | emp\_cur CURSOR FOR | 16999 | 4 | 0 | 0 | 0

1 | SELECT empno, ename FROM memp ORDER BY empno; | 16999 | 5 | 0 | 0 | 0

1 | BEGIN | 16999 | 6 | 0 | 0 | 0

1 | OPEN emp\_cur; | 16999 | 7 | 0 | 0 | 0

1 | RAISE INFO 'EMPNO ENAME'; | 16999 | 8 | 1 | 0 | 0.001621

1 | RAISE INFO '----- -------'; | 16999 | 9 | 1 | 0 | 0.000301

1 | LOOP | 16999 | 10 | 1 | 0 | 4.6e-05

1 | FETCH emp\_cur INTO v\_empno, v\_ename; | 16999 | 11 | 1 | 0 | 0.001114

1 | EXIT WHEN NOT FOUND; | 16999 | 12 | 15 | 0 | 0.000206

1 | RAISE INFO '% %', v\_empno, v\_ename; | 16999 | 13 | 15 | 0 | 8.3e-05

1 | END LOOP; | 16999 | 14 | 14 | 0 | 0.000773

1 | CLOSE emp\_cur; | 16999 | 15 | 0 | 0 | 0

1 | RETURN; | 16999 | 16 | 1 | 0 | 1e-05

1 | END; | 16999 | 17 | 1 | 0 | 0

1 | | 16999 | 18 | 0 | 0 | 0

2 | DECLARE | 17002 | 1 | 0 | 0 | 0

2 | v\_action VARCHAR(24); | 17002 | 2 | 0 | 0 | 0

2 | v\_text TEXT; | 17002 | 3 | 0 | 0 | 0

2 | BEGIN | 17002 | 4 | 0 | 0 | 0

2 | IF TG\_OP = 'INSERT' THEN | 17002 | 5 | 0 | 0 | 0

2 | v\_action := ' added employee(s) on '; | 17002 | 6 | 1 | 0 | 0.000143

2 | ELSIF TG\_OP = 'UPDATE' THEN | 17002 | 7 | 0 | 0 | 0

2 | v\_action := ' updated employee(s) on '; | 17002 | 8 | 0 | 0 | 0

2 | ELSIF TG\_OP = 'DELETE' THEN | 17002 | 9 | 1 | 0 | 3.2e-05

2 | v\_action := ' deleted employee(s) on '; | 17002 | 10 | 0 | 0 | 0

2 | END IF; | 17002 | 11 | 0 | 0 | 0

2 | v\_text := 'User ' || USER || v\_action || CURRENT\_DATE; | 17002 | 12 | 0 | 0 | 0

2 | RAISE INFO ' %', v\_text; | 17002 | 13 | 1 | 0 | 0.000383

2 | RETURN NULL; | 17002 | 14 | 1 | 0 | 6.3e-05

2 | END; | 17002 | 15 | 1 | 0 | 3.6e-05

2 | | 17002 | 16 | 0 | 0 | 0

2 | DECLARE | 17000 | 1 | 0 | 0 | 0

2 | v\_dname VARCHAR(14); | 17000 | 2 | 0 | 0 | 0

2 | BEGIN | 17000 | 3 | 0 | 0 | 0

2 | SELECT INTO v\_dname dname FROM dept WHERE deptno = p\_deptno; | 17000 | 4 | 0 | 0 | 0

2 | RETURN v\_dname; | 17000 | 5 | 1 | 0 | 0.000647

2 | IF NOT FOUND THEN | 17000 | 6 | 1 | 0 | 2.6e-05

2 | RAISE INFO 'Invalid department number %', p\_deptno; | 17000 | 7 | 0 | 0 | 0

2 | RETURN ''; | 17000 | 8 | 0 | 0 | 0

2 | END IF; | 17000 | 9 | 0 | 0 | 0

2 | END; | 17000 | 10 | 0 | 0 | 0

2 | | 17000 | 11 | 0 | 0 | 0

2 | DECLARE | 17004 | 1 | 0 | 0 | 0

2 | sal\_diff NUMERIC(7,2); | 17004 | 2 | 0 | 0 | 0

2 | BEGIN | 17004 | 3 | 0 | 0 | 0

2 | IF TG\_OP = 'INSERT' THEN | 17004 | 4 | 0 | 0 | 0

2 | RAISE INFO 'Inserting employee %', NEW.empno; | 17004 | 5 | 1 | 0 | 8.4e-05

2 | RAISE INFO '..New salary: %', NEW.sal; | 17004 | 6 | 0 | 0 | 0

2 | RETURN NEW; | 17004 | 7 | 0 | 0 | 0

2 | END IF; | 17004 | 8 | 0 | 0 | 0

2 | IF TG\_OP = 'UPDATE' THEN | 17004 | 9 | 0 | 0 | 0

2 | sal\_diff := NEW.sal - OLD.sal; | 17004 | 10 | 1 | 0 | 0.000355

2 | RAISE INFO 'Updating employee %', OLD.empno; | 17004 | 11 | 1 | 0 | 0.000177

2 | RAISE INFO '..Old salary: %', OLD.sal; | 17004 | 12 | 1 | 0 | 5.5e-05

2 | RAISE INFO '..New salary: %', NEW.sal; | 17004 | 13 | 1 | 0 | 3.1e-05

2 | RAISE INFO '..Raise : %', sal\_diff; | 17004 | 14 | 1 | 0 | 2.8e-05

2 | RETURN NEW; | 17004 | 15 | 1 | 0 | 2.7e-05

2 | END IF; | 17004 | 16 | 1 | 0 | 1e-06

2 | IF TG\_OP = 'DELETE' THEN | 17004 | 17 | 0 | 0 | 0

2 | RAISE INFO 'Deleting employee %', OLD.empno; | 17004 | 18 | 0 | 0 | 0

2 | RAISE INFO '..Old salary: %', OLD.sal; | 17004 | 19 | 0 | 0 | 0

2 | RETURN OLD; | 17004 | 20 | 0 | 0 | 0

2 | END IF; | 17004 | 21 | 0 | 0 | 0

2 | END; | 17004 | 22 | 0 | 0 | 0

2 | | 17004 | 23 | 0 | 0 | 0

(68 rows)

                                                                                                                   

11. Query the plsql\_profiler\_data view to review a subset of the information found in plsql\_profiler\_rawdata table:

acctg=\# SELECT \* FROM plsql\_profiler\_data;

runid | unit\_number | line\# | total\_occur | total\_time | min\_time | max\_time | spare1 | spare2 | spare3 | spare4

\-------+-------------+-------+-------------+------------+----------+----------+--------+--------+--------+--------

1 | 16999 | 1 | 0 | 0 | 0 | 0 | | | |

1 | 16999 | 2 | 0 | 0 | 0 | 0 | | | |

1 | 16999 | 3 | 0 | 0 | 0 | 0 | | | |

1 | 16999 | 4 | 0 | 0 | 0 | 0 | | | |

1 | 16999 | 5 | 0 | 0 | 0 | 0 | | | |

1 | 16999 | 6 | 0 | 0 | 0 | 0 | | | |

1 | 16999 | 7 | 0 | 0 | 0 | 0 | | | |

1 | 16999 | 8 | 1 | 0.001621 | 0.001621 | 0.001621 | | | |

1 | 16999 | 9 | 1 | 0.000301 | 0.000301 | 0.000301 | | | |

1 | 16999 | 10 | 1 | 4.6e-05 | 4.6e-05 | 4.6e-05 | | | |

1 | 16999 | 11 | 1 | 0.001114 | 0.001114 | 0.001114 | | | |

1 | 16999 | 12 | 15 | 0.000206 | 5e-06 | 7.8e-05 | | | |

1 | 16999 | 13 | 15 | 8.3e-05 | 2e-06 | 4.7e-05 | | | |

1 | 16999 | 14 | 14 | 0.000773 | 4.7e-05 | 0.000116 | | | |

1 | 16999 | 15 | 0 | 0 | 0 | 0 | | | |

1 | 16999 | 16 | 1 | 1e-05 | 1e-05 | 1e-05 | | | |

1 | 16999 | 17 | 1 | 0 | 0 | 0 | | | |

1 | 16999 | 18 | 0 | 0 | 0 | 0 | | | |

2 | 17002 | 1 | 0 | 0 | 0 | 0 | | | |

2 | 17002 | 2 | 0 | 0 | 0 | 0 | | | |

2 | 17002 | 3 | 0 | 0 | 0 | 0 | | | |

2 | 17002 | 4 | 0 | 0 | 0 | 0 | | | |

2 | 17002 | 5 | 0 | 0 | 0 | 0 | | | |

2 | 17002 | 6 | 1 | 0.000143 | 0.000143 | 0.000143 | | | |

2 | 17002 | 7 | 0 | 0 | 0 | 0 | | | |

2 | 17002 | 8 | 0 | 0 | 0 | 0 | | | |

2 | 17002 | 9 | 1 | 3.2e-05 | 3.2e-05 | 3.2e-05 | | | |

2 | 17002 | 10 | 0 | 0 | 0 | 0 | | | |

2 | 17002 | 11 | 0 | 0 | 0 | 0 | | | |

2 | 17002 | 12 | 0 | 0 | 0 | 0 | | | |

2 | 17002 | 13 | 1 | 0.000383 | 0.000383 | 0.000383 | | | |

2 | 17002 | 14 | 1 | 6.3e-05 | 6.3e-05 | 6.3e-05 | | | |

2 | 17002 | 15 | 1 | 3.6e-05 | 3.6e-05 | 3.6e-05 | | | |

2 | 17002 | 16 | 0 | 0 | 0 | 0 | | | |

2 | 17000 | 1 | 0 | 0 | 0 | 0 | | | |

2 | 17000 | 2 | 0 | 0 | 0 | 0 | | | |

2 | 17000 | 3 | 0 | 0 | 0 | 0 | | | |

2 | 17000 | 4 | 0 | 0 | 0 | 0 | | | |

2 | 17000 | 5 | 1 | 0.000647 | 0.000647 | 0.000647 | | | |

2 | 17000 | 6 | 1 | 2.6e-05 | 2.6e-05 | 2.6e-05 | | | |

2 | 17000 | 7 | 0 | 0 | 0 | 0 | | | |

2 | 17000 | 8 | 0 | 0 | 0 | 0 | | | |

2 | 17000 | 9 | 0 | 0 | 0 | 0 | | | |

2 | 17000 | 10 | 0 | 0 | 0 | 0 | | | |

2 | 17000 | 11 | 0 | 0 | 0 | 0 | | | |

2 | 17004 | 1 | 0 | 0 | 0 | 0 | | | |

2 | 17004 | 2 | 0 | 0 | 0 | 0 | | | |

2 | 17004 | 3 | 0 | 0 | 0 | 0 | | | |

2 | 17004 | 4 | 0 | 0 | 0 | 0 | | | |

2 | 17004 | 5 | 1 | 8.4e-05 | 8.4e-05 | 8.4e-05 | | | |

2 | 17004 | 6 | 0 | 0 | 0 | 0 | | | |

2 | 17004 | 7 | 0 | 0 | 0 | 0 | | | |

2 | 17004 | 8 | 0 | 0 | 0 | 0 | | | |

2 | 17004 | 9 | 0 | 0 | 0 | 0 | | | |

2 | 17004 | 10 | 1 | 0.000355 | 0.000355 | 0.000355 | | | |

2 | 17004 | 11 | 1 | 0.000177 | 0.000177 | 0.000177 | | | |

2 | 17004 | 12 | 1 | 5.5e-05 | 5.5e-05 | 5.5e-05 | | | |

2 | 17004 | 13 | 1 | 3.1e-05 | 3.1e-05 | 3.1e-05 | | | |

2 | 17004 | 14 | 1 | 2.8e-05 | 2.8e-05 | 2.8e-05 | | | |

2 | 17004 | 15 | 1 | 2.7e-05 | 2.7e-05 | 2.7e-05 | | | |

2 | 17004 | 16 | 1 | 1e-06 | 1e-06 | 1e-06 | | | |

2 | 17004 | 17 | 0 | 0 | 0 | 0 | | | |

2 | 17004 | 18 | 0 | 0 | 0 | 0 | | | |

2 | 17004 | 19 | 0 | 0 | 0 | 0 | | | |

2 | 17004 | 20 | 0 | 0 | 0 | 0 | | | |

2 | 17004 | 21 | 0 | 0 | 0 | 0 | | | |

2 | 17004 | 22 | 0 | 0 | 0 | 0 | | | |

2 | 17004 | 23 | 0 | 0 | 0 | 0 | | | |

(68 rows)

### DBMS\_PROFILER Functions and Procedures

The DBMS\_PROFILER package collects and stores performance information about the PL/pgSQL and SPL statements that are executed during a profiling session; use the functions and procedures listed below to control the profiling tool.

Table ‑ DBMS\_PROFILER Functions/Procedures

|                                                                     |                          |                          |                                                                                                                  |
| ------------------------------------------------------------------- | ------------------------ | ------------------------ | ---------------------------------------------------------------------------------------------------------------- |
| Function/Procedure                                                  | Function or Procedure    | Return Type              | Description                                                                                                      |
| FLUSH\_DATA                                                         | Function and Procedure   | Status Code or Exception | Flushes performance data collected in the current session without terminating the session (profiling continues). |
| GET\_VERSION (major OUT, minor OUT)                                 | Procedure                | n/a                      | Returns the version number of this package.                                                                      |
| INTERNAL\_VERSION\_CHECK                                            | Function                 | Status Code              | Confirms that the current version of the profiler will work with the current database.                           |
| PAUSE\_PROFILER                                                     | Function and Procedure   | Status Code or Exception | Pause data collection.                                                                                           |
| RESUME\_PROFILER                                                    | Function and Procedure   | Status Code or Exception | Resume data collection.                                                                                          |
| START\_PROFILER\[*run*\_*comment, run\_comment1, run\_number OUT\]* | Functions and Procedures | Status Code or Exception | Start data collection.                                                                                           |
| STOP\_PROFILER                                                      | Function and Procedure   | Status Code or Exception | Stop data collection and flush performance data to PLSQL\_PROFILER\_RAWDATA.                                     |

**Return Values**

The functions within the DBMS\_PROFILER package return a status code to indicate success or failure; the DBMS\_PROFILER procedures raise an exception only if they encounter a failure. The status codes and messages returned by the functions, and the exceptions raised by the procedures are listed in the table below.

| Status Code | Message       | Exception         | Description                                             |
| ----------- | ------------- | ----------------- | ------------------------------------------------------- |
| \-1         | error version | version\_mismatch | The profiler version and the database are incompatible. |
| 0           | success       | n/a               | The operation completed successfully.                   |
| 1           | error\_param  | profiler\_error   | The operation received an incorrect parameter.          |
| 2           | error\_io     | profiler\_error   | The data flush operation has failed.                    |

#### FLUSH\_DATA

The FLUSH\_DATA procedure or function flushes the data collected in the current session without terminating the profiler session. The data is flushed to the tables listed in Section 6.3 of the EDB Postgres Advanced Server Performance Features Guide. The signature of the FLUSH\_DATA function is:

DBMS\_PROFILER.FLUSH\_DATA
RETURN INTEGER;

The signature of the FLUSH\_DATA procedure is:

DBMS\_PROFILER.FLUSH\_DATA;

#### GET\_VERSION

The GET\_VERSION procedure returns the version of DBMS\_PROFILER. The procedure signature is:

DBMS\_PROFILER.GET\_VERSION( major OUT INTEGER

minor OUT INTEGER);

**Parameters**

major

The major version number of DBMS\_PROFILER.

minor

The minor version number of DBMS\_PROFILER.

#### INTERNAL\_VERSION\_CHECK

The INTERNAL\_VERSION\_CHECK function confirms that the current version of DBMS\_PROFILER will work with the current database. The function signature is:

DBMS\_PROFILER.INTERNAL\_VERSION\_CHECK
RETURN INTEGER;

#### PAUSE\_PROFILER

The PAUSE\_PROFILER function or procedure pauses a profiling session. The function signature is:

DBMS\_PROFILER.PAUSE\_PROFILER
RETURN INTEGER;

The signature of the PAUSE\_PROFILER procedure is:

DBMS\_PROFILER.PAUSE\_PROFILER;

#### RESUME\_PROFILER

The RESUME\_PROFILER function or procedure resumes a paused profiling session. The function signature is:

DBMS\_PROFILER.RESUME\_PROFILER
RETURN INTEGER;

The signature of the RESUME\_PROFILER procedure is:

DBMS\_PROFILER.RESUME\_PROFILER;

#### START\_PROFILER

The START\_PROFILER function or procedure starts a data collection session. The START\_PROFILER function has two forms:

DBMS\_PROFILER.START\_PROFILER(
*run\_comment* IN TEXT := sysdate,
*run\_comment1* IN TEXT := '',
*run\_number* OUT INTEGER)
RETURN INTEGER;

DBMS\_PROFILER.START\_PROFILER(
*run\_comment* IN TEXT := sysdate,
*run\_comment1* IN TEXT := '')
RETURN INTEGER;

The START\_PROFILER procedure has two forms:

DBMS\_PROFILER.START\_PROFILER (
*run\_comment* IN TEXT := sysdate,
*run\_comment1* IN TEXT := '');

DBMS\_PROFILER.START\_PROFILER (
*run\_comment* IN TEXT := sysdate,
*run\_comment1* IN TEXT := '',
*run\_number* OUT INTEGER);

**Parameters**

*run\_comment*

A user-defined comment for the profiler session; the default value is sysdate.

*run\_comment1*

An additional user-defined comment for the profiler session; the default value is ''.

*run\_number*

The session number of the profiler session.

#### STOP\_PROFILER

The STOP\_PROFILER function or procedure stops a profiling session and flushes the performance information to the DBMS\_PROFILER tables and view. The STOP\_PROFILER function signature is:

DBMS\_PROFILER.STOP\_PROFILER;

RETURN INTEGER;

The signature of the START\_PROFILER procedure is:

DBMS\_PROFILER.STOP\_PROFILER;

### DBMS\_PROFILER - Reference

The Advanced Server installer creates the following tables and views that you can query to review PL/SQL performance profile information:

| Table Name               | Description                                                                                                          |
| ------------------------ | -------------------------------------------------------------------------------------------------------------------- |
| PLSQL\_PROFILER\_RUNS    | Table containing information about all profiler runs, organized by runid.                                            |
| PLSQL\_PROFILER\_UNITS   | Table containing information about all profiler runs, organized by unit.                                             |
| PLSQL\_PROFILER\_DATA    | View containing performance statistics.                                                                              |
| PLSQL\_PROFILER\_RAWDATA | Table containing the performance statistics *and* the extended performance statistics for DRITA counters and timers. |

#### PLSQL\_PROFILER\_RUNS

The PLSQL\_PROFILER\_RUNS table contains the following columns:

| Column            | Data Type                   | Description                                    |
| ----------------- | --------------------------- | ---------------------------------------------- |
| runid             | INTEGER (NOT NULL)          | Unique identifier (plsql\_profiler\_runnumber) |
| related\_run      | INTEGER                     | The runid of a related run.                    |
| run\_owner        | TEXT                        | The role that recorded the profiling session.  |
| run\_date         | TIMESTAMP WITHOUT TIME ZONE | The profiling session start time.              |
| run\_comment      | TEXT                        | User comments relevant to this run             |
| run\_total\_time  | BIGINT                      | Run time (in nanoseconds)                      |
| run\_system\_info | TEXT                        | Currently Unused                               |
| run\_comment1     | TEXT                        | Additional user comments                       |
| spare1            | TEXT                        | Currently Unused                               |

#### PLSQL\_PROFILER\_UNITS

The PLSQL\_PROFILER\_UNITS table contains the following columns:

| Column          | Data Type                   | Description                                                                       |
| --------------- | --------------------------- | --------------------------------------------------------------------------------- |
| runid           | INTEGER                     | Unique identifier (plsql\_profiler\_runnumber)                                    |
| unit\_number    | OID                         | Corresponds to the OID of the row in the pg\_proc table that identifies the unit. |
| unit\_type      | TEXT                        | PL/SQL function, procedure, trigger or anonymous block                            |
| unit\_owner     | TEXT                        | The identity of the role that owns the unit.                                      |
| unit\_name      | TEXT                        | The complete signature of the unit.                                               |
| unit\_timestamp | TIMESTAMP WITHOUT TIME ZONE | Creation date of the unit (currently NULL).                                       |
| total\_time     | BIGINT                      | Time spent within the unit (in nanoseconds)                                       |
| spare1          | BIGINT                      | Currently Unused                                                                  |
| spare2          | BIGINT                      | Currently Unused                                                                  |

#### PLSQL\_PROFILER\_DATA

The PLSQL\_PROFILER\_DATA view contains the following columns:

| Column       | Data Type        | Description                                           |
| ------------ | ---------------- | ----------------------------------------------------- |
| runid        | INTEGER          | Unique identifier (plsql\_profiler\_runnumber)        |
| unit\_number | OID              | Object ID of the unit that contains the current line. |
| line\#       | INTEGER          | Current line number of the profiled workload.         |
| total\_occur | BIGINT           | The number of times that the line was executed.       |
| total\_time  | DOUBLE PRECISION | The amount of time spent executing the line.          |
| min\_time    | DOUBLE PRECISION | The minimum execution time for the line.              |
| max\_time    | DOUBLE PRECISION | The maximum execution time for the line.              |
| spare1       | NUMBER           | Currently Unused                                      |
| spare2       | NUMBER           | Currently Unused                                      |
| spare3       | NUMBER           | Currently Unused                                      |
| spare4       | NUMBER           | Currently Unused                                      |

#### PLSQL\_PROFILER\_RAWDATA

The PLSQL\_PROFILER\_RAWDATA table contains the statistical information that is found in the PLSQL\_PROFILER\_DATA view, as well as the performance statistics returned by the DRITA counters and timers.

| Column                                       | Data Type        | Description                                                                                                                                                                                                                                   |
| -------------------------------------------- | ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| runid                                        | INTEGER          | The run identifier (plsql\_profiler\_runnumber).                                                                                                                                                                                              |
| sourcecode                                   | TEXT             | The individual line of profiled code.                                                                                                                                                                                                         |
| func\_oid                                    | OID              | Object ID of the unit that contains the current line.                                                                                                                                                                                         |
| line\_number                                 | INTEGER          | Current line number of the profiled workload.                                                                                                                                                                                                 |
| exec\_count                                  | BIGINT           | The number of times that the line was executed.                                                                                                                                                                                               |
| time\_total                                  | DOUBLE PRECISION | The amount of time spent executing the line.                                                                                                                                                                                                  |
| time\_shortest                               | DOUBLE PRECISION | The minimum execution time for the line.                                                                                                                                                                                                      |
| time\_longest                                | DOUBLE PRECISION | The maximum execution time for the line.                                                                                                                                                                                                      |
| tuples\_returned                             | BIGINT           | Currently Unused                                                                                                                                                                                                                              |
| num\_scans                                   | BIGINT           | Currently Unused                                                                                                                                                                                                                              |
| tuples\_fetched                              | BIGINT           | Currently Unused                                                                                                                                                                                                                              |
| tuples\_inserted                             | BIGINT           | Currently Unused                                                                                                                                                                                                                              |
| tuples\_updated                              | BIGINT           | Currently Unused                                                                                                                                                                                                                              |
| tuples\_deleted                              | BIGINT           | Currently Unused                                                                                                                                                                                                                              |
| blocks\_fetched                              | BIGINT           | Currently Unused                                                                                                                                                                                                                              |
| blocks\_hit                                  | BIGINT           | Currently Unused                                                                                                                                                                                                                              |
| wal\_write                                   | BIGINT           | The server has waited for a write to the write-ahead log buffer (expect this value to be high).                                                                                                                                               |
| wal\_flush                                   | BIGINT           | The server has waited for the write-ahead log to flush to disk.                                                                                                                                                                               |
| wal\_file\_sync                              | BIGINT           | The server has waited for the write-ahead log to sync to disk (related to the wal\_sync\_method parameter which, by default, is 'fsync' - better performance can be gained by changing this parameter to open\_sync).                         |
| buffer\_free\_list\_lock\_acquire            | BIGINT           | The server has waited for the short-term lock that synchronizes access to the list of free buffers (in shared memory).                                                                                                                        |
| shmem\_index\_lock\_acquire                  | BIGINT           | The server has waited for the short-term lock that synchronizes access to the shared-memory map.                                                                                                                                              |
| oid\_gen\_lock\_acquire                      | BIGINT           | The server has waited for the short-term lock that synchronizes access to the next available OID (object ID).                                                                                                                                 |
| xid\_gen\_lock\_acquire                      | BIGINT           | The server has waited for the short-term lock that synchronizes access to the next available transaction ID.                                                                                                                                  |
| proc\_array\_lock\_acquire                   | BIGINT           | The server has waited for the short-term lock that synchronizes access to the process array                                                                                                                                                   |
| sinval\_lock\_acquire                        | BIGINT           | The server has waited for the short-term lock that synchronizes access to the cache invalidation state.                                                                                                                                       |
| freespace\_lock\_acquire                     | BIGINT           | The server has waited for the short-term lock that synchronizes access to the freespace map.                                                                                                                                                  |
| wal\_insert\_lock\_acquire                   | BIGINT           | The server has waited for the short-term lock that synchronizes write access to the write-ahead log. A high number may indicate that WAL buffers are sized too small.                                                                         |
| wal\_write\_lock\_acquire                    | BIGINT           | The server has waited for the short-term lock that synchronizes write-ahead log flushes.                                                                                                                                                      |
| control\_file\_lock\_acquire                 | BIGINT           | The server has waited for the short-term lock that synchronizes write access to the control file (this should usually be a low number).                                                                                                       |
| checkpoint\_lock\_acquire                    | BIGINT           | A server process has waited for the short-term lock that prevents simultaneous checkpoints.                                                                                                                                                   |
| clog\_control\_lock\_acquire                 | BIGINT           | The server has waited for the short-term lock that synchronizes access to the commit log.                                                                                                                                                     |
| subtrans\_control\_lock\_acquire             | BIGINT           | The server has waited for the short-term lock that synchronizes access to the subtransaction log.                                                                                                                                             |
| multi\_xact\_gen\_lock\_acquire              | BIGINT           | The server has waited for the short-term lock that synchronizes access to the next available multi-transaction ID (when a SELECT...FOR SHARE statement executes).                                                                             |
| multi\_xact\_offset\_lock\_acquire           | BIGINT           | The server has waited for the short-term lock that synchronizes access to the multi-transaction offset file (when a SELECT...FOR SHARE statement executes).                                                                                   |
| multi\_xact\_member\_lock\_acquire           | BIGINT           | The server has waited for the short-term lock that synchronizes access to the multi-transaction member file (when a SELECT...FOR SHARE statement executes).                                                                                   |
| rel\_cache\_init\_lock\_acquire              | BIGINT           | The server has waited for the short-term lock that prevents simultaneous relation-cache loads/unloads.                                                                                                                                        |
| bgwriter\_communication\_lock\_acquire       | BIGINT           | The bgwriter (background writer) process has waited for the short-term lock that synchronizes messages between the bgwriter and a backend process.                                                                                            |
| two\_phase\_state\_lock\_acquire             | BIGINT           | The server has waited for the short-term lock that synchronizes access to the list of prepared transactions.                                                                                                                                  |
| tablespace\_create\_lock\_acquire            | BIGINT           | The server has waited for the short-term lock that prevents simultaneous CREATE TABLESPACE or DROP TABLESPACE commands.                                                                                                                       |
| btree\_vacuum\_lock\_acquire                 | BIGINT           | The server has waited for the short-term lock that synchronizes access to the next available vacuum cycle ID.                                                                                                                                 |
| add\_in\_shmem\_lock\_acquire                | BIGINT           | Currently Unused                                                                                                                                                                                                                              |
| autovacuum\_lock\_acquire                    | BIGINT           | The server has waited for the short-term lock that synchronizes access to the shared autovacuum state.                                                                                                                                        |
| autovacuum\_schedule\_lock\_acquire          | BIGINT           | The server has waited for the short-term lock that synchronizes access to the autovacuum schedule.                                                                                                                                            |
| syncscan\_lock\_acquire                      | BIGINT           | The server has waited for the short-term lock that coordinates synchronous scans.                                                                                                                                                             |
| icache\_lock\_acquire                        | BIGINT           | The server has waited for the short-term lock that synchronizes access to InfiniteCache state                                                                                                                                                 |
| breakpoint\_lock\_acquire                    | BIGINT           | The server has waited for the short-term lock that synchronizes access to the debugger breakpoint list.                                                                                                                                       |
| lwlock\_acquire                              | BIGINT           | The server has waited for a short-term lock that has not been described elsewhere in this section.                                                                                                                                            |
| db\_file\_read                               | BIGINT           | A server process has waited for the completion of a read (from disk).                                                                                                                                                                         |
| db\_file\_write                              | BIGINT           | A server process has waited for the completion of a write (to disk).                                                                                                                                                                          |
| db\_file\_sync                               | BIGINT           | A server process has waited for the operating system to flush all changes to disk.                                                                                                                                                            |
| db\_file\_extend                             | BIGINT           | A server process has waited for the operating system while adding a new page to the end of a file.                                                                                                                                            |
| sql\_parse                                   | BIGINT           | Currently Unused                                                                                                                                                                                                                              |
| query\_plan                                  | BIGINT           | The server has generated a query plan.                                                                                                                                                                                                        |
| infinitecache\_read                          | BIGINT           | The server has waited for an Infinite Cache read request.                                                                                                                                                                                     |
| infinitecache\_write                         | BIGINT           | The server has waited for an Infinite Cache write request.                                                                                                                                                                                    |
| wal\_write\_time                             | BIGINT           | The amount of time that the server has waited for a write to the write-ahead log buffer (expect this value to be high).                                                                                                                       |
| wal\_flush\_time                             | BIGINT           | The amount of time that the server has waited for the write-ahead log to flush to disk.                                                                                                                                                       |
| wal\_file\_sync\_time                        | BIGINT           | The amount of time that the server has waited for the write-ahead log to sync to disk (related to the wal\_sync\_method parameter which, by default, is 'fsync' - better performance can be gained by changing this parameter to open\_sync). |
| buffer\_free\_list\_lock\_acquire\_time      | BIGINT           | The amount of time that the server has waited for the short-term lock that synchronizes access to the list of free buffers (in shared memory).                                                                                                |
| shmem\_index\_lock\_acquire\_time            | BIGINT           | The amount of time that the server has waited for the short-term lock that synchronizes access to the shared-memory map.                                                                                                                      |
| oid\_gen\_lock\_acquire\_time                | BIGINT           | The amount of time that the server has waited for the short-term lock that synchronizes access to the next available OID (object ID).                                                                                                         |
| xid\_gen\_lock\_acquire\_time                | BIGINT           | The amount of time that the server has waited for the short-term lock that synchronizes access to the next available transaction ID.                                                                                                          |
| proc\_array\_lock\_acquire\_time             | BIGINT           | The amount of time that the server has waited for the short-term lock that synchronizes access to the process array.                                                                                                                          |
| sinval\_lock\_acquire\_time                  | BIGINT           | The amount of time that the server has waited for the short-term lock that synchronizes access to the cache invalidation state.                                                                                                               |
| freespace\_lock\_acquire\_time               | BIGINT           | The amount of time that the server has waited for the short-term lock that synchronizes access to the freespace map.                                                                                                                          |
| wal\_insert\_lock\_acquire\_time             | BIGINT           | The amount of time that the server has waited for the short-term lock that synchronizes write access to the write-ahead log. A high number may indicate that WAL buffers are sized too small.                                                 |
| wal\_write\_lock\_acquire\_time              | BIGINT           | The amount of time that the server has waited for the short-term lock that synchronizes write-ahead log flushes.                                                                                                                              |
| control\_file\_lock\_acquire\_time           | BIGINT           | The amount of time that the server has waited for the short-term lock that synchronizes write access to the control file (this should usually be a low number).                                                                               |
| checkpoint\_lock\_acquire\_time              | BIGINT           | The amount of time that the server process has waited for the short-term lock that prevents simultaneous checkpoints.                                                                                                                         |
| clog\_control\_lock\_acquire\_time           | BIGINT           | The amount of time that the server has waited for the short-term lock that synchronizes access to the commit log.                                                                                                                             |
| subtrans\_control\_lock\_acquire\_time       | BIGINT           | The amount of time that the server has waited for the short-term lock that synchronizes access to the subtransaction log.                                                                                                                     |
| multi\_xact\_gen\_lock\_acquire\_time        | BIGINT           | The amount of time that the server has waited for the short-term lock that synchronizes access to the next available multi-transaction ID (when a SELECT...FOR SHARE statement executes).                                                     |
| multi\_xact\_offset\_lock\_acquire\_time     | BIGINT           | The amount of time that the server has waited for the short-term lock that synchronizes access to the multi-transaction offset file (when a SELECT...FOR SHARE statement executes).                                                           |
| multi\_xact\_member\_lock\_acquire\_time     | BIGINT           | The amount of time that the server has waited for the short-term lock that synchronizes access to the multi-transaction member file (when a SELECT...FOR SHARE statement executes).                                                           |
| rel\_cache\_init\_lock\_acquire\_time        | BIGINT           | The amount of time that the server has waited for the short-term lock that prevents simultaneous relation-cache loads/unloads.                                                                                                                |
| bgwriter\_communication\_lock\_acquire\_time | BIGINT           | The amount of time that the bgwriter (background writer) process has waited for the short-term lock that synchronizes messages between the bgwriter and a backend process.                                                                    |
| two\_phase\_state\_lock\_acquire\_time       | BIGINT           | The amount of time that the server has waited for the short-term lock that synchronizes access to the list of prepared transactions.                                                                                                          |
| tablespace\_create\_lock\_acquire\_time      | BIGINT           | The amount of time that the server has waited for the short-term lock that prevents simultaneous CREATE TABLESPACE or DROP TABLESPACE commands.                                                                                               |
| btree\_vacuum\_lock\_acquire\_time           | BIGINT           | The amount of time that the server has waited for the short-term lock that synchronizes access to the next available vacuum cycle ID.                                                                                                         |
| add\_in\_shmem\_lock\_acquire\_time          | BIGINT           | Obsolete/unused                                                                                                                                                                                                                               |
| autovacuum\_lock\_acquire\_time              | BIGINT           | The amount of time that the server has waited for the short-term lock that synchronizes access to the shared autovacuum state.                                                                                                                |
| autovacuum\_schedule\_lock\_acquire\_time    | BIGINT           | The amount of time that the server has waited for the short-term lock that synchronizes access to the autovacuum schedule.                                                                                                                    |
| syncscan\_lock\_acquire\_time                | BIGINT           | The amount of time that the server has waited for the short-term lock that coordinates synchronous scans.                                                                                                                                     |
| icache\_lock\_acquire\_time                  | BIGINT           | The amount of time that the server has waited for the short-term lock that synchronizes access to InfiniteCache state                                                                                                                         |
| breakpoint\_lock\_acquire\_time              | BIGINT           | The amount of time that the server has waited for the short-term lock that synchronizes access to the debugger breakpoint list.                                                                                                               |
| lwlock\_acquire\_time                        | BIGINT           | The amount of time that the server has waited for a short-term lock that has not been described elsewhere in this section.                                                                                                                    |
| db\_file\_read\_time                         | BIGINT           | The amount of time that the server process has waited for the completion of a read (from disk).                                                                                                                                               |
| db\_file\_write\_time                        | BIGINT           | The amount of time that the server process has waited for the completion of a write (to disk).                                                                                                                                                |
| db\_file\_sync\_time                         | BIGINT           | The amount of time that the server process has waited for the operating system to flush all changes to disk.                                                                                                                                  |
| db\_file\_extend\_time                       | BIGINT           | The amount of time that the server process has waited for the operating system while adding a new page to the end of a file.                                                                                                                  |
| sql\_parse\_time                             | BIGINT           | The amount of time that the server has parsed a SQL statement.                                                                                                                                                                                |
| query\_plan\_time                            | BIGINT           | The amount of time that the server has computed the execution plan for a SQL statement.                                                                                                                                                       |
| infinitecache\_read\_time                    | BIGINT           | The amount of time that the server has waited for an Infinite Cache read request.                                                                                                                                                             |
| infinitecache\_write\_time                   | BIGINT           | The amount of time that the server has waited for an Infinite Cache write request.                                                                                                                                                            |
| totalwaits                                   | BIGINT           | The total number of event waits.                                                                                                                                                                                                              |
| totalwaittime                                | BIGINT           | The total time spent waiting for an event.                                                                                                                                                                                                    |

## Dynamic Runtime Instrumentation Tools Architecture (DRITA)

The Dynamic Runtime Instrumentation Tools Architecture (DRITA) allows a DBA to query catalog views to determine the *wait events* that affect the performance of individual sessions or the system as a whole. DRITA records the number of times each event occurs as well as the time spent waiting; you can use this information to diagnose performance problems. DRITA offers this functionality, while consuming minimal system resources.

DRITA compares *snapshots* to evaluate the performance of a system. A snapshot is a saved set of system performance data at a given point in time. Each snapshot is identified by a unique ID number; you can use snapshot ID numbers with DRITA reporting functions to return system performance statistics.

### Configuring and Using DRITA

Advanced Server's postgresql.conf file includes a configuration parameter named timed\_statistics that controls the collection of timing data. The valid parameter values are TRUE or FALSE; the default value is FALSE.

This is a dynamic parameter which can be modified in the postgresql.conf file, or while a session is in progress. To enable DRITA, you must either:

> Modify the postgresql.conf file, setting the timed\_statistics parameter to TRUE.
>
> or
>
> Connect to the server with the EDB-PSQL client, and invoke the command:
>
> SET timed\_statistics = TRUE

After modifying the timed\_statistics parameter, take a starting snapshot. A snapshot captures the current state of each timer and event counter. The server will compare the starting snapshot to a later snapshot to gauge system performance.

Use the edbsnap() function to take the beginning snapshot:

edb=\# SELECT \* FROM edbsnap();

edbsnap

\----------------------

Statement processed.

(1 row)

Then, run the workload that you would like to evaluate; when the workload has completed (or at a strategic point during the workload), take another snapshot:

edb=\# SELECT \* FROM edbsnap();

edbsnap

\----------------------

Statement processed.

(1 row)

You can capture multiple snapshots during a session. Then, use the DRITA functions and reports to manage and compare the snapshots to evaluate performance information.

## DRITA Functions

You can use DRITA functions to gather wait information and manage snapshots. DRITA functions are fully supported by Advanced Server 9.5 whether your installation is made compatible with Oracle databases or is made in PostgreSQL-compatible mode.

### get\_snaps()

The get\_snaps() function returns a list of the current snapshots. The signature is:

> get\_snaps()

The following example demonstrates using the get\_snaps() function to display a list of snapshots:

edb=\# SELECT \* FROM get\_snaps();

get\_snaps

\------------------------------

1 11-FEB-10 10:41:05.668852

2 11-FEB-10 10:42:27.26154

3 11-FEB-10 10:45:48.999992

4 11-FEB-10 11:01:58.345163

5 11-FEB-10 11:05:14.092683

6 11-FEB-10 11:06:33.151002

7 11-FEB-10 11:11:16.405664

8 11-FEB-10 11:13:29.458405

9 11-FEB-10 11:23:57.595916

10 11-FEB-10 11:29:02.214014

11 11-FEB-10 11:31:44.244038

(11 rows)

The first column in the result list displays the snapshot identifier; the second column displays the date and time that the snapshot was captured.

### sys\_rpt()

The sys\_rpt() function returns system wait information. The signature is:

> sys\_rpt(*beginning\_id*, *ending\_id*, *top\_n*)

Parameters

*beginning*\_*id*

*beginning*\_*id* is an integer value that represents the beginning session identifier.

*ending*\_*id*

*ending*\_*id* is an integer value that represents the ending session identifier.

*top\_n*

*top\_n* represents the number of rows to return

This example demonstrates a call to the sys\_rpt()function:

edb=\# SELECT \* FROM sys\_rpt(9, 10, 10);

sys\_rpt

\-----------------------------------------------------------------------------

WAIT NAME COUNT WAIT TIME % WAIT

\---------------------------------------------------------------------------

wal write 21250 104.723772 36.31

db file read 121407 72.143274 25.01

wal flush 84185 51.652495 17.91

wal file sync 712 29.482206 10.22

infinitecache write 84178 15.814444 5.48

db file write 84177 14.447718 5.01

infinitecache read 672 0.098691 0.03

db file extend 190 0.040386 0.01

query plan 52 0.024400 0.01

wal insert lock acquire 4 0.000837 0.00

(12 rows)

The information displayed in the result set includes:

|             |                                                                           |
| ----------- | ------------------------------------------------------------------------- |
| Column Name | Description                                                               |
| WAIT NAME   | The name of the wait.                                                     |
| COUNT       | The number of times that the wait event occurred.                         |
| WAIT TIME   | The time of the wait event in milliseconds.                               |
| % WAIT      | The percentage of the total wait time used by this wait for this session. |

### sess\_rpt()

The sess\_rpt() function returns session wait information. The signature is:

> sess\_rpt(*beginning\_id*, *ending\_id, top\_n*)

Parameters

*beginning*\_*id*

*beginning\_id* is an integer value that represents the beginning session identifier.

*ending\_id*

*ending\_id* is an integer value that represents the ending session identifier.

*top\_n*

*top\_n* represents the number of rows to return

The following example demonstrates a call to the sess\_rpt()function:

SELECT \* FROM sess\_rpt(18, 19, 10);

sess\_rpt

\-----------------------------------------------------------------------------

ID USER WAIT NAME COUNT TIME(ms) %WAIT SES %WAIT ALL

\----------------------------------------------------------------------------

17373 enterprise db file read 30 0.175713 85.24 85.24

17373 enterprise query plan 18 0.014930 7.24 7.24

17373 enterprise wal flush 6 0.004067 1.97 1.97

17373 enterprise wal write 1 0.004063 1.97 1.97

17373 enterprise wal file sync 1 0.003664 1.78 1.78

17373 enterprise infinitecache read 38 0.003076 1.49 1.49

17373 enterprise infinitecache write 5 0.000548 0.27 0.27

17373 enterprise db file extend 190 0.04.386 0.03 0.03

17373 enterprise db file write 5 0.000082 0.04 0.04

(11 rows)

The information displayed in the result set includes:

|             |                                                                             |
| ----------- | --------------------------------------------------------------------------- |
| Column Name | Description                                                                 |
| ID          | The processID of the session.                                               |
| USER        | The name of the user incurring the wait.                                    |
| WAIT NAME   | The name of the wait event.                                                 |
| COUNT       | The number of times that the wait event occurred.                           |
| TIME (ms)   | The length of the wait event in milliseconds.                               |
| % WAIT SES  | The percentage of the total wait time used by this wait for this session.   |
| % WAIT ALL  | The percentage of the total wait time used by this wait (for all sessions). |

### sessid\_rpt()

The sessid\_rpt() function returns session ID information for a specified backend. The signature is:

> sessid\_rpt(*beginning\_id*, *ending\_id, backend\_id*)

Parameters

*beginning\_id*

*beginning\_id* is an integer value that represents the beginning session identifier.

*ending\_id*

*ending\_id* is an integer value that represents the ending session identifier.

*backend\_id*

*backend\_id* is an integer value that represents the backend identifier.

The following code sample demonstrates a call to sessid\_rpt():

SELECT \* FROM sessid\_rpt(18, 19, 17373);

sessid\_rpt

\-----------------------------------------------------------------------------

ID USER WAIT NAME COUNT TIME(ms) %WAIT SES %WAIT ALL

\----------------------------------------------------------------------------

17373 enterprise db file read 30 0.175713 85.24 85.24

17373 enterprise query plan 18 0.014930 7.24 7.24

17373 enterprise wal flush 6 0.004067 1.97 1.97

17373 enterprise wal write 1 0.004063 1.97 1.97

17373 enterprise wal file sync 1 0.003664 1.78 1.78

17373 enterprise infinitecache read 38 0.003076 1.49 1.49

17373 enterprise infinitecache write 5 0.000548 0.27 0.27

17373 enterprise db file extend 190 0.040386 0.03 0.03

17373 enterprise db file write 5 0.000082 0.04 0.04

(11 rows)

The information displayed in the result set includes:

|             |                                                                             |
| ----------- | --------------------------------------------------------------------------- |
| Column Name | Description                                                                 |
| ID          | The process ID of the wait.                                                 |
| USER        | The name of the user that owns the session.                                 |
| WAIT NAME   | The name of the wait event.                                                 |
| COUNT       | The number of times that the wait event occurred.                           |
| TIME (ms)   | The length of the wait in milliseconds.                                     |
| % WAIT SES  | The percentage of the total wait time used by this wait for this session.   |
| % WAIT ALL  | The percentage of the total wait time used by this wait (for all sessions). |

### sesshist\_rpt()

The sesshist\_rpt() function returns session wait information for a specified backend. The signature is:

> sesshist\_rpt(*snapshot\_id*, *session\_id*)

Parameters

*snapshot\_id*

*snapshot\_id* is an integer value that identifies the snapshot.

*session\_id*

*session\_id* is an integer value that represents the session.

The following example demonstrates a call to the sesshist\_rpt()function:

edb=\# SELECT \* FROM sesshist\_rpt (9, 5531);

sesshist\_rpt

\----------------------------------------------------------------------------

ID USER SEQ WAIT NAME

ELAPSED(ms) File Name \# of Blk Sum of Blks

\----------------------------------------------------------------------------

5531 enterprise 1 db file read

18546 14309 session\_waits\_pk 1 1

5531 enterprise 2 infinitecache read

125 14309 session\_waits\_pk 1 1

5531 enterprise 3 db file read

376 14304 edb$session\_waits 0 1

5531 enterprise 4 infinitecache read

166 14304 edb$session\_waits 0 1

5531 enterprise 5 db file read

7978 1260 pg\_authid 0 1

5531 enterprise 6 infinitecache read

154 1260 pg\_authid 0 1

5531 enterprise 7 db file read

628 14302 system\_waits\_pk 1 1

5531 enterprise 8 infinitecache read

463 14302 system\_waits\_pk 1 1

5531 enterprise 9 db file read

3446 14297 edb$system\_waits 0 1

5531 enterprise 10 infinitecache read

187 14297 edb$system\_waits 0 1

5531 enterprise 11 db file read

14750 14295 snap\_pk 1 1

5531 enterprise 12 infinitecache read

416 14295 snap\_pk 1 1

5531 enterprise 13 db file read

7139 14290 edb$snap 0 1

5531 enterprise 14 infinitecache read

158 14290 edb$snap 0 1

5531 enterprise 15 db file read

27287 14288 snapshot\_num\_seq 0 1

5531 enterprise 16 infinitecache read

(17 rows)

The information displayed in the result set includes:

|              |                                                                         |
| ------------ | ----------------------------------------------------------------------- |
| Column Name  | Description                                                             |
| ID           | The system-assigned identifier of the wait.                             |
| USER         | The name of the user that incurred the wait.                            |
| SEQ          | The sequence number of the wait event.                                  |
| WAIT NAME    | The name of the wait event.                                             |
| ELAPSED (ms) | The length of the wait event in milliseconds.                           |
| File         | The relfilenode number of the file.                                     |
| Name         | If available, the name of the file name related to the wait event.      |
| \# of Blk    | The block number read or written for a specific instance of the event . |
| Sum of Blks  | The number of blocks read.                                              |

### purgesnap()

The purgesnap() function purges a range of snapshots from the snapshot tables. The signature is:

> purgesnap(*beginning\_id*, *ending\_id*)

Parameters

*beginning*\_*id*

*beginning*\_*id* is an integer value that represents the beginning session identifier.

*ending*\_*id*

*ending*\_*id* is an integer value that represents the ending session identifier.

purgesnap()removes all snapshots between *beginning*\_*id* and *ending\_id* (inclusive):

SELECT \* FROM purgesnap(6, 9);

purgesnap

\------------------------------------

Snapshots in range 6 to 9 deleted.

(1 row)

A call to the get\_snaps() function after executing the example shows that snapshots 6 through 9 have been purged from the snapshot tables:

edb=\# SELECT \* FROM get\_snaps();

get\_snaps

\------------------------------

1 11-FEB-10 10:41:05.668852

2 11-FEB-10 10:42:27.26154

3 11-FEB-10 10:45:48.999992

4 11-FEB-10 11:01:58.345163

5 11-FEB-10 11:05:14.092683

10 11-FEB-10 11:29:02.214014

11 11-FEB-10 11:31:44.244038

(7 rows)

### truncsnap()

Use the truncsnap() function to delete all records from the snapshot table. The signature is:

> truncsnap()

For example:

SELECT \* FROM truncsnap();

truncsnap

\----------------------

Snapshots truncated.

(1 row)

A call to the get\_snaps() function after calling the truncsnap() function shows that all records have been removed from the snapshot tables:

SELECT \* FROM get\_snaps();

get\_snaps

\-----------

(0 rows)

## Simulating Statspack AWR Reports

The functions described in this section return information comparable to the information contained in an Oracle Statspack/AWR (Automatic Workload Repository) report. When taking a snapshot, performance data from system catalog tables is saved into history tables. The reporting functions listed below report on the differences between two given snapshots.
 - stat\_db\_rpt()
 - stat\_tables\_rpt()
 - statio\_tables\_rpt()
 - stat\_indexes\_rpt()
 - statio\_indexes\_rpt()

The reporting functions can be executed individually or you can execute all five functions by calling the edbreport() function.

### edbreport()

The edbreport() function includes data from the other reporting functions, plus additional system information. The signature is:

> edbreport(beginning\_id, ending\_id)

Parameters

beginning\_id

beginning\_id is an integer value that represents the beginning session identifier.

ending\_id

ending\_id is an integer value that represents the ending session identifier.

The call to the edbreport() function returns a composite report that contains system information and the reports returned by the other statspack functions. :

edb=\# SELECT \* FROM edbreport(9, 10);

edbreport

\-----------------------------------------------------------------------------

EnterpriseDB Report for database edb 23-AUG-15

Version: EnterpriseDB 9.5.0.0 on i686-pc-linux-gnu

Begin snapshot: 9 at 23-AUG-15 13:45:07.165123

End snapshot: 10 at 23-AUG-15 13:45:35.653036

Size of database edb is 155 MB

Tablespace: pg\_default Size: 179 MB Owner: enterprisedb

Tablespace: pg\_global Size: 435 kB Owner: enterprisedb

Schema: pg\_toast\_temp\_1 Size: 0 bytes Owner: enterprisedb

Schema: public Size: 0 bytes Owner: enterprisedb

Schema: enterprisedb Size: 143 MB Owner: enterprisedb

Schema: pgagent Size: 192 kB Owner: enterprisedb

Schema: dbms\_job\_procedure Size: 0 bytes Owner: enterprisedb

The information displayed in the report introduction includes the database name and version, the current date, the beginning and ending snapshot date and times, database and tablespace details and schema information.

Top 10 Relations by pages

TABLE RELPAGES

\----------------------------------------------------------------------------

pgbench\_accounts 15874

pg\_proc 102

edb$statio\_all\_indexes 73

edb$stat\_all\_indexes 73

pg\_attribute 67

pg\_depend 58

edb$statio\_all\_tables 49

edb$stat\_all\_tables 47

pgbench\_tellers 37

pg\_description 32

The information displayed in the Top 10 Relations by pages section includes:

|             |                                   |
| ----------- | --------------------------------- |
| Column Name | Description                       |
| TABLE       | The name of the table.            |
| RELPAGES    | The number of pages in the table. |

Top 10 Indexes by pages

INDEX RELPAGES

\----------------------------------------------------------------------------

pgbench\_accounts\_pkey 2198

pg\_depend\_depender\_index 32

pg\_depend\_reference\_index 31

pg\_proc\_proname\_args\_nsp\_index 30

pg\_attribute\_relid\_attnam\_index 23

pg\_attribute\_relid\_attnum\_index 17

pg\_description\_o\_c\_o\_index 15

edb$statio\_idx\_pk 11

edb$stat\_idx\_pk 11

pg\_proc\_oid\_index 9

The information displayed in the Top 10 Indexes by pages section includes:

|             |                                   |
| ----------- | --------------------------------- |
| Column Name | Description                       |
| INDEX       | The name of the index.            |
| RELPAGES    | The number of pages in the index. |

Top 10 Relations by DML

SCHEMA RELATION UPDATES DELETES INSERTS

\---------------------------------------------------------------------------

enterprisedb pgbench\_accounts 10400 0 1000000

enterprisedb pgbench\_tellers 10400 0 100

enterprisedb pgbench\_branches 10400 0 10

enterprisedb pgbench\_history 0 0 10400

pgagent pga\_jobclass 0 0 6

pgagent pga\_exception 0 0 0

pgagent pga\_job 0 0 0

pgagent pga\_jobagent 0 0 0

pgagent pga\_joblog 0 0 0

pgagent pga\_jobstep 0 0 0

The information displayed in the Top 10 Relations by DML section includes:

|             |                                                    |
| ----------- | -------------------------------------------------- |
| Column Name | Description                                        |
| SCHEMA      | The name of the schema in which the table resides. |
| RELATION    | The name of the table.                             |
| UPDATES     | The number of UPDATES performed on the table.      |
| DELETES     | The number of DELETES performed on the table.      |
| INSERTS     | The number of INSERTS performed on the table.      |

DATA from pg\_stat\_database

DATABASE NUMBACKENDS XACT COMMIT XACT ROLLBACK BLKS READ BLKS HIT BLKS ICACHE HIT HIT RATIO ICACHE HIT RATIO

\----------------------------------------------------------------------------

edb 0 142 0 78 10446
0 99.26 0.00

DATA from pg\_buffercache not included because pg\_buffercache is not installed

The information displayed in the DATA from pg\_stat\_database section of the report includes:

|                  |                                                                                                                                                                                                                    |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Column Name      | Description                                                                                                                                                                                                        |
| DATABASE         | The name of the database.                                                                                                                                                                                          |
| NUMBACKENDS      | Number of backends currently connected to this database. This is the only column in this view that returns a value reflecting current state; all other columns return the accumulated values since the last reset. |
| XACT COMMIT      | Number of transactions in this database that have been committed.                                                                                                                                                  |
| XACT ROLLBACK    | Number of transactions in this database that have been rolled back.                                                                                                                                                |
| BLKS READ        | Number of disk blocks read in this database.                                                                                                                                                                       |
| BLKS HIT         | Number of times disk blocks were found already in the buffer cache (when a read was not necessary).                                                                                                                |
| BLKS ICACHE HIT  | The number of blocks found in Infinite Cache.                                                                                                                                                                      |
| HIT RATIO        | The percentage of times that a block was found in the shared buffer cache.                                                                                                                                         |
| ICACHE HIT RATIO | The percentage of times that a block was found in Infinite Cache.                                                                                                                                                  |

DATA from pg\_stat\_all\_tables ordered by seq scan

SCHEMA RELATION SEQ SCAN REL TUP READ IDX SCAN IDX TUP READ INS UPD DEL

\----------------------------------------------------------------------------

pg\_catalog pg\_class 16 7162 546 319 0 1 0

pg\_catalog pg\_am 13 13 0 0 0 0 0

pg\_catalog pg\_database 4 16 42 42 0 0 0

pg\_catalog pg\_index 4 660 145 149 0 0 0

pg\_catalog pg\_namespace 4 100 49 49 0 0 0

sys edb$snap 1 9 0 0 1 0 0

pg\_catalog pg\_authid 1 1 25 25 0 0 0

sys edb$session\_wait\_history 0 0 0 0 50 0 0

sys edb$session\_waits 0 0 0 0 2 0 0

sys edb$stat\_all\_indexes 0 0 0 0 165 0 0

The information displayed in the DATA from pg\_stat\_all\_tables ordered by seq scan section includes:

|              |                                                          |
| ------------ | -------------------------------------------------------- |
| Column Name  | Description                                              |
| SCHEMA       | The name of the schema in which the table resides.       |
| RELATION     | The name of the table.                                   |
| SEQ SCAN     | The number of sequential scans initiated on this table.. |
| REL TUP READ | The number of tuples read in the table.                  |
| IDX SCAN     | The number of index scans initiated on the table.        |
| IDX TUP READ | The number of index tuples read.                         |
| INS          | The number of rows inserted.                             |
| UPD          | The number of rows updated.                              |
| DEL          | The number of rows deleted.                              |

DATA from pg\_stat\_all\_tables ordered by rel tup read

SCHEMA RELATION SEQ SCAN REL TUP READ IDX SCAN IDX TUP READ INS UPD DEL

\----------------------------------------------------------------------------

pg\_catalog pg\_class 16 7162 546 319 0 1 0

pg\_catalog pg\_index 4 660 145 149 0 0 0

pg\_catalog pg\_namespace 4 100 49 49 0 0 0

pg\_catalog pg\_database 4 16 42 42 0 0 0

pg\_catalog pg\_am 13 13 0 0 0 0 0

sys edb$snap 1 9 0 0 1 0 0

pg\_catalog pg\_authid 1 1 25 25 0 0 0

sys edb$session\_wait\_history 0 0 0 0 50 0 0

sys edb$session\_waits 0 0 0 0 2 0 0

sys edb$stat\_all\_indexes 0 0 0 0 165 0 0

The information displayed in the DATA from pg\_stat\_all\_tables ordered by rel tup read section includes:

|              |                                                        |
| ------------ | ------------------------------------------------------ |
| Column Name  | Description                                            |
| SCHEMA       | The name of the schema in which the table resides.     |
| RELATION     | The name of the table.                                 |
| SEQ SCAN     | The number of sequential scans performed on the table. |
| REL TUP READ | The number of tuples read from the table.              |
| IDX SCAN     | The number of index scans performed on the table.      |
| IDX TUP READ | The number of index tuples read.                       |
| INS          | The number of rows inserted.                           |
| UPD          | The number of rows updated.                            |
| DEL          | The number of rows deleted.                            |

DATA from pg\_statio\_all\_tables

SCHEMA RELATION HEAP HEAP HEAP IDX IDX

READ HIT ICACHE READ HIT

HIT

IDX TOAST TOAST TOAST TIDX TIDX TIDX

ICACHE READ HIT ICACHE READ HIT ICACHE

HIT HIT HIT

\-----------------------------------------------------------------------------

public pgbench\_accounts 92766 67215 288 59 32126

9 0 0 0 0 0 0

pg\_catalog pg\_class 0 296 0 3 16

0 0 0 0 0 0 0

sys edb$stat\_all\_indexes 8 125 0 4 233

0 0 0 0 0 0 0

sys edb$statio\_all\_index 8 125 0 4 233

0 0 0 0 0 0 0

sys edb$stat\_all\_tables 6 91 0 2 174

0 0 0 0 0 0 0

sys edb$statio\_all\_table 6 91 0 2 174

0 0 0 0 0 0 0

pg\_catalog pg\_namespace 3 72 0 0 0

0 0 0 0 0 0 0

sys edb$session\_wait\_his 1 24 0 4 47

0 0 0 0 0 0 0

pg\_catalog pg\_opclass 3 13 0 2 0

0 0 0 0 0 0 0

pg\_catalog pg\_trigger 0 12 0 1 15

0 0 0 0 0 0 0

The information displayed in the Data from pg\_statio\_all\_tables section includes:

|                  |                                                     |
| ---------------- | --------------------------------------------------- |
| Column Name      | Description                                         |
| SCHEMA           | The name of the schema in which the table resides.  |
| RELATION         | The name of the table.                              |
| HEAP READ        | The number of heap blocks read.                     |
| HEAP HIT         | The number of heap blocks hit.                      |
| HEAP ICACHE HIT  | The number of heap blocks in Infinite Cache.        |
| IDX READ         | The number of index blocks read.                    |
| IDX HIT          | The number of index blocks hit.                     |
| IDX ICACHE HIT   | The number of index blocks in Infinite Cache.       |
| TOAST READ       | The number of toast blocks read.                    |
| TOAST HIT        | The number of toast blocks hit.                     |
| TOAST ICACHE HIT | The number of toast blocks in Infinite Cache.       |
| TIDX READ        | The number of toast index blocks read.              |
| TIDX HIT         | The number of toast index blocks hit.               |
| TIDX ICACHE HIT  | The number of toast index blocks in Infinite Cache. |

DATA from pg\_stat\_all\_indexes

SCHEMA RELATION INDEX IDX SCAN IDX TUP READ IDX TUP FETCH

\----------------------------------------------------------------------------

pg\_catalog pg\_attribute pg\_attribute\_relid\_attnum\_index 427 907 907

pg\_catalog pg\_class pg\_class\_relname\_nsp\_index 289 62 62

pg\_catalog pg\_class pg\_class\_oid\_index 257 257 257

pg\_catalog pg\_statistic pg\_statistic\_relid\_att\_inh\_index 207 196 196

enterprisedb pgbench\_accounts pgbench\_accounts\_pkey 200 255 200

pg\_catalog pg\_cast pg\_cast\_source\_target\_index 199 50 50

pg\_catalog pg\_proc pg\_proc\_oid\_index 116 116 116

pg\_catalog edb\_partition edb\_partition\_partrelid\_index 112 0 0

pg\_catalog edb\_policy edb\_policy\_object\_name\_index 112 0 0

enterprisedb pgbench\_branches pgbench\_branches\_pkey 101 110 0

The information displayed in the DATA from pg\_stat\_all\_indexes section includes:

|               |                                                                           |
| ------------- | ------------------------------------------------------------------------- |
| Column Name   | Description                                                               |
| SCHEMA        | The name of the schema in which the index resides.                        |
| RELATION      | The name of the table on which the index is defined.                      |
| INDEX         | The name of the index.                                                    |
| IDX SCAN      | The number of indexes scans initiated on this index.                      |
| IDX TUP READ  | Number of index entries returned by scans on this index                   |
| IDX TUP FETCH | Number of live table rows fetched by simple index scans using this index. |

DATA from pg\_statio\_all\_indexes

SCHEMA RELATION INDEX IDX BLKS READ IDX BLKS HIT IDX BLKS ICACHE HIT

\----------------------------------------------------------------------------

pg\_catalog pg\_attribute pg\_attribute\_relid\_attnum\_index 0 867 0

enterprisedb pgbench\_accounts pgbench\_accounts\_pkey 1 778 0

pg\_catalog pg\_class pg\_class\_relname\_nsp\_index 0 590 0

pg\_catalog pg\_class pg\_class\_oid\_index 0 527 0

pg\_catalog pg\_statistic pg\_statistic\_relid\_att\_inh\_index 0 441 0

sys edb$stat\_all\_indexes edb$stat\_idx\_pk 1 332 0

sys edb$statio\_all\_indexes edb$statio\_idx\_pk 1 332 0

pg\_catalog pg\_proc pg\_proc\_oid\_index 0 244 0

sys edb$stat\_all\_tables edb$stat\_tab\_pk 0 241 0

sys edb$statio\_all\_tables edb$statio\_tab\_pk 0 241 0

The information displayed in the DATA from pg\_statio\_all\_indexes section includes:

|                     |                                                             |
| ------------------- | ----------------------------------------------------------- |
| Column Name         | Description                                                 |
| SCHEMA              | The name of the schema in which the index resides.          |
| RELATION            | The name of the table on which the index is defined.        |
| INDEX               | The name of the index.                                      |
| IDX BLKS READ       | The number of index blocks read.                            |
| IDX BLKS HIT        | The number of index blocks hit.                             |
| IDX BLKS ICACHE HIT | The number of index blocks in Infinite Cache that were hit. |

System Wait Information

WAIT NAME COUNT WAIT TIME % WAIT

\---------------------------------------------------------------------------

query plan 0 0.000407 100.00

db file read 0 0.000000 0.00

The information displayed in the System Wait Information section includes:

|             |                                                                           |
| ----------- | ------------------------------------------------------------------------- |
| Column Name | Description                                                               |
| WAIT NAME   | The name of the wait.                                                     |
| COUNT       | The number of times that the wait event occurred.                         |
| WAIT TIME   | The length of the wait time in milliseconds.                              |
| % WAIT      | The percentage of the total wait time used by this wait for this session. |

Database Parameters from postgresql.conf

PARAMETER SETTING CONTEXT MINVAL MAXVAL

\----------------------------------------------------------------------------

allow\_system\_table\_mods off postmaster

application\_name psql user

archive\_command (disabled) sighup

archive\_mode off postmaster

archive\_timeout 0 sighup 0 2147483647

array\_nulls on user

authentication\_timeout 60 sighup 1 600

autovacuum on sighup

autovacuum\_analyze\_scale\_factor 0.1 sighup 0 100

autovacuum\_analyze\_threshold 50 sighup 0 2147483647

autovacuum\_freeze\_max\_age 200000000 postmaster 100000000 2000000000

autovacuum\_max\_workers 3 postmaster 1 8388607

autovacuum\_naptime 60 sighup 1 2147483

autovacuum\_vacuum\_cost\_delay 20 ...

The information displayed in the Database Parameters from postgresql.conf section includes:

|             |                                                  |
| ----------- | ------------------------------------------------ |
| Column Name | Description                                      |
| PARAMETER   | The name of the parameter.                       |
| SETTING     | The current value assigned to the parameter.     |
| CONTEXT     | The context required to set the parameter value. |
| MINVAL      | The minimum value allowed for the parameter.     |
| MAXVAL      | The maximum value allowed for the parameter.     |

### stat\_db\_rpt()

The signature is:

> stat\_db\_rpt(*beginning\_id*, *ending\_id*)

Parameters

beginning\_id

beginning\_id is an integer value that represents the beginning session identifier.

ending\_id

ending\_id is an integer value that represents the ending session identifier.

The following example demonstrates the stat\_db\_rpt() function:

SELECT \* FROM stat\_db\_rpt(9, 10);

stat\_db\_rpt

\-----------------------------------------------------------------------------

DATA from pg\_stat\_database

DATABASE NUMBACKENDS XACT COMMIT XACT ROLLBACK BLKS READ BLKS HIT

BLKS ICACHE HIT HIT RATIO ICACHE HIT RATIO

\-----------------------------------------------------------------------------

edb 1 21 0 92928 101217

301 52.05 0.15

The information displayed in the DATA from pg\_stat\_database section of the report includes:

|                  |                                                                                                                                                                                                                    |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Column Name      | Description                                                                                                                                                                                                        |
| DATABASE         | The name of the database.                                                                                                                                                                                          |
| NUMBACKENDS      | Number of backends currently connected to this database. This is the only column in this view that returns a value reflecting current state; all other columns return the accumulated values since the last reset. |
| XACT COMMIT      | The number of transactions in this database that have been committed.                                                                                                                                              |
| XACT ROLLBACK    | The number of transactions in this database that have been rolled back.                                                                                                                                            |
| BLKS READ        | The number of blocks read.                                                                                                                                                                                         |
| BLKS HIT         | The number of blocks hit.                                                                                                                                                                                          |
| BLKS ICACHE HIT  | The number of blocks in Infinite Cache that were hit.                                                                                                                                                              |
| HIT RATIO        | The percentage of times that a block was found in the shared buffer cache.                                                                                                                                         |
| ICACHE HIT RATIO | The percentage of times that a block was found in Infinite Cache.                                                                                                                                                  |

### stat\_tables\_rpt()

The signature is:

> function\_name(*beginning\_id*, *ending\_id*, *top\_n, scope*)

Parameters

beginning\_id

beginning\_id is an integer value that represents the beginning session identifier.

ending\_id

ending\_id is an integer value that represents the ending session identifier.

top\_n

top\_n represents the number of rows to return

scope

scope determines which tables the function returns statistics about. Specify SYS, USER or ALL:
 - SYS indicates that the function should return information about system defined tables. A table is considered a system table if it is stored in one of the following schemas: pg\_catalog, information\_schema, sys, or dbo.
 - USER indicates that the function should return information about user-defined tables.
 - ALL specifies that the function should return information about all tables.

The stat\_tables\_rpt() function returns a two-part report. The first portion of the report contains:

SELECT \* FROM stat\_tables\_rpt(18, 19, 10, 'ALL');

stat\_tables\_rpt

\-----------------------------------------------------------------------------

DATA from pg\_stat\_all\_tables ordered by seq scan

SCHEMA RELATION

SEQ SCAN REL TUP READ IDX SCAN IDX TUP READ INS UPD DEL

\-----------------------------------------------------------------------------

pg\_catalog pg\_class

8 2952 78 65 0 0 0

pg\_catalog pg\_index

4 448 23 28 0 0 0

pg\_catalog pg\_namespace

4 76 1 1 0 0 0

pg\_catalog pg\_database

3 6 0 0 0 0 0

pg\_catalog pg\_authid

2 1 0 0 0 0 0

sys edb$snap

1 15 0 0 1 0 0

public accounts

0 0 0 0 0 0 0

public branches

0 0 0 0 0 0 0

sys edb$session\_wait\_history

0 0 0 0 25 0 0

sys edb$session\_waits

0 0 0 0 10 0 0

The information displayed in the DATA from pg\_stat\_all\_tables ordered by seq scan section includes:

|              |                                                    |
| ------------ | -------------------------------------------------- |
| Column Name  | Description                                        |
| SCHEMA       | The name of the schema in which the table resides. |
| RELATION     | The name of the table.                             |
| SEQ SCAN     | The number of sequential scans on the table.       |
| REL TUP READ | The number of tuples read from the table.          |
| IDX SCAN     | The number of index scans performed on the table.  |
| IDX TUP READ | The number of index tuples read from the table.    |
| INS          | The number of rows inserted.                       |
| UPD          | The number of rows updated.                        |
| DEL          | The number of rows deleted.                        |

The second portion of the report contains:

DATA from pg\_stat\_all\_tables ordered by rel tup read

SCHEMA RELATION

SEQ SCAN REL TUP READ IDX SCAN IDX TUP READ INS UPD DEL

\-----------------------------------------------------------------------------

pg\_catalog pg\_class

8 2952 78 65 0 0 0

pg\_catalog pg\_index

4 448 23 28 0 0 0

pg\_catalog pg\_namespace

4 76 1 1 0 0 0

sys edb$snap

1 15 0 0 1 0 0

pg\_catalog pg\_database

3 6 0 0 0 0 0

pg\_catalog pg\_authid

2 1 0 0 0 0 0

public accounts

0 0 0 0 0 0 0

public branches

0 0 0 0 0 0 0

sys edb$session\_wait\_history

0 0 0 0 25 0 0

sys edb$session\_waits

0 0 0 0 10 0 0

(29 rows)

The information displayed in the DATA from pg\_stat\_all\_tables ordered by rel tup read section includes:

|              |                                                        |
| ------------ | ------------------------------------------------------ |
| Column Name  | Description                                            |
| SCHEMA       | The name of the schema in which the table resides.     |
| RELATION     | The name of the table.                                 |
| SEQ SCAN     | The number of sequential scans performed on the table. |
| REL TUP READ | The number of tuples read from the table.              |
| IDX SCAN     | The number of index scans performed on the table.      |
| IDX TUP READ | The number of live rows fetched by index scans.        |
| INS          | The number of rows inserted.                           |
| UPD          | The number of rows updated.                            |
| DEL          | The number of rows deleted.                            |

### statio\_tables\_rpt()

The signature is:

> statio\_tables\_rpt(*beginning\_id*, *ending\_id*, *top\_n*, *scope*)

Parameters

beginning\_id

beginning\_id is an integer value that represents the beginning session identifier.

ending\_id

ending\_id is an integer value that represents the ending session identifier.

top\_n

top\_n represents the number of rows to return

scope

scope determines which tables the function returns statistics about. Specify SYS, USER or ALL:
 - SYS indicates that the function should return information about system defined tables. A table is considered a system table if it is stored in one of the following schemas: pg\_catalog, information\_schema, sys, or dbo.
 - USER indicates that the function should return information about user-defined tables.
 - ALL specifies that the function should return information about all tables.

The statio\_tables\_rpt() function returns a report that contains:

edb=\# SELECT \* FROM statio\_tables\_rpt(9, 10, 10, 'SYS');

statio\_tables\_rpt -----------------------------------------------------------------------------

DATA from pg\_statio\_all\_tables

SCHEMA RELATION HEAP HEAP HEAP IDX IDX

READ HIT ICACHE READ HIT

HIT

IDX TOAST TOAST TOAST TIDX TIDX TIDX

ICACHE READ HIT ICACHE READ HIT ICACHE

HIT HIT HIT

\-----------------------------------------------------------------------------

public pgbench\_accounts 92766 67215 288 59 32126

9 0 0 0 0 0 0

pg\_catalog pg\_class 0 296 0 3 16

0 0 0 0 0 0 0

sys edb$stat\_all\_indexes 8 125 0 4 233

0 0 0 0 0 0 0

sys edb$statio\_all\_index 8 125 0 4 233

0 0 0 0 0 0 0

sys edb$stat\_all\_tables 6 91 0 2 174

0 0 0 0 0 0 0

sys edb$statio\_all\_table 6 91 0 2 174

0 0 0 0 0 0 0

pg\_catalog pg\_namespace 3 72 0 0 0

0 0 0 0 0 0 0

sys edb$session\_wait\_his 1 24 0 4 47

0 0 0 0 0 0 0

pg\_catalog pg\_opclass 3 13 0 2 0

0 0 0 0 0 0 0

pg\_catalog pg\_trigger 0 12 0 1 15

0 0 0 0 0 0 0

(16 rows)

The information displayed in the Data from pg\_statio\_all\_tables section includes:

|                  |                                                       |
| ---------------- | ----------------------------------------------------- |
| Column Name      | Description                                           |
| SCHEMA           | The name of the schema in which the relation resides. |
| RELATION         | The name of the relation.                             |
| HEAP READ        | The number of heap blocks read.                       |
| HEAP HIT         | The number of heap blocks hit.                        |
| HEAP ICACHE HIT  | The number of heap blocks in Infinite Cache.          |
| IDX READ         | The number of index blocks read.                      |
| IDX HIT          | The number of index blocks hit.                       |
| IDX ICACHE HIT   | The number of index blocks in Infinite Cache.         |
| TOAST READ       | The number of toast blocks read.                      |
| TOAST HIT        | The number of toast blocks hit.                       |
| TOAST ICACHE HIT | The number of toast blocks in Infinite Cache.         |
| TIDX READ        | The number of toast index blocks read.                |
| TIDX HIT         | The number of toast index blocks hit.                 |
| TIDX ICACHE HIT  | The number of toast index blocks in Infinite Cache.   |

### stat\_indexes\_rpt()

The signature is:

> stat\_indexes\_rpt(*beginning\_id*, *ending\_id, top\_n, scope*)

Parameters

beginning\_id

beginning\_id is an integer value that represents the beginning session identifier.

ending\_id

ending\_id is an integer value that represents the ending session identifier.

top\_n

top\_n represents the number of rows to return

scope

scope determines which tables the function returns statistics about. Specify SYS, USER or ALL:
 - SYS indicates that the function should return information about system defined tables. A table is considered a system table if it is stored in one of the following schemas: pg\_catalog, information\_schema, sys, or dbo.
 - USER indicates that the function should return information about user-defined tables.
 - ALL specifies that the function should return information about all tables.

The stat\_indexes\_rpt() function returns a report that contains:

edb=\# SELECT \* FROM stat\_indexes\_rpt(9, 10, 10, 'ALL');

stat\_indexes\_rpt

\-----------------------------------------------------------------------------

DATA from pg\_stat\_all\_indexes

SCHEMA RELATION INDEX

IDX SCAN IDX TUP READ IDX TUP FETCH

\-----------------------------------------------------------------------------

pg\_catalog pg\_cast pg\_cast\_source\_target\_index

30 7 7

pg\_catalog pg\_class pg\_class\_oid\_index

15 15 15

pg\_catalog pg\_trigger pg\_trigger\_tgrelid\_tgname\_index

12 12 12

pg\_catalog pg\_attribute pg\_attribute\_relid\_attnum\_index

7 31 31

pg\_catalog pg\_statistic pg\_statistic\_relid\_att\_index

7 0 0

pg\_catalog pg\_database pg\_database\_oid\_index

5 5 5

pg\_catalog pg\_proc pg\_proc\_oid\_index

5 5 5

pg\_catalog pg\_operator pg\_operator\_oprname\_l\_r\_n\_index

3 1 1

pg\_catalog pg\_type pg\_type\_typname\_nsp\_index

3 1 1

pg\_catalog pg\_amop pg\_amop\_opr\_fam\_index

2 3 3

(14 rows)

The information displayed in the DATA from pg\_stat\_all\_indexes section includes:

|               |                                                       |
| ------------- | ----------------------------------------------------- |
| Column Name   | Description                                           |
| SCHEMA        | The name of the schema in which the relation resides. |
| RELATION      | The name of the relation.                             |
| INDEX         | The name of the index.                                |
| IDX SCAN      | The number of indexes scanned.                        |
| IDX TUP READ  | The number of index tuples read.                      |
| IDX TUP FETCH | The number of index tuples fetched.                   |

### statio\_indexes\_rpt()

The signature is:

> statio\_indexes\_rpt(*beginning\_id*, *ending\_id, top\_n, scope*)

Parameters

beginning\_id

beginning\_id is an integer value that represents the beginning session identifier.

ending\_id

ending\_id is an integer value that represents the ending session identifier.

top\_n

top\_n represents the number of rows to return

scope

scope determines which tables the function returns statistics about. Specify SYS, USER or ALL:
 - SYS indicates that the function should return information about system defined tables. A table is considered a system table if it is stored in one of the following schemas: pg\_catalog, information\_schema, sys, or dbo.
 - USER indicates that the function should return information about user-defined tables.
 - ALL specifies that the function should return information about all tables.

The statio\_indexes\_rpt()function returns a report that contains:

edb=\# SELECT \* FROM statio\_indexes\_rpt(9, 10, 10, 'SYS');

statio\_indexes\_rpt

\-----------------------------------------------------------------------------

DATA from pg\_statio\_all\_indexes

SCHEMA RELATION INDEX

IDX BLKS READ IDX BLKS HIT IDX BLKS ICACHE HIT

\-----------------------------------------------------------------------------

public pgbench\_accounts pgbench\_accounts\_pkey

59 32126 9

sys edb$stat\_all\_indexes edb$stat\_idx\_pk

4 233 0

sys edb$statio\_all\_indexes edb$statio\_idx\_pk

4 233 0

sys edb$stat\_all\_tables edb$stat\_tab\_pk

2 174 0

sys edb$statio\_all\_tables edb$statio\_tab\_pk

2 174 0

sys edb$session\_wait\_history session\_waits\_hist\_pk

4 47 0

pg\_catalog pg\_cast pg\_cast\_source\_target\_index

1 29 0

pg\_catalog pg\_trigger pg\_trig\_tgrelid\_tgname\_index

1 15 0

pg\_catalog pg\_class pg\_class\_oid\_index

1 14 0

pg\_catalog pg\_statistic pg\_statistic\_relid\_att\_index

2 12 0

(14 rows)

The information displayed in the DATA from pg\_statio\_all\_indexes report includes:

|                     |                                                             |
| ------------------- | ----------------------------------------------------------- |
| Column Name         | Description                                                 |
| SCHEMA              | The name of the schema in which the relation resides.       |
| RELATION            | The name of the table on which the index is defined.        |
| INDEX               | The name of the index.                                      |
| IDX BLKS READ       | The number of index blocks read.                            |
| IDX BLKS HIT        | The number of index blocks hit.                             |
| IDX BLKS ICACHE HIT | The number of index blocks in Infinite Cache that were hit. |

##  Performance Tuning Recommendations

To use DRITA reports for performance tuning, review the top five events in a given report, looking for any event that takes a disproportionately large percentage of resources. In a streamlined system, user I/O will probably make up the largest number of waits. Waits should be evaluated in the context of CPU usage and total time; an event may not be significant if it takes 2 minutes out of a total measurement interval of 2 hours, if the rest of the time is consumed by CPU time. The component of response time (CPU "work" time or other "wait" time) that consumes the highest percentage of overall time should be evaluated.

When evaluating events, watch for:

| Event type                 | Description                                                                            |
| -------------------------- | -------------------------------------------------------------------------------------- |
| Checkpoint waits           | Checkpoint waits may indicate that checkpoint parameters need to be adjusted.          |
| WAL-related waits          | WAL-related waits may indicate wal\_buffers are under-sized.                           |
| SQL Parse waits            | If the number of waits is high, try to use prepared statements.                        |
| db file random reads       | If high, check that appropriate indexes and statistics exist.                          |
| db file random writes      | If high, may need to decrease bgwriter\_delay.                                         |
| btree random lock acquires | May indicate indexes are being rebuilt. Schedule index builds during less active time. |

Performance reviews should also include careful scrutiny of the hardware, the operating system, the network and the application SQL statements.

## Event Descriptions

| Event Name                          | Description                                                                                                                                                                                                           |
| ----------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| add in shmem lock acquire           | Obsolete/unused                                                                                                                                                                                                       |
| bgwriter communication lock acquire | The bgwriter (background writer) process has waited for the short-term lock that synchronizes messages between the bgwriter and a backend process.                                                                    |
| btree vacuum lock acquire           | The server has waited for the short-term lock that synchronizes access to the next available vacuum cycle ID.                                                                                                         |
| buffer free list lock acquire       | The server has waited for the short-term lock that synchronizes access to the list of free buffers (in shared memory).                                                                                                |
| checkpoint lock acquire:            | A server process has waited for the short-term lock that prevents simultaneous checkpoints.                                                                                                                           |
| checkpoint start lock acquire       | The server has waited for the short-term lock that synchronizes access to the bgwriter checkpoint schedule.                                                                                                           |
| clog control lock acquire           | The server has waited for the short-term lock that synchronizes access to the commit log.                                                                                                                             |
| control file lock acquire           | The server has waited for the short-term lock that synchronizes write access to the control file (this should usually be a low number).                                                                               |
| db file extend                      | A server process has waited for the operating system while adding a new page to the end of a file.                                                                                                                    |
| db file read                        | A server process has waited for the completion of a read (from disk).                                                                                                                                                 |
| db file write                       | A server process has waited for the completion of a write (to disk).                                                                                                                                                  |
| db file sync                        | A server process has waited for the operating system to flush all changes to disk.                                                                                                                                    |
| first buf mapping lock acquire      | The server has waited for a short-term lock that synchronizes access to the shared-buffer mapping table.                                                                                                              |
| freespace lock acquire              | The server has waited for the short-term lock that synchronizes access to the freespace map.                                                                                                                          |
| Infinite Cache read                 | The server has waited for an Infinite Cache read request.                                                                                                                                                             |
| Infinite Cache write                | The server has waited for an Infinite Cache write request.                                                                                                                                                            |
| lwlock acquire                      | The server has waited for a short-term lock that has not been described elsewhere in this section.                                                                                                                    |
| multi xact gen lock acquire         | The server has waited for the short-term lock that synchronizes access to the next available multi-transaction ID (when a SELECT...FOR SHARE statement executes).                                                     |
| multi xact member lock acquire      | The server has waited for the short-term lock that synchronizes access to the multi-transaction member file (when a SELECT...FOR SHARE statement executes).                                                           |
| multi xact offset lock acquire      | The server has waited for the short-term lock that synchronizes access to the multi-transaction offset file (when a SELECT...FOR SHARE statement executes).                                                           |
| oid gen lock acquire                | The server has waited for the short-term lock that synchronizes access to the next available OID (object ID).                                                                                                         |
| query plan                          | The server has computed the execution plan for a SQL statement.                                                                                                                                                       |
| rel cache init lock acquire         | The server has waited for the short-term lock that prevents simultaneous relation-cache loads/unloads.                                                                                                                |
| shmem index lock acquire            | The server has waited for the short-term lock that synchronizes access to the shared-memory map.                                                                                                                      |
| sinval lock acquire                 | The server has waited for the short-term lock that synchronizes access to the cache invalidation state.                                                                                                               |
| sql parse                           | The server has parsed a SQL statement.                                                                                                                                                                                |
| subtrans control lock acquire       | The server has waited for the short-term lock that synchronizes access to the subtransaction log.                                                                                                                     |
| tablespace create lock acquire      | The server has waited for the short-term lock that prevents simultaneous CREATE TABLESPACE or DROP TABLESPACE commands.                                                                                               |
| two phase state lock acquire        | The server has waited for the short-term lock that synchronizes access to the list of prepared transactions.                                                                                                          |
| wal insert lock acquire             | The server has waited for the short-term lock that synchronizes write access to the write-ahead log. A high number may indicate that WAL buffers are sized too small.                                                 |
| wal write lock acquire              | The server has waited for the short-term lock that synchronizes write-ahead log flushes.                                                                                                                              |
| wal file sync                       | The server has waited for the write-ahead log to sync to disk (related to the wal\_sync\_method parameter which, by default, is 'fsync' - better performance can be gained by changing this parameter to open\_sync). |
| wal flush                           | The server has waited for the write-ahead log to flush to disk.                                                                                                                                                       |
| wal write                           | The server has waited for a write to the write-ahead log buffer (expect this value to be high).                                                                                                                       |
| xid gen lock acquire                | The server has waited for the short-term lock that synchronizes access to the next available transaction ID.                                                                                                          |

## Catalog Views

The following DRITA catalog views provide access to performance information relating to system waits.

### edb$system\_waits

The edb$system\_waits view summarizes the number of waits and the total wait time per session for each wait named. It also displays the average and max wait times. The following example shows the result of a SELECT statement on the edb$system\_waits view:

select \* from sys.edb$system\_waits;

 edb\_id | dbname |wait\_name | wait\_count |avg\_wait | max\_wait | totalwait

\--------+--------+-----------+------------+---------+----------+----------

      1 | edb    |db fileread|        301 |0.011516 | 0.629986 | 2.742500

      1 | edb    |wal flush  |        26 |0.010364 | 0.085380 | 0.269452

      1 | edb    |wal write  |        26 |0.010355 | 0.085371 | 0.269232

      1 | edb    |query plan |        277 |0.001367 | 0.049425 | 0.192442

      2 | edb    |wal flush |        28 |0.040443 | 0.095150 | 0.431984

      2 | edb    |wal write |        28 |0.040434 | 0.095093 | 0.431698

      2 | edb    |query plan |        299 |0.001479 | 0.049425 | 0.262596

edb$system\_waits summarizes the following information:

|             |               |                                                |
| ----------- | ------------- | ---------------------------------------------- |
| Column Name | Type          | Description                                    |
| edb\_id     | BIGINT        | Wait identifier.                               |
| dbname      | NAME          | Name of the database in which the wait occurs. |
| wait\_name  | TEXT          | Name of the wait event.                        |
| wait\_count | BIGINT        | Number of times the wait event has occurred.   |
| avg\_wait   | NUMERIC       | Average wait time in milliseconds.             |
| max\_wait   | NUMERIC(50,6) | Maximum wait time in milliseconds.             |
| totalwait   | NUMERIC(50,6) | Total wait time in milliseconds.               |

### edb$session\_waits

The edb$session\_waits view summarizes the number of waits and the total wait time per session for each wait named and identified by backend ID. It also displays the average and max wait times. The following code sample shows the result of a SELECT statement on the edb$session\_waits view:

SELECT \* FROM sys.edb$session\_waits;

edb\_id | dbname | backend\_id |  wait\_name    | wait\_count | avg\_wait\_time | max\_wait\_time| total\_wait\_time |  usename    |  current\_query

\--------+--------+------------+---------------+------------+---------------+--------------+-----------------+--------------+---------------------------

1 | edb | 22935 | db file read  | 175 | 0.008399 |
0.629986 | 1.469887 | enterprisedb | \<IDLE\>

1 | edb | 22988 | db file read  | 116 | 0.009556 |
0.040627 | 1.108438 | enterprisedb | select \* from edbsnap();

1 | edb | 22988 | wal flush | 26 | 0.010364 |
0.085380 | 0.269452 | enterprisedb | select \* from edbsnap();

(3 rows)

edb$session\_waits summarizes the following information:

|                   |               |                                                |
| ----------------- | ------------- | ---------------------------------------------- |
| Column Name       | Type          | Description                                    |
| edb\_id           | BIGINT        | Wait identifier.                               |
| dbname            | NAME          | Name of the database in which the wait occurs. |
| backend\_id       | BIGINT        | The backend ID of the process.                 |
| wait\_name        | TEXT          | Name of the wait event.                        |
| wait\_count       | BIGINT        | Number of times the wait event has occurred.   |
| avg\_wait\_time   | NUMERIC(50,6) | Average wait time in milliseconds.             |
| max\_wait\_time   | NUMERIC       | Maximum wait time in milliseconds.             |
| total\_wait\_time | NUMERIC       | Total wait time in milliseconds.               |
| use\_name         | NAME          | The name of the user invoking the query.       |
| current\_query    | TEXT          | The query that is currently executing.         |

### edb$session\_wait\_history

The edb$session\_wait\_history view contains the last 25 wait events for each backend ID active during the session. The following code sample shows the result of a SELECT statement on the edb$session\_wait\_history view:

SELECT \* FROM sys.edb$session\_wait\_history;

edb\_id | dbname | backend\_id | seq |   wait\_name   | elapsed | p1 | p2 | p3

\--------+--------+------------+-----+---------------+---------+----+----+----

1 | edb    |      22935 |   1 | query plan   |      54 |  0 |  0 | 0

1 | edb    |      22935 |   2 | db file read |    1116 |2689| 8 | 1

1 | edb    |      22935 |   3 | db file read |     983 |1255| 32 |  1

1 | edb    |      22935 |   4 | db file read  |   13717 |2691| 19 |  1

1 | edb    |      22935 |   5 | query plan    |      75 | 0|  0 |  0

1 | edb    |      22935 |   6 | db file read |   11053 |1255|  7 | 1

1 | edb    |      22935 |   7 | db file read  |     404 |2689|  4 |  1

(7 rows)

The edb$session\_wait\_history view includes the following information:

|             |        |                                                                 |
| ----------- | ------ | --------------------------------------------------------------- |
| Column Name | Type   | Description                                                     |
| edb\_id     | BIGINT | Wait identifier.                                                |
| dbname      | TEXT   | Name of the database in which the wait occurs.                  |
| backend\_id | BIGINT | The session identifier of the process in which the wait occurs. |
| seq         | BIGINT | The sequence number of the event (value 1 through 25).          |
| wait\_name  | TEXT   | Name of the wait event.                                         |
| elapsed     | BIGINT | Elapsed time in milliseconds.                                   |
| p1          | BIGINT | Wait specific – see table below.                                |
| p2          | BIGINT | Wait specific – see table below.                                |
| p3          | BIGINT | Wait specific – see table below.                                |

The values contained in the p1, p2, and p3 columns are wait-specific. The following waits include information in those columns:

<table>
<thead>
<tr class="header">
<th>Wait Name</th>
<th>p1</th>
<th>p2</th>
<th>p3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>wal file sync</td>
<td><p>0 means Fsync</p>
<p>1 means Fdatasync</p>
<p>2 means open</p>
<p>3 means Fsync writethrough</p>
<p>4 means open dsync</p>
<p>For more information, please see the documentation for WAL_SYNC_METHOD</p></td>
<td>unused</td>
<td>unused</td>
</tr>
<tr class="even">
<td>Infinite Cache write</td>
<td>The Infinite Cache node ID that was written</td>
<td>The file ID from pg_class.relfilenode</td>
<td>The block number that was written</td>
</tr>
<tr class="odd">
<td>Infinite Cache read</td>
<td>The file ID from pg_class.relfilenode</td>
<td>The block number that was written</td>
<td>unused</td>
</tr>
<tr class="even">
<td>db file extend</td>
<td>The file ID from pg_class.relfilenode</td>
<td>The block number that was extended</td>
<td><p>Skip Fsync;</p>
<p>1 if True, 0 if False</p></td>
</tr>
<tr class="odd">
<td>db file read</td>
<td>The file ID from pg_class.relfilenode</td>
<td>The block number that was read</td>
<td>unused</td>
</tr>
<tr class="even">
<td>db file write</td>
<td>The file ID from pg_class.relfilenode</td>
<td>The block number that was written</td>
<td>unused</td>
</tr>
</tbody>
</table>

For all other event types, the p1, p2, and p3 columns are unused.

