---
title: Introduction
navTitle: EDB Postgres Advanced Server
---


*Notice: The names for EDB’s products have changed. The product formerly referred to as Postgres Plus Advanced Server is now referred to as EDB Postgres Advanced Server. Until a new version of this documentation is published, wherever you see Postgres Plus Advanced Server you may substitute it with EDB Postgres Advanced Server. Name changes in software and software outputs will be phased in over time.*

This guide describes the features of EnterpriseDB’s *EDB Postgres Enterprise,* formerly known as *EDB Postgres Plus Enterprise Edition*. The core of EDB Postgres Enterprise is EnterpriseDB’s database server, *EDB Postgres Advanced Server*.

Enterprise provides a wide range of additional functionality in various areas including database administration, enhanced SQL capabilities, database and application security, performance monitoring and analysis, and application development utilities.

This guide is arranged as follows:
 - **Database Administration.** Chapter 2 contains the features related to database administration.

> *Configuration parameters* described in Section <span class="underline">2.1</span> control the basic characteristics and performance of an Advanced Server instance.
>
> *Audit logging* described in Section <span class="underline">2.2</span> provides enhanced database auditing capabilities.
>
> *Unicode Collation Algorithm* described in Section <span class="underline">2.3</span> provides the capability to create a collation specific to your particular needs on a UTF-8 encoded database.
 - **Enhanced SQL Features.** Chapter 3 contains the SQL enhancements provided for an Advanced Server database.

> *Synonyms* described in Section <span class="underline">3.1</span> provide for easy-to-use abbreviations for the fully qualified path names of tables and views.
>
> *Hierarchical queries* described in Section <span class="underline">3.2</span> provide for a logical display of tables related by foreign key constraints.
>
> *Extended functions and operators* described in Section <span class="underline">3.3</span> provides for additional functionality of SQL.
>
> *Partitioned tables* described in Section <span class="underline">3.4</span> provide for the implementation of table partitioning using the SQL CREATE TABLE statement.
 - **Security.** Chapter 4 contains various security features.

> *SQL/Protect* described in Section <span class="underline">4.1</span> provides protection against SQL injection attacks.
>
> *EDB\*Wrap* described in Section <span class="underline">4.2</span> provides obfuscation of program source code to prevent unwanted scrutiny.
>
> *Virtual Private Database* described in Section <span class="underline">4.3</span> provides fine-grained, row level access.
 - **EDB Resource Manager.** Chapter 5 contains information on the EDB Resource Manager feature, which provides the capability to control system resource usage by Advanced Server processes.

> *Resource Groups* described in Section <span class="underline">5.1</span> shows how to create and maintain the groups on which resource limits can be defined and to which Advanced Server processes can be assigned.
>
> *CPU Usage Throttling* described in Section <span class="underline">5.2</span> provides a method to control CPU usage by Advanced Server processes.
>
> *Dirty Buffer Throttling* described in Section <span class="underline">5.3</span> provides a method to control the dirty rate of shared buffers by Advanced Server processes.
 - **Database Utilities.** Chapter 6 contains database utility programs and interfaces.

> *EDB\*Loader* described in Section <span class="underline">6.1</span> provides a quick and easy method for loading Advanced Server tables.
>
> *EDB\*Plus* described in Section <span class="underline">6.2</span> is a command line utility program for running SQL statements.
>
> The *libpq C library* described in Section <span class="underline">6.3</span> is the C application programming interface (API) language for Advanced Server.
>
> *ECPGPlus* described in Section <span class="underline">6.4</span> is a C precompiler for Advanced Server.
 - > **Open Client Library.** Chapter <span class="underline">7</span> provides information about the Open Client Library, an application programming interface for Advanced Server.
    >
    > *The PL Debugger* described in Section <span class="underline">7.5</span> is a graphically oriented debugging tool for PL/pgSQL.

<!-- end list -->
 - **Performance Analysis and Tuning.** Chapter 8 contains the various tools for analyzing and improving application and database server performance.

> *Dynatune* described in Section <span class="underline">8.1</span> provides a quick and easy means for configuring Advanced Server depending upon the type of application usage.
>
> *Infinite Cache* described in Section <span class="underline">8.2</span> provides for performance improvement using memory caching. **Note:** Infinite Cache has been deprecated and may be removed in a future release. Please contact your EnterpriseDB Account Manager or [mailto:sales@enterprisedb.com](mailto:sales@enterprisedb.com) for more information.
>
> *Index Advisor* described in Section <span class="underline">8.3</span> helps to determine the additional indexes needed on tables to improve application performance.
>
> *SQL Profiler* described in Section <span class="underline">8.4</span> locates and diagnoses poorly running SQL queries in applications.
>
> *Query optimization hints* described in Section <span class="underline">8.5</span> allows you to influence the manner in which the query planner processes SQL statements.
>
> *DBMS\_PROFILER* described in Section <span class="underline">8.6</span> is a built-in package that can be used to gather performance statistics for PL/pgSQL programs.
>
> *Dynamic Runtime Instrumentation Tools Architecture (DRITA)* described in Section <span class="underline">8.7</span> provides the capability to capture and view statistics pertaining to wait events that affect system performance.
 - **Built-In Utility Packages.** Chapter <span class="underline">9</span> contains an extensive set of *built-in packages* that provide functions to quicken and ease development of PL/pgSQL applications.
 - **Expanded Catalog Views.** Chapter <span class="underline">10</span> contains additional *catalog views* added to Advanced Server to simplify the querying of database object information.
 - **System Catalog Tables.** Chapter <span class="underline">11</span> contains additional *system catalog tables* added for Advanced Server specific database objects.
 - **Appendix.** Chapter <span class="underline">12</span> contains various miscellaneous topics such as Advanced Server database limits and keywords.

## What’s New

The following features have been added to EDB Postgres Advanced Server 9.4 to create Advanced Server 9.5:
 - Advanced Server now provides support for Profile Management. For more information, see Section <span class="underline">2.4</span>.
 - Advanced Server now includes support for DBMS\_SESSION.SET\_ROLE. For more information, see Section <span class="underline">9.13.1</span>.
 - Advanced Server now includes support for the UTL\_RAW package. For more information, see Section <span class="underline">9.20</span>.
 - Advanced Server now includes the edb\_audit\_tag parameter; the parameter can be used to add a tag to an audit log. For more information, see sections <span class="underline">2.1.3.7.10</span> and <span class="underline">2.2.1</span>.
 - Advanced Server supports the use of EDBLDR\_ENV\_STYLE to specify the style of environment variables recognized by EDB\*Loader. For more information, see Section <span class="underline">6.1.3</span>.
 - EDB\*Loader now accepts the ZONED \[(precision\[,scale\])\] field type specification. For more information, see Section <span class="underline">6.1.3</span>.

<!-- end list -->
 - Advanced Server now supports the UTL\_HTTP.WRITE\_LINE and UTL\_HTTP.WRITE\_TEXT procedures. For more information, see sections <span class="underline">9.18.25</span> and <span class="underline">9.18.27</span>, respectively.
 - Advanced Server now supports the DBA\_PROFILES view. For more information, see Section <span class="underline">10.36</span>.
 - Advanced Server now supports the FREEZE keyword in the EDB\*Loader control file and on the command line. For more information, see sections <span class="underline">6.1.3</span> and <span class="underline">6.1.4</span>, respectively.
 - Advanced Server now supports XA functions xaoEnv and xaoSvcCtx in the Open Client Library. For more information, See Section <span class="underline">7.4.6</span>.
 - Advanced Server now supports the EDB\_ATTR\_EMPTY\_STRINGS environment attribute in the Open Client Library. For more information, See Section <span class="underline">7.4.2.1</span>.

## Typographical Conventions Used in this Guide

Certain typographical conventions are used in this manual to clarify the meaning and usage of various commands, statements, programs, examples, etc. This section provides a summary of these conventions.

In the following descriptions a *term* refers to any word or group of words that may be language keywords, user-supplied values, literals, etc. A term’s exact meaning depends upon the context in which it is used.
 - *Italic font* introduces a new term, typically, in the sentence that defines it for the first time.
 - Fixed-width (mono-spaced) font is used for terms that must be given literally such as SQL commands, specific table and column names used in the examples, programming language keywords, directory paths and file names, parameter values, etc. For example postgresql.conf, SELECT \* FROM emp;
 - *Italic fixed-width font* is used for terms for which the user must substitute values in actual usage. For example, DELETE FROM *table\_name*;
 - A vertical pipe | denotes a choice between the terms on either side of the pipe. A vertical pipe is used to separate two or more alternative terms within square brackets (optional choices) or braces (one mandatory choice).
 - Square brackets \[ \] denote that one or none of the enclosed term(s) may be substituted. For example, \[ a | b \], means choose one of “a” or “b” or neither of the two.
 - Braces {} denote that exactly one of the enclosed alternatives must be specified. For example, { a | b }, means exactly one of “a” or “b” must be specified.
 - Ellipses ... denote that the proceeding term may be repeated. For example, \[ a | b \] ... means that you may have the sequence, “b a a b a”.

## Other Conventions Used in this Guide

This guide applies to both Linux and Windows systems. Directory paths are presented in the Linux format with forward slashes. When working on Windows systems, start the directory path with the drive letter followed by a colon and substitute back slashes for forward slashes.

Throughout this guide, the directory path of the Advanced Server is referred to as *POSTGRES\_PLUS\_HOME*.

> For Linux installations, the default directory path is
>
> /opt/PostgresPlus/*version\_no*
>
> For Windows installations, the default directory path is
>
> C:\\Program Files\\PostgresPlus\\*version\_no*

The product version number is represented by *version\_no*.

## About the Examples Used in this Guide

The examples in this guide are shown in the type and background illustrated below.

Examples and output from examples are shown in fixed-width, blue font on a light blue background.

The examples use the sample tables, dept, emp, and jobhist, created and loaded when Advanced Server is installed.

The tables and programs in the sample database can be re-created at any time by executing the following script:

> *POSTGRES\_PLUS\_HOME*/installer/server/pg-sample.sql.

The script:
 - Creates the sample tables and programs in the currently connected database.
 - Grants all permissions on the tables to the PUBLIC group.

The tables and programs will be created in the first schema of the search path in which the current user has permission to create tables and procedures. You can display the search path by issuing the command:

SHOW SEARCH\_PATH;

You can use PSQL commands to modify the search path.

#### Sample Database Description

The sample database represents employees in an organization. It contains three types of records: employees, departments, and historical records of employees.

Each employee has an identification number, name, hire date, salary, and manager. Some employees earn a commission in addition to their salary. All employee-related information is stored in the emp table.

The sample company is regionally diverse, so it tracks the locations of its departments. Each company employee is assigned to a department. Each department is identified by a unique department number and a short name. Each department is associated with one location. All department-related information is stored in the dept table.

The company also tracks information about jobs held by the employees. Some employees have been with the company for a long time and have held different positions, received raises, switched departments, etc. When a change in employee status occurs, the company records the end date of the former position. A new job record is added with the start date and the new job title, department, salary, and the reason for the status change. All employee history is maintained in the jobhist table.

The following is the pg-sample.sql script:

SET datestyle TO 'iso, dmy';

\--

\-- Script that creates the 'sample' tables, views

\-- functions, triggers, etc.

\--

\-- Start new transaction - commit all or nothing

\--

BEGIN;

\--

\-- Create and load tables used in the documentation examples.

\--

\-- Create the 'dept' table

\--

CREATE TABLE dept (

deptno NUMERIC(2) NOT NULL CONSTRAINT dept\_pk PRIMARY KEY,

dname VARCHAR(14) CONSTRAINT dept\_dname\_uq UNIQUE,

loc VARCHAR(13)

);

\--

\-- Create the 'emp' table

\--

CREATE TABLE emp (

empno NUMERIC(4) NOT NULL CONSTRAINT emp\_pk PRIMARY KEY,

ename VARCHAR(10),

job VARCHAR(9),

mgr NUMERIC(4),

hiredate DATE,

sal NUMERIC(7,2) CONSTRAINT emp\_sal\_ck CHECK (sal \> 0),

comm NUMERIC(7,2),

deptno NUMERIC(2) CONSTRAINT emp\_ref\_dept\_fk

REFERENCES dept(deptno)

);

\--

\-- Create the 'jobhist' table

\--

CREATE TABLE jobhist (

empno NUMERIC(4) NOT NULL,

startdate TIMESTAMP(0) NOT NULL,

enddate TIMESTAMP(0),

job VARCHAR(9),

sal NUMERIC(7,2),

comm NUMERIC(7,2),

deptno NUMERIC(2),

chgdesc VARCHAR(80),

CONSTRAINT jobhist\_pk PRIMARY KEY (empno, startdate),

CONSTRAINT jobhist\_ref\_emp\_fk FOREIGN KEY (empno)

REFERENCES emp(empno) ON DELETE CASCADE,

CONSTRAINT jobhist\_ref\_dept\_fk FOREIGN KEY (deptno)

REFERENCES dept (deptno) ON DELETE SET NULL,

CONSTRAINT jobhist\_date\_chk CHECK (startdate \<= enddate)

);

\--

\-- Create the 'salesemp' view

\--

CREATE OR REPLACE VIEW salesemp AS

SELECT empno, ename, hiredate, sal, comm FROM emp WHERE job = 'SALESMAN';

\--

\-- Sequence to generate values for function 'new\_empno'.

\--

CREATE SEQUENCE next\_empno START WITH 8000 INCREMENT BY 1;

\--

\-- Issue PUBLIC grants

\--

\--GRANT ALL ON emp TO PUBLIC;

\--GRANT ALL ON dept TO PUBLIC;

\--GRANT ALL ON jobhist TO PUBLIC;

\--GRANT ALL ON salesemp TO PUBLIC;

\--GRANT ALL ON next\_empno TO PUBLIC;

\--

\-- Load the 'dept' table

\--

INSERT INTO dept VALUES (10,'ACCOUNTING','NEW YORK');

INSERT INTO dept VALUES (20,'RESEARCH','DALLAS');

INSERT INTO dept VALUES (30,'SALES','CHICAGO');

INSERT INTO dept VALUES (40,'OPERATIONS','BOSTON');

\--

\-- Load the 'emp' table

\--

INSERT INTO emp VALUES (7369,'SMITH','CLERK',7902,'17-DEC-80',800,NULL,20);

INSERT INTO emp VALUES (7499,'ALLEN','SALESMAN',7698,'20-FEB-81',1600,300,30);

INSERT INTO emp VALUES (7521,'WARD','SALESMAN',7698,'22-FEB-81',1250,500,30);

INSERT INTO emp VALUES (7566,'JONES','MANAGER',7839,'02-APR-81',2975,NULL,20);

INSERT INTO emp VALUES (7654,'MARTIN','SALESMAN',7698,'28-SEP-81',1250,1400,30);

INSERT INTO emp VALUES (7698,'BLAKE','MANAGER',7839,'01-MAY-81',2850,NULL,30);

INSERT INTO emp VALUES (7782,'CLARK','MANAGER',7839,'09-JUN-81',2450,NULL,10);

INSERT INTO emp VALUES (7788,'SCOTT','ANALYST',7566,'19-APR-87',3000,NULL,20);

INSERT INTO emp VALUES (7839,'KING','PRESIDENT',NULL,'17-NOV-81',5000,NULL,10);

INSERT INTO emp VALUES (7844,'TURNER','SALESMAN',7698,'08-SEP-81',1500,0,30);

INSERT INTO emp VALUES (7876,'ADAMS','CLERK',7788,'23-MAY-87',1100,NULL,20);

INSERT INTO emp VALUES (7900,'JAMES','CLERK',7698,'03-DEC-81',950,NULL,30);

INSERT INTO emp VALUES (7902,'FORD','ANALYST',7566,'03-DEC-81',3000,NULL,20);

INSERT INTO emp VALUES (7934,'MILLER','CLERK',7782,'23-JAN-82',1300,NULL,10);

\--

\-- Load the 'jobhist' table

\--

INSERT INTO jobhist VALUES (7369,'17-DEC-80',NULL,'CLERK',800,NULL,20,'New Hire');

INSERT INTO jobhist VALUES (7499,'20-FEB-81',NULL,'SALESMAN',1600,300,30,'New Hire');

INSERT INTO jobhist VALUES (7521,'22-FEB-81',NULL,'SALESMAN',1250,500,30,'New Hire');

INSERT INTO jobhist VALUES (7566,'02-APR-81',NULL,'MANAGER',2975,NULL,20,'New Hire');

INSERT INTO jobhist VALUES (7654,'28-SEP-81',NULL,'SALESMAN',1250,1400,30,'New Hire');

INSERT INTO jobhist VALUES (7698,'01-MAY-81',NULL,'MANAGER',2850,NULL,30,'New Hire');

INSERT INTO jobhist VALUES (7782,'09-JUN-81',NULL,'MANAGER',2450,NULL,10,'New Hire');

INSERT INTO jobhist VALUES (7788,'19-APR-87','12-APR-88','CLERK',1000,NULL,20,'New Hire');

INSERT INTO jobhist VALUES (7788,'13-APR-88','04-MAY-89','CLERK',1040,NULL,20,'Raise');

INSERT INTO jobhist VALUES (7788,'05-MAY-90',NULL,'ANALYST',3000,NULL,20,'Promoted to Analyst');

INSERT INTO jobhist VALUES (7839,'17-NOV-81',NULL,'PRESIDENT',5000,NULL,10,'New Hire');

INSERT INTO jobhist VALUES (7844,'08-SEP-81',NULL,'SALESMAN',1500,0,30,'New Hire');

INSERT INTO jobhist VALUES (7876,'23-MAY-87',NULL,'CLERK',1100,NULL,20,'New Hire');

INSERT INTO jobhist VALUES (7900,'03-DEC-81','14-JAN-83','CLERK',950,NULL,10,'New Hire');

INSERT INTO jobhist VALUES (7900,'15-JAN-83',NULL,'CLERK',950,NULL,30,'Changed to Dept 30');

INSERT INTO jobhist VALUES (7902,'03-DEC-81',NULL,'ANALYST',3000,NULL,20,'New Hire');

INSERT INTO jobhist VALUES (7934,'23-JAN-82',NULL,'CLERK',1300,NULL,10,'New Hire');

\--

\-- Populate statistics table and view (pg\_statistic/pg\_stats)

\--

ANALYZE dept;

ANALYZE emp;

ANALYZE jobhist;

\--

\-- Function that lists all employees' numbers and names

\-- from the 'emp' table using a cursor.

\--

CREATE OR REPLACE FUNCTION list\_emp() RETURNS VOID

AS $$

DECLARE

v\_empno NUMERIC(4);

v\_ename VARCHAR(10);

emp\_cur CURSOR FOR

SELECT empno, ename FROM emp ORDER BY empno;

BEGIN

OPEN emp\_cur;

RAISE INFO 'EMPNO ENAME';

RAISE INFO '----- -------';

LOOP

FETCH emp\_cur INTO v\_empno, v\_ename;

EXIT WHEN NOT FOUND;

RAISE INFO '% %', v\_empno, v\_ename;

END LOOP;

CLOSE emp\_cur;

RETURN;

END;

$$ LANGUAGE 'plpgsql';

\--

\-- Function that selects an employee row given the employee

\-- number and displays certain columns.

\--

CREATE OR REPLACE FUNCTION select\_emp (

p\_empno NUMERIC

) RETURNS VOID

AS $$

DECLARE

v\_ename emp.ename%TYPE;

v\_hiredate emp.hiredate%TYPE;

v\_sal emp.sal%TYPE;

v\_comm emp.comm%TYPE;

v\_dname dept.dname%TYPE;

v\_disp\_date VARCHAR(10);

BEGIN

SELECT INTO

v\_ename, v\_hiredate, v\_sal, v\_comm, v\_dname

ename, hiredate, sal, COALESCE(comm, 0), dname

FROM emp e, dept d

WHERE empno = p\_empno

AND e.deptno = d.deptno;

IF NOT FOUND THEN

RAISE INFO 'Employee % not found', p\_empno;

RETURN;

END IF;

v\_disp\_date := TO\_CHAR(v\_hiredate, 'MM/DD/YYYY');

RAISE INFO 'Number : %', p\_empno;

RAISE INFO 'Name : %', v\_ename;

RAISE INFO 'Hire Date : %', v\_disp\_date;

RAISE INFO 'Salary : %', v\_sal;

RAISE INFO 'Commission: %', v\_comm;

RAISE INFO 'Department: %', v\_dname;

RETURN;

EXCEPTION

WHEN OTHERS THEN

RAISE INFO 'The following is SQLERRM : %', SQLERRM;

RAISE INFO 'The following is SQLSTATE: %', SQLSTATE;

RETURN;

END;

$$ LANGUAGE 'plpgsql';

\--

\-- A RECORD type used to format the return value of

\-- function, 'emp\_query'.

\--

CREATE TYPE emp\_query\_type AS (

empno NUMERIC,

ename VARCHAR(10),

job VARCHAR(9),

hiredate DATE,

sal NUMERIC

);

\--

\-- Function that queries the 'emp' table based on

\-- department number and employee number or name. Returns

\-- employee number and name as INOUT parameters and job,

\-- hire date, and salary as OUT parameters. These are

\-- returned in the form of a record defined by

\-- RECORD type, 'emp\_query\_type'.

\--

CREATE OR REPLACE FUNCTION emp\_query (

IN p\_deptno NUMERIC,

INOUT p\_empno NUMERIC,

INOUT p\_ename VARCHAR,

OUT p\_job VARCHAR,

OUT p\_hiredate DATE,

OUT p\_sal NUMERIC

)

AS $$

BEGIN

SELECT INTO

p\_empno, p\_ename, p\_job, p\_hiredate, p\_sal

empno, ename, job, hiredate, sal

FROM emp

WHERE deptno = p\_deptno

AND (empno = p\_empno

OR ename = UPPER(p\_ename));

END;

$$ LANGUAGE 'plpgsql';

\--

\-- Function to call 'emp\_query\_caller' with IN and INOUT

\-- parameters. Displays the results received from INOUT and

\-- OUT parameters.

\--

CREATE OR REPLACE FUNCTION emp\_query\_caller() RETURNS VOID

AS $$

DECLARE

v\_deptno NUMERIC;

v\_empno NUMERIC;

v\_ename VARCHAR;

v\_rows INTEGER;

r\_emp\_query EMP\_QUERY\_TYPE;

BEGIN

v\_deptno := 30;

v\_empno := 0;

v\_ename := 'Martin';

r\_emp\_query := emp\_query(v\_deptno, v\_empno, v\_ename);

RAISE INFO 'Department : %', v\_deptno;

RAISE INFO 'Employee No: %', (r\_emp\_query).empno;

RAISE INFO 'Name : %', (r\_emp\_query).ename;

RAISE INFO 'Job : %', (r\_emp\_query).job;

RAISE INFO 'Hire Date : %', (r\_emp\_query).hiredate;

RAISE INFO 'Salary : %', (r\_emp\_query).sal;

RETURN;

EXCEPTION

WHEN OTHERS THEN

RAISE INFO 'The following is SQLERRM : %', SQLERRM;

RAISE INFO 'The following is SQLSTATE: %', SQLSTATE;

RETURN;

END;

$$ LANGUAGE 'plpgsql';

\--

\-- Function to compute yearly compensation based on semimonthly

\-- salary.

\--

CREATE OR REPLACE FUNCTION emp\_comp (

p\_sal NUMERIC,

p\_comm NUMERIC

) RETURNS NUMERIC

AS $$

BEGIN

RETURN (p\_sal + COALESCE(p\_comm, 0)) \* 24;

END;

$$ LANGUAGE 'plpgsql';

\--

\-- Function that gets the next number from sequence, 'next\_empno',

\-- and ensures it is not already in use as an employee number.

\--

CREATE OR REPLACE FUNCTION new\_empno() RETURNS INTEGER

AS $$

DECLARE

v\_cnt INTEGER := 1;

v\_new\_empno INTEGER;

BEGIN

WHILE v\_cnt \> 0 LOOP

SELECT INTO v\_new\_empno nextval('next\_empno');

SELECT INTO v\_cnt COUNT(\*) FROM emp WHERE empno = v\_new\_empno;

END LOOP;

RETURN v\_new\_empno;

END;

$$ LANGUAGE 'plpgsql';

\--

\-- Function that adds a new clerk to table 'emp'.

\--

CREATE OR REPLACE FUNCTION hire\_clerk (

p\_ename VARCHAR,

p\_deptno NUMERIC

) RETURNS NUMERIC

AS $$

DECLARE

v\_empno NUMERIC(4);

v\_ename VARCHAR(10);

v\_job VARCHAR(9);

v\_mgr NUMERIC(4);

v\_hiredate DATE;

v\_sal NUMERIC(7,2);

v\_comm NUMERIC(7,2);

v\_deptno NUMERIC(2);

BEGIN

v\_empno := new\_empno();

INSERT INTO emp VALUES (v\_empno, p\_ename, 'CLERK', 7782,

CURRENT\_DATE, 950.00, NULL, p\_deptno);

SELECT INTO

v\_empno, v\_ename, v\_job, v\_mgr, v\_hiredate, v\_sal, v\_comm, v\_deptno

empno, ename, job, mgr, hiredate, sal, comm, deptno

FROM emp WHERE empno = v\_empno;

RAISE INFO 'Department : %', v\_deptno;

RAISE INFO 'Employee No: %', v\_empno;

RAISE INFO 'Name : %', v\_ename;

RAISE INFO 'Job : %', v\_job;

RAISE INFO 'Manager : %', v\_mgr;

RAISE INFO 'Hire Date : %', v\_hiredate;

RAISE INFO 'Salary : %', v\_sal;

RAISE INFO 'Commission : %', v\_comm;

RETURN v\_empno;

EXCEPTION

WHEN OTHERS THEN

RAISE INFO 'The following is SQLERRM : %', SQLERRM;

RAISE INFO 'The following is SQLSTATE: %', SQLSTATE;

RETURN -1;

END;

$$ LANGUAGE 'plpgsql';

\--

\-- Function that adds a new salesman to table 'emp'.

\--

CREATE OR REPLACE FUNCTION hire\_salesman (

p\_ename VARCHAR,

p\_sal NUMERIC,

p\_comm NUMERIC

) RETURNS NUMERIC

AS $$

DECLARE

v\_empno NUMERIC(4);

v\_ename VARCHAR(10);

v\_job VARCHAR(9);

v\_mgr NUMERIC(4);

v\_hiredate DATE;

v\_sal NUMERIC(7,2);

v\_comm NUMERIC(7,2);

v\_deptno NUMERIC(2);

BEGIN

v\_empno := new\_empno();

INSERT INTO emp VALUES (v\_empno, p\_ename, 'SALESMAN', 7698,

CURRENT\_DATE, p\_sal, p\_comm, 30);

SELECT INTO

v\_empno, v\_ename, v\_job, v\_mgr, v\_hiredate, v\_sal, v\_comm, v\_deptno

empno, ename, job, mgr, hiredate, sal, comm, deptno

FROM emp WHERE empno = v\_empno;

RAISE INFO 'Department : %', v\_deptno;

RAISE INFO 'Employee No: %', v\_empno;

RAISE INFO 'Name : %', v\_ename;

RAISE INFO 'Job : %', v\_job;

RAISE INFO 'Manager : %', v\_mgr;

RAISE INFO 'Hire Date : %', v\_hiredate;

RAISE INFO 'Salary : %', v\_sal;

RAISE INFO 'Commission : %', v\_comm;

RETURN v\_empno;

EXCEPTION

WHEN OTHERS THEN

RAISE INFO 'The following is SQLERRM : %', SQLERRM;

RAISE INFO 'The following is SQLSTATE: %', SQLSTATE;

RETURN -1;

END;

$$ LANGUAGE 'plpgsql';

\--

\-- Rule to INSERT into view 'salesemp'

\--

CREATE OR REPLACE RULE salesemp\_i AS ON INSERT TO salesemp

DO INSTEAD

INSERT INTO emp VALUES (NEW.empno, NEW.ename, 'SALESMAN', 7698,

NEW.hiredate, NEW.sal, NEW.comm, 30);

\--

\-- Rule to UPDATE view 'salesemp'

\--

CREATE OR REPLACE RULE salesemp\_u AS ON UPDATE TO salesemp

DO INSTEAD

UPDATE emp SET empno = NEW.empno,

ename = NEW.ename,

hiredate = NEW.hiredate,

sal = NEW.sal,

comm = NEW.comm

WHERE empno = OLD.empno;

\--

\-- Rule to DELETE from view 'salesemp'

\--

CREATE OR REPLACE RULE salesemp\_d AS ON DELETE TO salesemp

DO INSTEAD

DELETE FROM emp WHERE empno = OLD.empno;

\--

\-- After statement-level trigger that displays a message after

\-- an insert, update, or deletion to the 'emp' table. One message

\-- per SQL command is displayed.

\--

CREATE OR REPLACE FUNCTION user\_audit\_trig() RETURNS TRIGGER

AS $$

DECLARE

v\_action VARCHAR(24);

v\_text TEXT;

BEGIN

IF TG\_OP = 'INSERT' THEN

v\_action := ' added employee(s) on ';

ELSIF TG\_OP = 'UPDATE' THEN

v\_action := ' updated employee(s) on ';

ELSIF TG\_OP = 'DELETE' THEN

v\_action := ' deleted employee(s) on ';

END IF;

v\_text := 'User ' || USER || v\_action || CURRENT\_DATE;

RAISE INFO ' %', v\_text;

RETURN NULL;

END;

$$ LANGUAGE 'plpgsql';

CREATE TRIGGER user\_audit\_trig

AFTER INSERT OR UPDATE OR DELETE ON emp

FOR EACH STATEMENT EXECUTE PROCEDURE user\_audit\_trig();

\--

\-- Before row-level trigger that displays employee number and

\-- salary of an employee that is about to be added, updated,

\-- or deleted in the 'emp' table.

\--

CREATE OR REPLACE FUNCTION emp\_sal\_trig() RETURNS TRIGGER

AS $$

DECLARE

sal\_diff NUMERIC(7,2);

BEGIN

IF TG\_OP = 'INSERT' THEN

RAISE INFO 'Inserting employee %', NEW.empno;

RAISE INFO '..New salary: %', NEW.sal;

RETURN NEW;

END IF;

IF TG\_OP = 'UPDATE' THEN

sal\_diff := NEW.sal - OLD.sal;

RAISE INFO 'Updating employee %', OLD.empno;

RAISE INFO '..Old salary: %', OLD.sal;

RAISE INFO '..New salary: %', NEW.sal;

RAISE INFO '..Raise : %', sal\_diff;

RETURN NEW;

END IF;

IF TG\_OP = 'DELETE' THEN

RAISE INFO 'Deleting employee %', OLD.empno;

RAISE INFO '..Old salary: %', OLD.sal;

RETURN OLD;

END IF;

END;

$$ LANGUAGE 'plpgsql';

CREATE TRIGGER emp\_sal\_trig

BEFORE DELETE OR INSERT OR UPDATE ON emp

FOR EACH ROW EXECUTE PROCEDURE emp\_sal\_trig();

COMMIT;

