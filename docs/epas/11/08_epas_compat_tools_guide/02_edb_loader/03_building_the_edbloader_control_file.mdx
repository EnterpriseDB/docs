---

title: "Building the EDB*Loader Control File"
---

<div id="building_the_edbloader_control_file" class="registered_link"></div>

When you invoke EDB\*Loader, the list of arguments provided must include the name of a control file. The control file includes the instructions that EDB*Loader uses to load the table (or tables) from the input data file. The control file includes information such as:

- The name of the input data file containing the data to be loaded.
- The name of the table or tables to be loaded from the data file.
- Names of the columns within the table or tables and their corresponding field placement in the data file.
- Specification of whether the data file uses a delimiter string to separate the fields, or if the fields occupy fixed column positions.
- Optional selection criteria to choose which records from the data file to load into a given table.
- The name of the file that will collect illegally formatted records.
- The name of the discard file that will collect records that do not meet the selection criteria of any table.

The syntax for the EDB*Loader control file is as follows:

> `[ OPTIONS (`*`param`*`=`*`value`* `[,` *`param`*`=`*`value`* `] ...) ]`
>
> `LOAD DATA`
>
>   `[ CHARACTERSET` *`charset`* `]`
>
>   `[ INFILE '{` *`data_file`* `| stdin }' ]`
>
>   `[ BADFILE '`*`bad_file`*`' ]`
>
>   `[ DISCARDFILE '`*`discard_file`*' `]`
>
>   `[ { DISCARDMAX | DISCARDS }` *`max_discard_recs`* `]`
>
> `[ INSERT | APPEND | REPLACE | TRUNCATE ]`
>
> `[ PRESERVE BLANKS ]`
>
> `{ INTO TABLE` *`target_table`*
>
>   `[ WHEN` *`field_condition`* `[ AND` *`field_condition`* `] ...]`
>
>   `[ FIELDS TERMINATED BY '`*`termstring`*`'`
>
> â€‹    `[ OPTIONALLY ENCLOSED BY '`*`enclstring`*`' ] ]`
>
>   `[ RECORDS DELIMITED BY '`*`delimstring`*`' ]`
>
>   `[ TRAILING NULLCOLS ]`
>
>    `(`*`field_def`* `[,` *`field_def`* `] ...)`
>
> `} ...`

where *`field_def`* defines a field in the specified *`data_file`* that describes the location, data format, or value of the data to be inserted into *`column_name`* of the *`target_table`*. The syntax of *`field_def`* is the following:

> *`column_name`* `{`
>
>   `CONSTANT` *`val`* `|`
>
>   `FILLER [ POSITION (`*`start`*`:`*`end`*`) ] [` *`fieldtype`* `] |`
>
>   `BOUNDFILLER [ POSITION (`*`start`*`:`*`end`*`) ] [` *`fieldtype`* `] |`
>
>   `[ POSITION (`*`start`*`:`*`end`*`) ] [` *`fieldtype`* `]`
>
>   `[ NULLIF` *`field_condition`* `[ AND` *`field_condition`* `] ...]`
>
>   `[ PRESERVE BLANKS ] [ "`*`expr`*`" ]`
>
> `}`

where *`fieldtype`* is one of:

> `CHAR [(`*`length`*`)] | DATE [(`*`length`*`)] [ "`*`datemask`*`" ] |`
>
> `INTEGER EXTERNAL [(`*`length`*`)] |`
> `FLOAT EXTERNAL [(`*`length`*`)] | DECIMAL EXTERNAL [(`*`length`*`)] |`
>
> `ZONED EXTERNAL [(`*`length`*`)] | ZONED [(`*`precision`*`[,`*`scale`*`])]`

**Description**

The specification of *`data_file`*, *`bad_file`*, and *`discard_file`* may include the full directory path or a relative directory path to the file name. If the file name is specified alone or with a relative directory path, the file is then assumed to exist (in the case of *`data_file`*), or is created (in the case of *`bad_file`* or *`discard_file`*), relative to the current working directory from which `edbldr` is invoked.

You can include references to environment variables within the EDB*Loader control file when referring to a directory path and/or file name. Environment variable references are formatted differently on Windows systems than on Linux systems:

- On Linux, the format is `$ENV_VARIABLE or ${ENV_VARIABLE}`
- On Windows, the format is `%ENV_VARIABLE%`

Where *`ENV_VARIABLE`* is the environment variable that is set to the directory path and/or file name.

The `EDBLDR_ENV_STYLE` environment variable instructs Advanced Server to interpret environment variable references as Windows-styled references or Linux-styled references irregardless of the operating system on which EDB\*Loader resides. You can use this environment variable to create portable control files for EDB*Loader.

- On a Windows system, set `EDBLDR_ENV_STYLE` to `linux` or `unix` to instruct Advanced Server to recognize Linux-style references within the control file.
- On a Linux system, set `EDBLDR_ENV_STYLE` to `windows` to instruct Advanced Server to recognize Windows-style references within the control file.

The operating system account `enterprisedb` must have read permission on the directory and file specified by *`data_file`*.

The operating system account `enterprisedb` must have write permission on the directories where *`bad_file`* and *`discard_file`* are to be written.

**Note:** It is suggested that the file names for *`data_file`*, *`bad_file`*, and *`discard_file`* include extensions of .`dat`, .`bad`, and .`dsc`, respectively. If the provided file name does not contain an extension, EDB\*Loader assumes the actual file name includes the appropriate aforementioned extension.

If an EDB\*Loader session results in data format errors and the `BADFILE` clause is not specified, nor is the `BAD` parameter given on the command line when `edbldr` is invoked, a bad file is created with the name *`control_file_base`*`.bad` in the current working directory from which `edbldr` is invoked. *`control_file_base`* is the base name of the control file (that is, the file name without any extension) used in the `edbldr` session.

If all of the following conditions are true, the discard file is not created even if the EDB*Loader session results in discarded records:

- The `DISCARDFILE` clause for specifying the discard file is not included in the control file.
- The `DISCARD` parameter for specifying the discard file is not included on the command line.
- The `DISCARDMAX` clause for specifying the maximum number of discarded records is not included in the control file.
- The `DISCARDS` clause for specifying the maximum number of discarded records is not included in the control file.
- The `DISCARDMAX` parameter for specifying the maximum number of discarded records is not included on the command line.

If neither the `DISCARDFILE` clause nor the `DISCARD` parameter for explicitly specifying the discard file name are specified, but `DISCARDMAX` or `DISCARDS` is specified, then the EDB*Loader session creates a discard file using the data file name with an extension of .`dsc`.

**Note:** There is a distinction between keywords `DISCARD` and `DISCARDS`. `DISCARD` is an EDB\*Loader command line parameter used to specify the discard file name (see Section [2.2](https://www.enterprisedb.com/edb-docs/d/edb-postgres-advanced-server/user-guides/database-compatibility-for-oracle-developers-tools-and-utilities-guide/11/Database_Compatibility_for_Oracle_Developers_Tools_and_Utilities_Guide.1.06.html#)). `DISCARDS` is a clause of the `LOAD DATA` directive that may only appear in the control file. Keywords `DISCARDS` and `DISCARDMAX` provide the same functionality of specifying the maximum number of discarded records allowed before terminating the EDB\*Loader session. Records loaded into the database before termination of the EDB\*Loader session due to exceeding the `DISCARDS` or `DISCARDMAX` settings are kept in the database and are not rolled back.

If one of `INSERT`, `APPEND`, `REPLACE`, or `TRUNCATE` is specified, it establishes the default action of how rows are to be added to target tables. If omitted, the default action is as if `INSERT` had been specified.

If the `FIELDS TERMINATED BY` clause is specified, then the `POSITION` `(`*`start`*`:`*`end`*`)` clause may not be specified for any *`field_def`*. Alternatively if the `FIELDS TERMINATED BY` clause is not specified, then every *`field_def`* must contain either the `POSITION` `(`*`start`*`:`*`end`*`)` clause, the *`fieldtype`*`(`*`length`*`)` clause, or the `CONSTANT` clause.

**Parameters**

`OPTIONS` *`param`*`=`*`value`*

Use the `OPTIONS` clause to specify *`param`*`=`*`value`* pairs that represent an EDB\*Loader directive. If a parameter is specified in both the `OPTIONS` clause and on the command line when `edbldr` is invoked, the command line setting is used.

Specify one or more of the following parameter/value pairs:

`DIRECT= { FALSE | TRUE }`

> If `DIRECT` is set to `TRUE` EDB\*Loader performs a direct path load instead of a conventional path load. The default value of `DIRECT` is `FALSE`.
>
> See Section [2.5](https://www.enterprisedb.com/edb-docs/d/edb-postgres-advanced-server/user-guides/database-compatibility-for-oracle-developers-tools-and-utilities-guide/11/Database_Compatibility_for_Oracle_Developers_Tools_and_Utilities_Guide.1.09.html#) for information on direct path loads.

`ERRORS=`*`error_count`*

> *`error_count`* specifies the number of errors permitted before aborting the EDB\*Loader session. The default is `50`.

`FREEZE= { FALSE | TRUE }`

> Set `FREEZE` to `TRUE` to indicate that the data should be copied with the rows *frozen*. A tuple guaranteed to be visible to all current and future transactions is marked as frozen to prevent transaction ID wrap-around. For more information about frozen tuples, see the PostgreSQL core documentation at:
>
> https://www.postgresql.org/docs/11/static/routine-vacuuming.html
>
> You must specify a data-loading type of `TRUNCATE` in the control file when using the `FREEZE` option. `FREEZE` is not supported for direct loading.
>
> By default, `FREEZE` is `FALSE`.

`PARALLEL= { FALSE | TRUE }`

> Set `PARALLEL` to `TRUE` to indicate that this EDB\*Loader session is one of a number of concurrent EDB\*Loader sessions participating in a parallel direct path load. The default value of `PARALLEL` is `FALSE`.
>
> When `PARALLEL` is `TRUE`, the `DIRECT` parameter must also be set to `TRUE` . See Section [2.6](https://www.enterprisedb.com/edb-docs/d/edb-postgres-advanced-server/user-guides/database-compatibility-for-oracle-developers-tools-and-utilities-guide/11/Database_Compatibility_for_Oracle_Developers_Tools_and_Utilities_Guide.1.10.html#) for more information about parallel direct path loads.

`ROWS=`*`n`*

> *`n`* specifies the number of rows that EDB\*Loader will commit before loading the next set of *n* rows.
>
> If EDB\*Loader encounters an invalid row during a load (in which the ROWS parameter is specified), those rows committed prior to encountering the error will remain in the destination table.

`SKIP=`*`skip_count`*

> *`skip_count`* specifies the number of records at the beginning of the input data file that should be skipped before loading begins. The default is `0`.

`SKIP_INDEX_MAINTENANCE={ FALSE | TRUE }`

> If `SKIP_INDEX_MAINTENANCE` is `TRUE`, index maintenance is not performed as part of a direct path load, and indexes on the loaded table are marked as invalid. The default value of `SKIP_INDEX_MAINTENANCE` is `FALSE`.
>
> Please note: During a parallel direct path load, target table indexes are not updated, and are marked as invalid after the load is complete.
>
> You can use the `REINDEX` command to rebuild an index. For more information about the `REINDEX` command, see the PostgreSQL core documentation available at:
>
> https://www.postgresql.org/docs/11/static/sql-reindex.html

*`charset`*

> Use the `CHARACTERSET` clause to identify the character set encoding of *`data_file`* where *`charset`* is the character set name. This clause is required if the data file encoding differs from the control file encoding. (The control file encoding must always be in the encoding of the client where `edbldr` is invoked.)
>
> Examples of *`charset`* settings are `UTF8`, `SQL_ASCII`, and `SJIS`.
>
> For more information about client to database character set conversion, see the PostgreSQL core documentation available at:
>
> https://www.postgresql.org/docs/11/static/multibyte.html

*`data_file`*

> File containing the data to be loaded into *`target_table`*. Each record in the data file corresponds to a row to be inserted into *`target_table`*.
>
> If an extension is not provided in the file name, EDB\*Loader assumes the file has an extension of .`dat`, for example, `mydatafile.dat`.
>
> **Note:** If the `DATA` parameter is specified on the command line when `edbldr` is invoked, the file given by the command line `DATA` parameter is used instead.
>
> If the `INFILE` clause is omitted as well as the command line `DATA` parameter, then the data file name is assumed to be identical to the control file name, but with an extension of .`dat`.

`stdin`

> Specify `stdin` (all lowercase letters) if you want to use standard input to pipe the data to be loaded directly to EDB\*Loader. This is useful for data sources generating a large number of records to be loaded.

*`bad_file`*

> File that receives *`data_file`* records that cannot be loaded due to errors.
>
> If an extension is not provided in the file name, EDB\*Loader assumes the file has an extension of .`bad`, for example, `mybadfile.bad`.
>
> **Note:** If the `BAD` parameter is specified on the command line when `edbldr` is invoked, the file given by the command line `BAD` parameter is used instead.

*`discard_file`*

> File that receives input data records that are not loaded into any table because none of the selection criteria are met for tables with the `WHEN` clause, and there are no tables without a `WHEN` clause. (All records meet the selection criteria of a table without a `WHEN` clause.)
>
> If an extension is not provided in the file name, EDB\*Loader assumes the file has an extension of .`dsc`, for example, `mydiscardfile.dsc`.
>
> **Note:** If the `DISCARD` parameter is specified on the command line when `edbldr` is invoked, the file given by the command line `DISCARD` parameter is used instead.

`{ DISCARDMAX | DISCARDS }` *`max_discard_recs`*

> Maximum number of discarded records that may be encountered from the input data records before terminating the EDB\*Loader session. (A discarded record is described in the preceding description of the *`discard_file`* parameter.) Either keyword `DISCARDMAX` or `DISCARDS` may be used preceding the integer value specified by *`max_discard_recs`*.
>
> For example, if *max~_discard_recs* is ~0, then the EDB\*Loader session is terminated if and when a first discarded record is encountered. If *`max_discard_recs`* is 1, then the EDB\*Loader session is terminated if and when a second discarded record is encountered.
>
> When the EDB\*Loader session is terminated due to exceeding *`max_discard_recs`*, prior input data records that have been loaded into the database are retained. They are not rolled back.

`INSERT | APPEND | REPLACE | TRUNCATE`

> Specifies how data is to be loaded into the target tables. If one of `INSERT`, `APPEND`, `REPLACE`, or `TRUNCATE` is specified, it establishes the default action for all tables, overriding the default of `INSERT`.
>
> `INSERT`
>
> > Data is to be loaded into an empty table. EDB\*Loader throws an exception and does not load any data if the table is not initially empty.
> >
> > **Note:** If the table contains rows, the `TRUNCATE` command must be used to empty the table prior to invoking EDB\*Loader. EDB\*Loader throws an exception if the `DELETE` command is used to empty the table instead of the `TRUNCATE` command. Oracle SQL\*Loader allows the table to be emptied by using either the `DELETE` or `TRUNCATE` command.
>
> `APPEND`
>
> > Data is to be added to any existing rows in the table. The table may be initially empty as well.
>
> `REPLACE`
>
> > The `REPLACE` keyword and `TRUNCATE` keywords are functionally identical. The table is truncated by EDB\*Loader prior to loading the new data.
> >
> > **Note:** Delete triggers on the table are not fired as a result of the `REPLACE` operation.
>
> `TRUNCATE`
>
> > The table is truncated by EDB\*Loader prior to loading the new data. Delete triggers on the table are not fired as a result of the `TRUNCATE` operation.

`PRESERVE BLANKS`

> For all target tables, retains leading white space when the optional enclosure delimiters are not present and leaves trailing white space intact when fields are specified with a predetermined size. When omitted, the default behavior is to trim leading and trailing white space.

*`target_table`*

> Name of the table into which data is to be loaded. The table name may be schema-qualified (for example, `enterprisedb.emp`). The specified target must not be a view.

*`field_condition`*

> Conditional clause taking the following form:
>
> `[ ( ] { (`*`start`*`:`*`end`*`) |` *`column_name`* `} { = | != | <> }`
>
>   `'`*`val`*`' [ ) ]`
>
> This conditional clause is used for the `WHEN` clause, which is part of the `INTO TABLE` *`target_table`* clause, and the `NULLIF` clause, which is part of the field definition denoted as *`field_def`* in the syntax diagram.
>
> *`start`* and *`end`* are positive integers specifying the column positions in *`data_file`* that mark the beginning and end of a field that is to be compared with the constant *`val`*. The first character in each record begins with a *`start`* value of 1.
>
> *`column_name`* specifies the name assigned to a field definition of the data file as defined by *`field_def`* in the syntax diagram.
>
> Use of either `(`*`start`*`:`*`end`*`)` or *`column_name`* defines the portion of the record in *`data_file`* that is to be compared with the value specified by '*`val`*' to evaluate as either true or false.
>
> All characters used in the *`field_condition`* text (particularly in the *`val`* string) must be valid in the database encoding. (For performing data conversion, EDB\*Loader first converts the characters in *`val`* string to the database encoding and then to the data file encoding.)
>
> In the `WHEN` *`field_condition`* `[ AND` *`field_condition`* `]` clause, if all such conditions evaluate to TRUE for a given record, then EDB\*Loader attempts to insert that record into *`target_table`*. If the insert operation fails, the record is written to *`bad_file`*.
>
> If for a given record, none of the `WHEN` clauses evaluate to `TRUE` for all `INTO TABLE` clauses, the record is written to *`discard_file`*, if a discard file was specified for the EDB\*Loader session.
>
> See the description of the `NULLIF` clause in this Parameters list for the effect of *`field_condition`* on this clause.

*`termstring`*

> String of one or more characters that separates each field in *`data_file`*. The characters may be single-byte or multi-byte as long as they are valid in the database encoding. Two consecutive appearances of *`termstring`* with no intervening character results in the corresponding column set to null.

*`enclstring`*

> String of one or more characters used to enclose a field value in *`data_file`*. The characters may be single-byte or multi-byte as long as they are valid in the database encoding. Use *`enclstring`* on fields where *`termstring`* appears as part of the data.

*`delimstring`*

> String of one or more characters that separates each record in *`data_file`*. The characters may be single-byte or multi-byte as long as they are valid in the database encoding. Two consecutive appearances of *`delimstring`* with no intervening character results in no corresponding row loaded into the table. The last record (in other words, the end of the data file) must also be terminated by the *`delimstring`* characters, otherwise the final record is not loaded into the table.
>
> **Note:** The `RECORDS DELIMITED BY '`*`delimstring`*`'` clause is not compatible with Oracle databases.

`TRAILING NULLCOLS`

> If `TRAILING NULLCOLS` is specified, then the columns in the column list for which there is no data in *`data_file`* for a given record, are set to null when the row is inserted. This applies only to one or more consecutive columns at the end of the column list.
>
> If fields are omitted at the end of a record and `TRAILING NULLCOLS` is not specified, EDB\*Loader assumes the record contains formatting errors and writes it to the bad file.

*`column_name`*

> Name of a column in *`target_table`* into which a field value defined by *`field_def`* is to be inserted. If the field definition includes the `FILLER` or `BOUNDFILLER` clause, then *`column_name`* is not required to be the name of a column in the table. It can be any identifier name since the `FILLER` and `BOUNDFILLER` clauses prevent the loading of the field data into a table column.

`CONSTANT` *`val`*

> Specifies a constant that is type-compatible with the column data type to which it is assigned in a field definition. Single or double quotes may enclose *`val`*. If *`val`* contains white space, then enclosing quotation marks must be used.
>
> The use of the `CONSTANT` clause completely determines the value to be assigned to a column in each inserted row. No other clause may appear in the same field definition.
>
> If the `TERMINATED BY` clause is used to delimit the fields in *`data_file`*, there must be no delimited field in *`data_file`* corresponding to any field definition with a `CONSTANT` clause. In other words, EDB\*Loader assumes there is no field in *`data_file`* for any field definition with a `CONSTANT` clause.

`FILLER`

> Specifies that the data in the field defined by the field definition is not to be loaded into the associated column if the identifier of the field definition is an actual column name in the table. In such case, the column is set to null. Use of the `FILLER` or `BOUNDFILLER` clause is the only circumstance in which the field definition does not have to be identified by an actual column name.
>
> Unlike the `BOUNDFILLER` clause, an identifier defined with the `FILLER` clause must not be referenced in a SQL expression. See the discussion of the *`expr`* parameter.

`BOUNDFILLER`

> Specifies that the data in the field defined by the field definition is not to be loaded into the associated column if the identifier of the field definition is an actual column name in the table. In such case, the column is set to null. Use of the `FILLER` or `BOUNDFILLER` clause is the only circumstance in which the field definition does not have to be identified by an actual column name.
>
> Unlike the `FILLER` clause, an identifier defined with the `BOUNDFILLER` clause may be referenced in a SQL expression. See the discussion of the *`expr`* parameter.

`POSITION (`*`start`*`:`*`end`*`)`

> Defines the location of the field in a record in a fixed-width field data file. *`start`* and *`end`* are positive integers. The first character in the record has a start value of `1`.

`CHAR [(`*`length`*`)] | DATE [(`*`length`*`)] [ "`*`datemask`*`" ] |`

`INTEGER EXTERNAL [(`*`length`*`)] |`
`FLOAT EXTERNAL [(`*`length`*`)] | DECIMAL EXTERNAL [(`*`length`*`)] |`

`ZONED EXTERNAL [(`*`length`*`)] | ZONED [(`*`precision`*`[,`*`scale`*`])]`

> Field type that describes the format of the data field in *`data_file`*.
>
> Note: Specification of a field type is optional (for descriptive purposes only) and has no effect on whether or not EDB\*Loader successfully inserts the data in the field into the table column. Successful loading depends upon the compatibility of the column data type and the field value. For example, a column with data type `NUMBER(7,2)` successfully accepts a field containing `2600`, but if the field contains a value such as `26XX`, the insertion fails and the record is written to *`bad_file`*.
>
> Please note that `ZONED` data is not human-readable; `ZONED` data is stored in an internal format where each digit is encoded in a separate nibble/nybble/4-bit field. In each `ZONED` value, the last byte contains a single digit (in the high-order 4 bits) and the sign (in the low-order 4 bits).

*`length`*

> Specifies the length of the value to be loaded into the associated column.
>
> If the `POSITION (`*`start`*`:`*`end`*`)` clause is specified along with a *`fieldtype`*`(`*`length`*`)` clause, then the ending position of the field is overridden by the specified *`length`* value. That is, the length of the value to be loaded into the column is determined by the *`length`* value beginning at the *`start`* position, and not by the *`end`* position of the `POSITION (`*`start`*`:`*`end`*`)` clause. Thus, the value to be loaded into the column may be shorter than the field defined by `POSITION (`*`start`*`:`*`end`*`),` or it may go beyond the *`end`* position depending upon the specified *`length`* size.
>
> If the `FIELDS TERMINATED BY '`*`termstring`*`'` clause is specified as part of the `INTO TABLE` clause, and a field definition contains the *`fieldtype`*`(`*`length`*`)` clause, then a record is accepted as long as the specified *`length`* values are greater than or equal to the field lengths as determined by the *`termstring`* characters enclosing all such fields of the record. If the specified *`length`* value is less than a field length as determined by the enclosing *`termstring`* characters for any such field, then the record is rejected.
>
> If the `FIELDS TERMINATED BY '`*`termstring`*`'` clause is not specified, and the `POSITION` (*`start`*`:`*`end`*`)` clause is not included with a field containing the *`fieldtype`*`(`*`length`*`)` clause, then the starting position of this field begins with the next character following the ending position of the preceding field. The ending position of the preceding field is either the end of its *`length`* value if the preceding field contains the *`fieldtype`*`(`*`length`*`)` clause, or by its *end* parameter if the field contains the `POSITION (`*`start`*`:`*`end`*`)` clause without the *`fieldtype`*`(`*`length`*`)` clause.

*`precision`*

> Use *`precision`* to specify the length of the `ZONED` value.
>
> If the *`precision`* value specified for `ZONED` conflicts with the length calculated by the server based on information provided with the `POSITION` clause, EDB\*Loader will use the value specified for *`precision`*.

*`scale`*

> *`scale`* specifies the number of digits to the right of the decimal point in a `ZONED` value*.*

*`datemask`*

> Specifies the ordering and abbreviation of the day, month, and year components of a date field.
>
> **Note:** If the `DATE` field type is specified along with a SQL expression for the column, then *`datemask`* must be specified after `DATE` and before the SQL expression. See the following discussion of the *`expr`* parameter.

`NULLIF` *`field_condition`* `[ AND` *field_condition* `] ...`

> **Note:** See the description of *`field_condition`* previously listed in this Parameters section for the syntax of *`field_condition`*.
>
> If all field conditions evaluate to TRUE, then the column identified by *`column_name`* in the field definition is set to null. If any field condition evaluates to `FALSE`, then the column is set to the appropriate value as would normally occur according to the field definition.

`PRESERVE BLANKS`

> For the column on which this option appears, retains leading white space when the optional enclosure delimiters are not present and leaves trailing white space intact when fields are specified with a predetermined size. When omitted, the default behavior is to trim leading and trailing white space.

*`expr`*

> A SQL expression returning a scalar value that is type-compatible with the column data type to which it is assigned in a field definition. Double quotes must enclose *`expr`*. *`expr`* may contain a reference to any column in the field list (except for fields with the FILLER clause) by prefixing the column name by a colon character (:).
>
> *`expr`* may also consist of a SQL `SELECT` statement. If a `SELECT` statement is used then the following rules must apply: 1) The `SELECT` statement must be enclosed within parentheses (`SELECT ...`). 2) The select list must consist of exactly one expression following the `SELECT` keyword. 3) The result set must not return more than one row. If no rows are returned, then the returned value of the resulting expression is null. The following is the syntax for use of the `SELECT` statement:
>
> `"(SELECT` *`expr`* `[ FROM` *`table_list`* `[ WHERE` *`condition`* `] ])"`
>
> **Note:** Omitting the `FROM` *`table_list`* clause is not compatible with Oracle databases. If no tables need to be specified, use of the `FROM DUAL` clause is compatible with Oracle databases.

**Examples**

The following are some examples of control files and their corresponding data files.

***Delimiter-Separated Field Data File***

The following control file uses a delimiter-separated data file that appends rows to the `emp` table:

```
LOAD DATA
  INFILE    'emp.dat'
    BADFILE 'emp.bad'
  APPEND
  INTO TABLE emp
    FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
    TRAILING NULLCOLS
  (
    empno,
    ename,
    job,
    mgr,
    hiredate,
    sal,
    deptno,
    comm
  )
```

In the preceding control file, the `APPEND` clause is used to allow the insertion of additional rows into the em~p table.

The following is the corresponding delimiter-separated data file:

```
9101,ROGERS,CLERK,7902,17-DEC-10,1980.00,20
9102,PETERSON,SALESMAN,7698,20-DEC-10,2600.00,30,2300.00
9103,WARREN,SALESMAN,7698,22-DEC-10,5250.00,30,2500.00
9104,"JONES, JR.",MANAGER,7839,02-APR-09,7975.00,20
```

The use of the `TRAILING NULLCOLS` clause allows the last field supplying the `comm` column to be omitted from the first and last records. The `comm` column is set to null for the rows inserted from these records.

The double quotation mark enclosure character surrounds the value `JONES, JR.` in the last record since the comma delimiter character is part of the field value.

The following query displays the rows added to the table after the EDB\*Loader session:

```
SELECT * FROM emp WHERE empno > 9100;

 empno |   ename    |   job    | mgr  |      hiredate      |   sal   |  comm   | deptno
-------+------------+----------+------+--------------------+---------+---------+--------
  9101 | ROGERS     | CLERK    | 7902 | 17-DEC-10 00:00:00 | 1980.00 |         |     20
  9102 | PETERSON   | SALESMAN | 7698 | 20-DEC-10 00:00:00 | 2600.00 | 2300.00 |     30
  9103 | WARREN     | SALESMAN | 7698 | 22-DEC-10 00:00:00 | 5250.00 | 2500.00 |     30
  9104 | JONES, JR. | MANAGER  | 7839 | 02-APR-09 00:00:00 | 7975.00 |         |     20
(4 rows)
```

***Fixed-Width Field Data File***

The following example is a control file that loads the same rows into the `emp` table, but uses a data file containing fixed-width fields:

```
LOAD DATA
  INFILE        'emp_fixed.dat'
    BADFILE     'emp_fixed.bad'
  APPEND
  INTO TABLE emp
    TRAILING NULLCOLS
  (
    empno       POSITION (1:4),
    ename       POSITION (5:14),
    job         POSITION (15:23),
    mgr         POSITION (24:27),
    hiredate    POSITION (28:38),
    sal         POSITION (39:46),
    deptno      POSITION (47:48),
    comm        POSITION (49:56)
  )
```

In the preceding control file, the `FIELDS TERMINATED BY` and `OPTIONALLY ENCLOSED BY` clauses are absent. Instead, each field now includes the `POSITION` clause.

The following is the corresponding data file containing fixed-width fields:

```
9101ROGERS    CLERK    790217-DEC-10   1980.0020
9102PETERSON  SALESMAN 769820-DEC-10   2600.0030 2300.00
9103WARREN    SALESMAN 769822-DEC-10   5250.0030 2500.00
9104JONES, JR.MANAGER  783902-APR-09   7975.0020
```

***Single Physical Record Data File â€“ RECORDS DELIMITED BY Clause***

The following example is a control file that loads the same rows into the `emp` table, but uses a data file with one physical record. Each individual record that is to be loaded as a row in the table is terminated by the semicolon character (;) specified by the `RECORDS DELIMITED BY` clause.

```
LOAD DATA
  INFILE    'emp_recdelim.dat'
    BADFILE 'emp_recdelim.bad'
  APPEND
  INTO TABLE emp
    FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
    RECORDS DELIMITED BY ';'
    TRAILING NULLCOLS
  (
    empno,
    ename,
    job,
    mgr,
    hiredate,
    sal,
    deptno,
    comm
  )
```

The following is the corresponding data file. The content is a single, physical record in the data file. The record delimiter character is included following the last record (that is, at the end of the file).

```
9101,ROGERS,CLERK,7902,17-DEC-10,1980.00,20,;9102,PETERSON,SALESMAN,7698,20-DEC-10,2600.00,30,2300.00;9103,WARREN,SALESMAN,7698,22-DEC-10,5250.00,30,2500.00;9104,"JONES, JR.",MANAGER,7839,02-APR-09,7975.00,20,;
```

**FILLER Clause**

The following control file illustrates the use of the `FILLER` clause in the data fields for the `sal` and co~mm columns. EDB\*Loader ignores the values in these fields and sets the corresponding columns to null.

```
LOAD DATA
  INFILE        'emp_fixed.dat'
    BADFILE     'emp_fixed.bad'
  APPEND
  INTO TABLE emp
    TRAILING NULLCOLS
  (
    empno       POSITION (1:4),
    ename       POSITION (5:14),
    job         POSITION (15:23),
    mgr         POSITION (24:27),
    hiredate    POSITION (28:38),
    sal         FILLER POSITION (39:46),
    deptno      POSITION (47:48),
    comm        FILLER POSITION (49:56)
  )
```

Using the same fixed-width data file as in the prior fixed-width field example, the resulting rows in the table appear as follows:

```
SELECT * FROM emp WHERE empno > 9100;

 empno |      ename       |   job    | mgr  |      hiredate      | sal | comm | deptno
-------+------------------+----------+------+--------------------+-----+------+--------
  9101 | ROGERS           | CLERK    | 7902 | 17-DEC-10 00:00:00 |     |      |     20
  9102 | PETERSON         | SALESMAN | 7698 | 20-DEC-10 00:00:00 |     |      |     30
  9103 | WARREN           | SALESMAN | 7698 | 22-DEC-10 00:00:00 |     |      |     30
  9104 | JONES, JR.       | MANAGER  | 7839 | 02-APR-09 00:00:00 |     |      |     20
(4 rows)
```

***BOUNDFILLER Clause***

The following control file illustrates the use of the `BOUNDFILLER` clause in the data fields for the `job` and `mgr` columns. EDB\*Loader ignores the values in these fields and sets the corresponding columns to null in the same manner as the `FILLER` clause. However, unlike columns with the `FILLER` clause, columns with the `BOUNDFILLER` clause are permitted to be used in an expression as shown for column `jobdesc`.

```
LOAD DATA
  INFILE    'emp.dat'
    BADFILE 'emp.bad'
  APPEND
  INTO TABLE empjob
    FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
    TRAILING NULLCOLS
  (
    empno,
    ename,
    job         BOUNDFILLER,
    mgr         BOUNDFILLER,
    hiredate    FILLER,
    sal         FILLER,
    deptno      FILLER,
    comm        FILLER,
    jobdesc     ":job || ' for manager ' || :mgr"
  )
```

The following is the delimiter-separated data file used in this example.

```
9101,ROGERS,CLERK,7902,17-DEC-10,1980.00,20
9102,PETERSON,SALESMAN,7698,20-DEC-10,2600.00,30,2300.00
9103,WARREN,SALESMAN,7698,22-DEC-10,5250.00,30,2500.00
9104,"JONES, JR.",MANAGER,7839,02-APR-09,7975.00,20
```

The following table is loaded using the preceding control file and data file.

```
CREATE TABLE empjob (
    empno           NUMBER(4) NOT NULL CONSTRAINT empjob_pk PRIMARY KEY,
    ename           VARCHAR2(10),
    job             VARCHAR2(9),
    mgr             NUMBER(4),
    jobdesc         VARCHAR2(25)
);
```

The resulting rows in the table appear as follows:

```
SELECT * FROM empjob;

 empno |   ename    | job | mgr |          jobdesc
-------+------------+-----+-----+---------------------------
  9101 | ROGERS     |     |     | CLERK for manager 7902
  9102 | PETERSON   |     |     | SALESMAN for manager 7698
  9103 | WARREN     |     |     | SALESMAN for manager 7698
  9104 | JONES, JR. |     |     | MANAGER for manager 7839
(4 rows)
```

***Field Types with Length Specification***

The following example is a control file that contains the field type clauses with the length specification:

```
LOAD DATA
  INFILE        'emp_fixed.dat'
    BADFILE     'emp_fixed.bad'
  APPEND
  INTO TABLE emp
    TRAILING NULLCOLS
  (
    empno       CHAR(4),
    ename       CHAR(10),
    job         POSITION (15:23) CHAR(9),
    mgr         INTEGER EXTERNAL(4),
    hiredate    DATE(11) "DD-MON-YY",
    sal         DECIMAL EXTERNAL(8),
    deptno      POSITION (47:48),
    comm        POSITION (49:56) DECIMAL EXTERNAL(8)
  )
```

Note that the `POSITION` clause and the *`fieldtype`*`(`*`length`*`)` clause can be used individually or in combination as long as each field definition contains at least one of the two clauses.

The following is the corresponding data file containing fixed-width fields:

```
9101ROGERS    CLERK    790217-DEC-10   1980.0020
9102PETERSON  SALESMAN 769820-DEC-10   2600.0030 2300.00
9103WARREN    SALESMAN 769822-DEC-10   5250.0030 2500.00
9104JONES, JR.MANAGER  783902-APR-09   7975.0020
```

The resulting rows in the table appear as follows:

```
SELECT * FROM emp WHERE empno > 9100;

 empno |   ename    |   job    | mgr  |      hiredate      |   sal   |  comm   | deptno u
-------+------------+----------+------+--------------------+---------+---------+--------
  9101 | ROGERS     | CLERK    | 7902 | 17-DEC-10 00:00:00 | 1980.00 |         |     20
  9102 | PETERSON   | SALESMAN | 7698 | 20-DEC-10 00:00:00 | 2600.00 | 2300.00 |     30
  9103 | WARREN     | SALESMAN | 7698 | 22-DEC-10 00:00:00 | 5250.00 | 2500.00 |     30
  9104 | JONES, JR. | MANAGER  | 7839 | 02-APR-09 00:00:00 | 7975.00 |         |     20
(4 rows)
```

***NULLIF Clause***

The following example uses the `NULLIF` clause on the `sal` column to set it to null for employees of job `MANAGER` as well as on the `comm` column to set it to null if the employee is not a `SALESMAN` and is not in department `30`. In other words, a `comm` value is accepted if the employee is a `SALESMAN` or is a member of department `30`.

The following is the control file:

```
LOAD DATA
  INFILE        'emp_fixed_2.dat'
    BADFILE     'emp_fixed_2.bad'
  APPEND
  INTO TABLE emp
    TRAILING NULLCOLS
  (
    empno       POSITION (1:4),
    ename       POSITION (5:14),
    job         POSITION (15:23),
    mgr         POSITION (24:27),
    hiredate    POSITION (28:38),
    sal         POSITION (39:46) NULLIF job = 'MANAGER',
    deptno      POSITION (47:48),
    comm        POSITION (49:56) NULLIF job <> 'SALESMAN' AND deptno <> '30'
  )
```

The following is the corresponding data file:

```
9101ROGERS    CLERK    790217-DEC-10   1980.0020
9102PETERSON  SALESMAN 769820-DEC-10   2600.0030 2300.00
9103WARREN    SALESMAN 769822-DEC-10   5250.0030 2500.00
9104JONES, JR.MANAGER  783902-APR-09   7975.0020
9105ARNOLDS   CLERK    778213-SEP-10   3750.0030  800.00
9106JACKSON   ANALYST  756603-JAN-11   4500.0040 2000.00
9107MAXWELL   SALESMAN 769820-DEC-10   2600.0010 1600.00
```

The resulting rows in the table appear as follows:

```
SELECT empno, ename, job, NVL(TO_CHAR(sal),'--null--') "sal",
  NVL(TO_CHAR(comm),'--null--') "comm", deptno FROM emp WHERE empno > 9100;

 empno |   ename    |   job    |   sal    |   comm   | deptno
-------+------------+----------+----------+----------+--------
  9101 | ROGERS     | CLERK    | 1980.00  | --null-- |     20
  9102 | PETERSON   | SALESMAN | 2600.00  | 2300.00  |     30
  9103 | WARREN     | SALESMAN | 5250.00  | 2500.00  |     30
  9104 | JONES, JR. | MANAGER  | --null-- | --null-- |     20
  9105 | ARNOLDS    | CLERK    | 3750.00  | 800.00   |     30
  9106 | JACKSON    | ANALYST  | 4500.00  | --null-- |     40
  9107 | MAXWELL    | SALESMAN | 2600.00  | 1600.00  |     10
(7 rows)
```

Note that the `sal` column for employee `JONES, JR.` is null since the job is `MANAGER`.

The `comm` values from the data file for employees `PETERSON`, `WARREN`, `ARNOLDS`, and `MAXWELL` are all loaded into the `comm` column of the `emp` table since these employees are either `SALESMAN` or members of department `30`.

The `comm` value of `2000.00` in the data file for employee `JACKSON` is ignored and the `comm` column of the `emp` table set to null since this employee is neither a `SALESMAN` nor is a member of department `30`.

***SELECT Statement in a Field Expression***

The following example uses a `SELECT` statement in the expression of the field definition to return the value to be loaded into the column.

```
LOAD DATA
  INFILE        'emp_fixed.dat'
    BADFILE     'emp_fixed.bad'
  APPEND
  INTO TABLE emp
    TRAILING NULLCOLS
  (
    empno       POSITION (1:4),
    ename       POSITION (5:14),
    job         POSITION (15:23) "(SELECT dname FROM dept WHERE deptno = :deptno)",
    mgr         POSITION (24:27),
    hiredate    POSITION (28:38),
    sal         POSITION (39:46),
    deptno      POSITION (47:48),
    comm        POSITION (49:56)
  )
```

The content of the `dept` table used in the `SELECT` statement is the following:

```
SELECT * FROM dept;

 deptno |   dname    |   loc
--------+------------+----------
     10 | ACCOUNTING | NEW YORK
     20 | RESEARCH   | DALLAS
     30 | SALES      | CHICAGO
     40 | OPERATIONS | BOSTON
(4 rows)
```

The following is the corresponding data file:

```
9101ROGERS    CLERK    790217-DEC-10   1980.0020
9102PETERSON  SALESMAN 769820-DEC-10   2600.0030 2300.00
9103WARREN    SALESMAN 769822-DEC-10   5250.0030 2500.00
9104JONES, JR.MANAGER  783902-APR-09   7975.0020
```

The resulting rows in the table appear as follows:

```
SELECT * FROM emp WHERE empno > 9100;

 empno |   ename    |   job    | mgr  |      hiredate      |   sal   |  comm   | deptno
-------+------------+----------+------+--------------------+---------+---------+--------
  9101 | ROGERS     | RESEARCH | 7902 | 17-DEC-10 00:00:00 | 1980.00 |         |     20
  9102 | PETERSON   | SALES    | 7698 | 20-DEC-10 00:00:00 | 2600.00 | 2300.00 |     30
  9103 | WARREN     | SALES    | 7698 | 22-DEC-10 00:00:00 | 5250.00 | 2500.00 |     30
  9104 | JONES, JR. | RESEARCH | 7839 | 02-APR-09 00:00:00 | 7975.00 |         |     20
(4 rows)
```

Note that the `job` column contains the value from the `dname` column of the `dept` table returned by the `SELECT` statement instead of the job name from the data file.

***Multiple INTO TABLE Clauses***

The following example illustrates the use of multiple `INTO TABLE` clauses. For this example, two empty tables are created with the same data definition as the `emp` table. The following `CREATE TABLE` commands create these two empty tables, while inserting no rows from the original `emp` table:

```
CREATE TABLE emp_research AS SELECT * FROM emp WHERE deptno = 99;
CREATE TABLE emp_sales AS SELECT * FROM emp WHERE deptno = 99;
```

The following control file contains two `INTO TABLE` clauses. Also note that there is no `APPEND` clause so the default operation of `INSERT` is used, which requires that tables `emp_research` and `emp_sales` be empty.

```
LOAD DATA
  INFILE        'emp_multitbl.dat'
    BADFILE     'emp_multitbl.bad'
    DISCARDFILE 'emp_multitbl.dsc'
  INTO TABLE emp_research
    WHEN (47:48) = '20'
    TRAILING NULLCOLS
  (
    empno       POSITION (1:4),
    ename       POSITION (5:14),
    job         POSITION (15:23),
    mgr         POSITION (24:27),
    hiredate    POSITION (28:38),
    sal         POSITION (39:46),
    deptno      CONSTANT '20',
    comm        POSITION (49:56)
  )
  INTO TABLE emp_sales
    WHEN (47:48) = '30'
    TRAILING NULLCOLS
  (
    empno       POSITION (1:4),
    ename       POSITION (5:14),
    job         POSITION (15:23),
    mgr         POSITION (24:27),
    hiredate    POSITION (28:38),
    sal         POSITION (39:46),
    deptno      CONSTANT '30',
    comm        POSITION (49:56) "ROUND(:comm + (:sal * .25), 0)"
  )
```

The `WHEN` clauses specify that when the field designated by columns 47 thru 48 contains `20`, the record is inserted into the `emp_research` table and when that same field contains 30, the record is inserted into the `emp_sales` table. If neither condition is true, the record is written to the discard file named `emp_multitbl.dsc`.

The `CONSTANT` clause is given for column `deptno` so the specified constant value is inserted into `deptno` for each record. When the `CONSTANT` clause is used, it must be the only clause in the field definition other than the column name to which the constant value is assigned.

Finally, column `comm` of the `emp_sales` table is assigned a SQL expression. Column names may be referenced in the expression by prefixing the column name with a colon character (:).

The following is the corresponding data file:

```
9101ROGERS    CLERK    790217-DEC-10   1980.0020
9102PETERSON  SALESMAN 769820-DEC-10   2600.0030 2300.00
9103WARREN    SALESMAN 769822-DEC-10   5250.0030 2500.00
9104JONES, JR.MANAGER  783902-APR-09   7975.0020
9105ARNOLDS   CLERK    778213-SEP-10   3750.0010
9106JACKSON   ANALYST  756603-JAN-11   4500.0040
```

Since the records for employees `ARNOLDS` and `JACKSON` contain `10` and `40` in columns `47` thru `48`, which do not satisfy any of the `WHEN` clauses, EDB\*Loader writes these two records to the discard file, `emp_multitbl.dsc`, whose content is shown by the following:

```
9105ARNOLDS   CLERK    778213-SEP-10   3750.0010
9106JACKSON   ANALYST  756603-JAN-11   4500.0040
```

The following are the rows loaded into the `emp_research` and `emp_sales` tables:

```
SELECT * FROM emp_research;

empno |   ename    |   job   | mgr  |      hiredate      |   sal   | comm | deptno
-------+------------+---------+------+--------------------+---------+------+--------
  9101 | ROGERS     | CLERK   | 7902 | 17-DEC-10 00:00:00 | 1980.00 |      |  20.00
  9104 | JONES, JR. | MANAGER | 7839 | 02-APR-09 00:00:00 | 7975.00 |      |  20.00
(2 rows)

SELECT * FROM emp_sales;

empno |  ename   |   job    | mgr  |      hiredate      |   sal   |  comm   | deptno
-------+----------+----------+------+--------------------+---------+---------+--------
  9102 | PETERSON | SALESMAN | 7698 | 20-DEC-10 00:00:00 | 2600.00 | 2950.00 |  30.00
  9103 | WARREN   | SALESMAN | 7698 | 22-DEC-10 00:00:00 | 5250.00 | 3813.00 |  30.00
(2 rows)
```

