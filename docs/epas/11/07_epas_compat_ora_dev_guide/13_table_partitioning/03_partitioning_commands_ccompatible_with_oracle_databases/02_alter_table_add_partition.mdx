---

title: "ALTER TABLE...ADD PARTITION"
---

<div id="alter_table_add_partition" class="registered_link"></div>

Use the `ALTER TABLE… ADD PARTITION` command to add a partition to an existing partitioned table. The syntax is:

`ALTER TABLE` *`table_name`* `ADD PARTITION` *``partition_definition`*`;`

Where *`partition_definition`* is:

> `{`*`list_partition`* `|` *`range_partition`* }

and *`list_partition`* is:

> `PARTITION [`*`partition_name`*`]`
>
>   `VALUES (`*`value`*`[,` *`value`*`]...)`
>
>   `[TABLESPACE` *`tablespace_name`*`]`
>
>   `[(`*`subpartition`*`, ...)]`

and *`range_partition`* is:

> `PARTITION [`*`partition_name`*`]`
>
>   `VALUES LESS THAN (`*`value`*`[,` *`value`*`]...)`
>
>   `[TABLESPACE` *`tablespace_name`*`]`
>
>   `[(`*`subpartition`*`, ...)]`

Where *`subpartition`* is:

> `{`*list*_*`subpartition`* `|` *`range_subpartition` `|` `hash_subpartition`*`}`

and *`list_subpartition`* is:

> `SUBPARTITION [`*`subpartition_name`*`]`
>
>   `VALUES (`*`value`*`[,` *`value`*`]...)`
>
>   `[TABLESPACE` *`tablespace_name`*`]`

and *`range_subpartition`* is:

> `SUBPARTITION [`*`subpartition_name`* `]`
>
>   `VALUES LESS THAN (`*`value`*`[,` *`value`*`]...)`
>
>   `[``TABLESPACE` *`tablespace_name`*`]`

**Description**

The `ALTER TABLE… ADD PARTITION` command adds a partition to an existing partitioned table. There is no upper limit to the number of defined partitions in a partitioned table.

New partitions must be of the same type (`LIST`, `RANGE` or `HASH`) as existing partitions. The new partition rules must reference the same column specified in the partitioning rules that define the existing partition(s).

You can use the `ALTER TABLE… ADD PARTITION` statement to add a partition to a table with a `DEFAULT` rule as long as there are no conflicting values between existing rows in the table and the values of the partition to be added.

You cannot use the A`LTER TABLE… ADD PARTITION` statement to add a partition to a table with a `MAXVALUE` rule.

You can alternatively use the `ALTER TABLE… SPLIT PARTITION` statement to split an existing partition, effectively increasing the number of partitions in a table.

`RANGE` partitions must be specified in ascending order. You cannot add a new partition that precedes existing partitions in a `RANGE` partitioned table.

Include the `TABLESPACE` clause to specify the tablespace in which the new partition will reside. If you do not specify a tablespace, the partition will reside in the default tablespace.

If the table is indexed, the index will be created on the new partition.

To use the `ALTER TABLE... ADD PARTITION` command you must be the table owner, or have superuser (or administrative) privileges.

**Parameters**

*`table_name`*

> The name (optionally schema-qualified) of the partitioned table.

*`partition_name`*

> The name of the partition to be created. Partition names must be unique amongst all partitions and subpartitions, and must follow the naming conventions for object identifiers.

*`subpartition_name`*

The name of the subpartition to be created. Subpartition names must be unique amongst all partitions and subpartitions, and must follow the naming conventions for object identifiers.

`(`*`value`*`[,` *`value`*`]...)`

> Use *`value`* to specify a quoted literal value (or comma-delimited list of literal values) by which rows will be distributed into partitions. Each partitioning rule must specify at least one *`value`*, but there is no limit placed on the number of values specified within a rule. *`value`* may also be `NULL`, `DEFAULT` (if specifying a `LIST` partition), or `MAXVALUE` (if specifying a `RANGE` partition).
>
> For information about creating a `DEFAULT` or `MAXVALUE` partition, see Section [10.4](https://www.enterprisedb.com/edb-docs/d/edb-postgres-advanced-server/user-guides/database-compatibility-for-oracle-developers-guide/11/Database_Compatibility_for_Oracle_Developers_Guide.1.119.html#).

*`tablespace_name`*

> The name of the tablespace in which a partition or subpartition resides.

## Example - Adding a Partition to a LIST Partitioned Table

The example that follows adds a partition to the list-partitioned `sales` table. The table was created using the command:

`CREATE TABLE sales`

`(`

  `dept_no     number,`

  `part_no     varchar2,`

  `country     varchar2(20),`

  `date        date,`

  `amount      number`

`)`

`PARTITION BY LIST(country)`

`(`

  `PARTITION europe VALUES('FRANCE', 'ITALY'),`

  `PARTITION asia VALUES('INDIA', 'PAKISTAN'),`

  `PARTITION americas VALUES('US', 'CANADA')`

`);`

The table contains three partitions (`americas`, `asia`, and `europe`) :

```
acctg=# SELECT partition_name, high_value FROM ALL_TAB_PARTITIONS;
 partition_name |             high_value
----------------+-------------------------------------
 EUROPE         | FOR VALUES IN ('FRANCE', 'ITALY')
 ASIA           | FOR VALUES IN ('INDIA', 'PAKISTAN')
 AMERICAS       | FOR VALUES IN ('US', 'CANADA')
(3 rows)
```

The following command adds a partition named `east_asia` to the `sales` table:

> `ALTER TABLE sales ADD PARTITION east_asia
>   VALUES ('CHINA', 'KOREA');`

After invoking the command, the table includes the `east_asia` partition:

```
acctg=# SELECT partition_name, high_value FROM ALL_TAB_PARTITIONS;
 partition_name |             high_value
----------------+-------------------------------------
 EUROPE         | FOR VALUES IN ('FRANCE', 'ITALY')
 ASIA           | FOR VALUES IN ('INDIA', 'PAKISTAN')
 AMERICAS       | FOR VALUES IN ('US', 'CANADA')
 EAST_ASIA      | FOR VALUES IN ('CHINA', 'KOREA')
(4 rows)
```

## Example - Adding a Partition to a RANGE Partitioned Table

The example that follows adds a partition to a range-partitioned table named sales:

`CREATE TABLE sales`

`(`

  `dept_no     number,`

  `part_no     varchar2,`

  `country     varchar2(20),`

  `date        date,`

  `amount      number`

`)`

`PARTITION BY RANGE(date)`

`(`

  `PARTITION q1_2012`
    `VALUES LESS THAN('2012-Apr-01'),`

  `PARTITION q2_2012`
    `VALUES LESS THAN('2012-Jul-01'),`

  `PARTITION q3_2012`
    `VALUES LESS THAN('2012-Oct-01'),`

  `PARTITION q4_2012`
    `VALUES LESS THAN('2013-Jan-01')`

`);`

The table contains four partitions (`q1_2012`, `q2_2012`, `q3_2012`, and q4_2012):

```
acctg=# SELECT partition_name, high_value FROM ALL_TAB_PARTITIONS;
 partition_name |                            high_value
----------------+------------------------------------------------------------------
 Q1_2012        | FOR VALUES FROM (MINVALUE) TO ('01-APR-12 00:00:00')
 Q2_2012        | FOR VALUES FROM ('01-APR-12 00:00:00') TO ('01-JUL-12 00:00:00')
 Q3_2012        | FOR VALUES FROM ('01-JUL-12 00:00:00') TO ('01-OCT-12 00:00:00')
 Q4_2012        | FOR VALUES FROM ('01-OCT-12 00:00:00') TO ('01-JAN-13 00:00:00')
(4 rows)
```

The following command adds a partition named `q1_2013` to the `sales` table:

> `A`LTER TABLE sales ADD PARTITION q1_2013`
>   VALUES LESS THAN('01-APR-2013');`

After invoking the command, the table includes the `q1_2013` partition:

```
acctg=# SELECT partition_name, high_value FROM ALL_TAB_PARTITIONS;
 partition_name |                            high_value
----------------+------------------------------------------------------------------
 Q1_2012        | FOR VALUES FROM (MINVALUE) TO ('01-APR-12 00:00:00')
 Q2_2012        | FOR VALUES FROM ('01-APR-12 00:00:00') TO ('01-JUL-12 00:00:00')
 Q3_2012        | FOR VALUES FROM ('01-JUL-12 00:00:00') TO ('01-OCT-12 00:00:00')
 Q4_2012        | FOR VALUES FROM ('01-OCT-12 00:00:00') TO ('01-JAN-13 00:00:00')
 Q1_2013        | FOR VALUES FROM ('01-JAN-13 00:00:00') TO ('01-APR-13 00:00:00')
(5 rows)
```

