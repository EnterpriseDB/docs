---

title: "Using Partition Pruning"
---

<div id="using_partition_pruning" class="registered_link"></div>

Advanced Server's query planner uses *partition* *pruning* to compute an efficient plan to locate a row (or rows) that matches the conditions specified in the `WHERE` clause of a `SELECT` statement. To successfully prune partitions from an execution plan, the `WHERE` clause must constrain the information that is compared to the partitioning key column specified when creating the partitioned table. When querying a:

- list-partitioned table, partition pruning is effective when the `WHERE` clause compares a literal value to the partitioning key using operators like equal (=) or `AND`.
- range-partitioned table, partition pruning is effective when the `WHERE` clause compares a literal value to a partitioning key using operators such as equal (=), less than (<), or greater than (>).
- hash-partitioned table, partition pruning is effective when the `WHERE` clause compares a literal value to the partitioning key using an operator such as equal (=).

The partition pruning mechanism uses two optimization techniques:

- Fast Pruning
- Constraint exclusion

Partition pruning techniques limit the search for data to only those partitions in which the values for which you are searching might reside. Both pruning techniques remove partitions from a query's execution plan, increasing performance.

The difference between the fast pruning and constraint exclusion is that fast pruning understands the relationship between the partitions in an Oracle-partitioned table, while constraint exclusion does not. For example, when a query searches for a specific value within a list-partitioned table, fast pruning can reason that only a specific partition may hold that value, while constraint exclusion must examine the constraints defined for *each* partition. Fast pruning occurs early in the planning process to reduce the number of partitions that the planner must consider, while constraint exclusion occurs late in the planning process.

**Using Constraint Exclusion**

The `constraint_exclusion` parameter controls constraint exclusion. The `constraint_exclusion` parameter may have a value of `on`, `off`, or `partition`. To enable constraint exclusion, the parameter must be set to *either* `partition` or `on`. By default, the parameter is set to `partition`.

For more information about constraint exclusion, see:

https://www.postgresql.org/docs/11/static/ddl-partitioning.html

When constraint exclusion is enabled, the server examines the constraints defined for each partition to determine if that partition can satisfy a query.

When you execute a `SELECT` statement that *does not* contain a `WHERE` clause, the query planner must recommend an execution plan that searches the entire table. When you execute a `SELECT` statement that *does* contain a `WHERE` clause, the query planner determines in which partition that row would be stored, and sends query fragments to that partition, pruning the partitions that could not contain that row from the execution plan. If you are not using partitioned tables, disabling constraint exclusion may improve performance.

**Fast Pruning**

Like constraint exclusion, fast pruning can only optimize queries that include a WHERE (or join) clause, and only when the qualifiers in the `WHERE` clause match a certain form. In both cases, the query planner will avoid searching for data within partitions that cannot possibly hold the data required by the query.

Fast pruning is controlled by a boolean configuration parameter named `edb_enable_pruning`. If `edb_enable_pruning` is `ON`, Advanced Server will fast prune certain queries. If `edb_enable_pruning` is `OFF`, the server will disable fast pruning.

Please note: Fast pruning cannot optimize queries against subpartitioned tables or optimize queries against range-partitioned tables that are partitioned on more than one column.

For LIST-partitioned tables, Advanced Server can fast prune queries that contain a `WHERE` clause that constrains a partitioning column to a literal value. For example, given a LIST-partitioned table such as:

`CREATE TABLE sales_hist(..., country text, ...)`
`PARTITION BY LIST(country)`

`(`
    `PARTITION americas VALUES('US', 'CA', 'MX'),`
    `PARTITION europe VALUES('BE', 'NL', 'FR'),`
    `PARTITION asia VALUES('JP', 'PK', 'CN'),`
    `PARTITION others VALUES(DEFAULT)`
`)`

Fast pruning can reason about WHERE clauses such as:

`WHERE country = 'US'`

`WHERE country IS NULL;`

Given the first `WHERE` clause, fast pruning would eliminate partitions `europe`, `asia`, and `others` because those partitions cannot hold rows that satisfy the qualifier: `WHERE country = 'US'`.

Given the second `WHERE` clause, fast pruning would eliminate partitions `americas`, `europe`, and `asia` because those partitions cannot hold rows where `country IS NULL`.

The operator specified in the `WHERE` clause must be an equal sign (=) or the equality operator appropriate for the data type of the partitioning column.

For range-partitioned tables, Advanced Server can fast prune queries that contain a WHERE clause that constrains a partitioning column to a literal value, but the operator may be any of the following:

> `\>`
> `\>=`
> `=`
> `<=`
> `<`

Fast pruning will also reason about more complex expressions involving `AND` and `BETWEEN` operators, such as:

> `WHERE size > 100 AND size <= 200`
> `WHERE size BETWEEN 100 AND 200`

But cannot prune based on expressions involving `OR` or `IN`.

For example, when querying a RANGE-partitioned table, such as:

`CREATE TABLE boxes(id int, size int, color text)`
  `PARTITION BY RANGE(size)`
`(`
    `PARTITION small VALUES LESS THAN(100),`
    `PARTITION medium VALUES LESS THAN(200),`
    `PARTITION large VALUES LESS THAN(300)`
`)`

Fast pruning can reason about WHERE clauses such as:

`WHERE size > 100     -- scan partitions 'medium' and 'large'`

`WHERE size >= 100    -- scan partitions 'medium' and 'large'`

`WHERE size = 100     -- scan partition 'medium'`

`WHERE size <= 100    -- scan partitions 'small' and 'medium'`

`WHERE size < 100     -- scan partition 'small'`

`WHERE size > 100 AND size < 199     -- scan partition 'medium'`

`WHERE size BETWEEN 100 AND 199      -- scan partition 'medium'`

`WHERE color = 'red' AND size = 100  -- scan 'medium'`

`WHERE color = 'red' AND (size > 100 AND size < 199) -- scan 'medium'`

In each case, fast pruning requires that the qualifier must refer to a partitioning column and literal value (or `IS NULL/IS NOT NULL`).

Note that fast pruning can also optimize `DELETE` and `UPDATE` statements containing `WHERE` clauses of the forms described above.

## Example - Partition Pruning

The `EXPLAIN` statement displays the execution plan of a statement. You can use the `EXPLAIN` statement to confirm that Advanced Server is pruning partitions from the execution plan of a query.

To demonstrate the efficiency of partition pruning, first create a simple table:

`CREATE TABLE sales`

`(`

  `dept_no     number,`

  `part_no     varchar2,`

  `country     varchar2(20),`

  `date        date,`

  `amount      number`

`)`

`PARTITION BY LIST(country)`

`(`

  `PARTITION europe VALUES('FRANCE', 'ITALY'),`

  `PARTITION asia VALUES('INDIA', 'PAKISTAN'),`

  `PARTITION americas VALUES('US', 'CANADA')`

`);`

Then, perform a constrained query that includes the EXPLAIN statement:

`EXPLAIN (COSTS OFF) SELECT * FROM sales WHERE country = 'INDIA';`

The resulting query plan shows that the server will scan only the `sales_asia` table - the table in which a row with a `country` value of `INDIA` would be stored:

```
edb=# EXPLAIN (COSTS OFF) SELECT * FROM sales WHERE country = 'INDIA';

                    QUERY PLAN
---------------------------------------------------

 Append
   ->  Seq Scan on sales_asia
         Filter: ((country)::text = 'INDIA'::text)
(3 rows)
```

If you perform a query that searches for a row that matches a value not included in the partitioning key:

`EXPLAIN (COSTS OFF) SELECT * FROM sales WHERE dept_no = '30';`

The resulting query plan shows that the server must look in all of the partitions to locate the rows that satisfy the query:

```
edb=# EXPLAIN (COSTS OFF) SELECT * FROM sales WHERE dept_no = '30';

                QUERY PLAN
-------------------------------------------

 Append
   ->  Seq Scan on sales_americas
         Filter: (dept_no = '30'::numeric)
   ->  Seq Scan on sales_europe
         Filter: (dept_no = '30'::numeric)
   ->  Seq Scan on sales_asia
         Filter: (dept_no = '30'::numeric)
(7 rows)
```

Constraint exclusion also applies when querying subpartitioned tables:

`CREATE TABLE sales`

`(`

  `dept_no     number,`

  `part_no     varchar2,`

  `country     varchar2(20),`

  `date        date,`

  `amount      number`

`)`

`PARTITION BY RANGE(date) SUBPARTITION BY LIST (country)`

`(`
  `PARTITION "2011" VALUES LESS THAN('01-JAN-2012')`

  `(`

​    `SUBPARTITION europe_2011 VALUES ('ITALY', 'FRANCE'),`

​    `SUBPARTITION asia_2011 VALUES ('PAKISTAN', 'INDIA'),`

​    `SUBPARTITION americas_2011 VALUES ('US', 'CANADA')`

  `),`

  `PARTITION "2012" VALUES LESS THAN('01-JAN-2013')`

  `(`

​    `SUBPARTITION europe_2012 VALUES ('ITALY', 'FRANCE'),`

​    `SUBPARTITION asia_2012 VALUES ('PAKISTAN', 'INDIA'),`

​    `SUBPARTITION americas_2012 VALUES ('US', 'CANADA')`

  `),`
  `PARTITION "2013" VALUES LESS THAN('01-JAN-2015')`

  `(`

​    `SUBPARTITION europe_2013 VALUES ('ITALY', 'FRANCE'),`

​    `SUBPARTITION asia_2013 VALUES ('PAKISTAN', 'INDIA'),`

​    `SUBPARTITION americas_2013 VALUES ('US', 'CANADA')`

  `)`

`);`

When you query the table, the query planner prunes any partitions or subpartitions from the search path that cannot possibly contain the desired result set:

```
edb=# EXPLAIN (COSTS OFF) SELECT * FROM sales WHERE country = 'US' AND date = 'Dec 12, 2012';

                                                   QUERY PLAN
-----------------------------------------------------------------------------------------------------------------

 Append
   ->  Seq Scan on sales_americas_2012
         Filter: (((country)::text = 'US'::text) AND (date = '12-DEC-12 00:00:00'::timestamp without time zone))
(3 rows)
```

