---

title: "Procedure and Function Parameters"
---

<div id="procedure_and_function_parameters" class="registered_link"></div>

An important aspect of using procedures and functions is the capability to pass data from the calling program to the procedure or function and to receive data back from the procedure or function. This is accomplished by using *parameters*.

Parameters are declared in the procedure or function definition, enclosed within parenthesis following the procedure or function name. Parameters declared in the procedure or function definition are known as *formal parameters*. When the procedure or function is invoked, the calling program supplies the actual data that is to be used in the called program’s processing as well as the variables that are to receive the results of the called program’s processing. The data and variables supplied by the calling program when the procedure or function is called are referred to as the *actual parameters*.

The following is the general format of a formal parameter declaration.

`(`*`name`* `[ IN | OUT | IN OUT ]` *`data_type`* `[ DEFAULT` *`value`* `])`

*`name`* is an identifier assigned to the formal parameter. If specified, `IN` defines the parameter for receiving input data into the procedure or function. An `IN` parameter can also be initialized to a default value. If specified, `OUT` defines the parameter for returning data from the procedure or function. If specified, `IN OUT` allows the parameter to be used for both input and output. If all of `IN`, `OUT`, and `IN OUT` are omitted, then the parameter acts as if it were defined as `IN` by default. Whether a parameter is `IN`, `OUT`, or `IN OUT` is referred to as the parameter’s *mode*. *`data_type`* defines the data type of the parameter. *`value`* is a default value assigned to an `IN` parameter in the called program if an actual parameter is not specified in the call.

The following is an example of a procedure that takes parameters:

```
CREATE OR REPLACE PROCEDURE emp_query (
    p_deptno        IN     NUMBER,
    p_empno         IN OUT NUMBER,
    p_ename         IN OUT VARCHAR2,
    p_job           OUT    VARCHAR2,
    p_hiredate      OUT    DATE,
    p_sal           OUT    NUMBER
)
IS
BEGIN
    SELECT empno, ename, job, hiredate, sal
        INTO p_empno, p_ename, p_job, p_hiredate, p_sal
        FROM emp
        WHERE deptno = p_deptno
          AND (empno = p_empno
           OR  ename = UPPER(p_ename));
END;
```

In this example, `p_deptno` is an `IN` formal parameter, `p_empno` and `p_ename` are `IN OUT` formal parameters, and `p_job`, `p_hiredate`, and `p_sal` are `OUT` formal parameters.

**Note:** In the previous example, no maximum length was specified on the `VARCHAR2` parameters and no precision and scale were specified on the `NUMBER` parameters. It is illegal to specify a length, precision, scale or other constraints on parameter declarations. These constraints are automatically inherited from the actual parameters that are used when the procedure or function is called.

The `emp_query` procedure can be called by another program, passing it the actual parameters. The following is an example of another SPL program that calls `emp_query`.

```
DECLARE
    v_deptno        NUMBER(2);
    v_empno         NUMBER(4);
    v_ename         VARCHAR2(10);
    v_job           VARCHAR2(9);
    v_hiredate      DATE;
    v_sal           NUMBER;
BEGIN
    v_deptno := 30;
    v_empno  := 7900;
    v_ename  := '';
    emp_query(v_deptno, v_empno, v_ename, v_job, v_hiredate, v_sal);
    DBMS_OUTPUT.PUT_LINE('Department : ' || v_deptno);
    DBMS_OUTPUT.PUT_LINE('Employee No: ' || v_empno);
    DBMS_OUTPUT.PUT_LINE('Name       : ' || v_ename);
    DBMS_OUTPUT.PUT_LINE('Job        : ' || v_job);
    DBMS_OUTPUT.PUT_LINE('Hire Date  : ' || v_hiredate);
    DBMS_OUTPUT.PUT_LINE('Salary     : ' || v_sal);
END;
```

In this example, `v_deptno`, `v_empno`, `v_ename`, `v_job`, `v_hiredate`, and `v_sal` are the actual parameters.

The output from the preceding example is shown as follows:

```
Department : 30
Employee No: 7900
Name       : JAMES
Job        : CLERK
Hire Date  : 03-DEC-81
Salary     : 950
```

## Positional vs. Named Parameter Notation

You can use either *positional* or *named* parameter notation when passing parameters to a function or procedure. If you specify parameters using positional notation, you must list the parameters in the order that they are declared; if you specify parameters with named notation, the order of the parameters is not significant.

To specify parameters using named notation, list the name of each parameter followed by an arrow (=>) and the parameter value. Named notation is more verbose, but makes your code easier to read and maintain.

A simple example that demonstrates using positional and named parameter notation follows:

> `CREATE OR REPLACE PROCEDURE emp_info (`
>
> ​    `p_deptno        IN     NUMBER,`
>
> ​    `p_empno         IN OUT NUMBER,`
>
> ​    `p_ename         IN OUT VARCHAR2,`
>
> `)`
>
> `IS`
>
> `BEGIN`
>
> ​    `dbms_output.put_line('Department Number =' || p_deptno);`
>
> ​    `dbms_output.put_line('Employee Number =' || p_empno);`
>
> ​    `dbms_output.put_line('Employee Name =' || p_ename;`
>
> `END;`

To call the procedure using positional notation, pass the following:

> `emp_info(30, 7455, 'Clark');`

To call the procedure using named notation, pass the following:

> `emp_info(p_ename =>'Clark', p_empno=>7455, p_deptno=>30);`

Using named notation can alleviate the need to re-arrange a procedure’s parameter list if the parameter list changes, if the parameters are reordered or if a new optional parameter is added.

In a case where you have a default value for an argument and the argument is not a trailing argument, you must use named notation to call the procedure or function. The following case demonstrates a procedure with two, leading, default arguments.

`CREATE OR REPLACE PROCEDURE check_balance (`

​    `p_customerID  IN NUMBER DEFAULT NULL,`

​    `p_balance     IN NUMBER DEFAULT NULL,`

​    `p_amount      IN NUMBER`

`)`

`IS`

`DECLARE`

​    `balance NUMBER;`

`BEGIN`

   `IF (p_balance IS NULL AND p_customerID IS NULL) THEN`

​      `RAISE_APPLICATION_ERROR`

​          `(-20010, 'Must provide balance or customer');`

   `ELSEIF (p_balance IS NOT NULL AND p_customerID IS NOT NULL) THEN`

​      `RAISE_APPLICATION_ERROR`

​          `(-20020,'Must provide balance or customer, not both');`

   `ELSEIF (p_balance IS NULL) THEN`

​      `balance := getCustomerBalance(p_customerID);`

   `ELSE`

​      `balance := p_balance;`

   `END IF;`

``

   `IF (amount > balance) THEN`

​      `RAISE_APPLICATION_ERROR`

​        `(-20030, 'Balance insufficient');`

   `END IF;`

`END;`

You can only omit non-trailing argument values (when you call this procedure) by using named notation; when using positional notation, only trailing arguments are allowed to default. You can call this procedure with the following arguments:

> `check_balance(p_customerID => 10, p_amount = 500.00)`
>
> `check_balance(p_balance => 1000.00, p_amount = 500.00)`

You can use a combination of positional and named notation (mixed notation) to specify parameters. A simple example that demonstrates using mixed parameter notation follows:

> `CREATE OR REPLACE PROCEDURE emp_info (`
>
> ​    `p_deptno        IN     NUMBER,`
>
> ​    `p_empno         IN OUT NUMBER,`
>
> ​    `p_ename         IN OUT VARCHAR2,`
>
> `)`
>
> `IS`
>
> `BEGIN`
>
> ​    `dbms_output.put_line('Department Number =' || p_deptno);`
>
> ​    `dbms_output.put_line('Employee Number =' || p_empno);`
>
> ​    `dbms_output.put_line('Employee Name =' || p_ename;`
>
> `END;`

You can call the procedure using mixed notation:

> `emp_info(30, p_ename =>'Clark', p_empno=>7455);`

If you do use mixed notation, remember that named arguments cannot precede positional arguments.

## Parameter Modes

As previously discussed, a parameter has one of three possible modes - `IN`, `OUT`, or `IN OUT`. The following characteristics of a formal parameter are dependent upon its mode:

- Its initial value when the procedure or function is called.
- Whether or not the called procedure or function can modify the formal parameter.
- How the actual parameter value is passed from the calling program to the called program.
- What happens to the formal parameter value when an unhandled exception occurs in the called program.

The following table summarizes the behavior of parameters according to their mode.

Table 3‑1 Parameter Modes

| Mode Property                                                | IN                                                | IN OUT                                            | OUT                                               |
| ------------------------------------------------------------ | ------------------------------------------------- | ------------------------------------------------- | ------------------------------------------------- |
| Formal parameter initialized to:                             | Actual parameter value                            | Actual parameter value                            | Actual parameter value                            |
| Formal parameter modifiable by the called program?           | No                                                | Yes                                               | Yes                                               |
| Actual parameter contains: (after normal called program termination) | Original actual parameter value prior to the call | Last value of the formal parameter                | Last value of the formal parameter                |
| Actual parameter contains: (after a handled exception in the called program) | Original actual parameter value prior to the call | Last value of the formal parameter                | Last value of the formal parameter                |
| Actual parameter contains: (after an unhandled exception in the called program) | Original actual parameter value prior to the call | Original actual parameter value prior to the call | Original actual parameter value prior to the call |

As shown by the table, an `IN` formal parameter is initialized to the actual parameter with which it is called unless it was explicitly initialized with a default value. The `IN` parameter may be referenced within the called program, however, the called program may not assign a new value to the IN parameter. After control returns to the calling program, the actual parameter always contains the same value as it was set to prior to the call.

The `OUT` formal parameter is initialized to the actual parameter with which it is called. The called program may reference and assign new values to the formal parameter. If the called program terminates without an exception, the actual parameter takes on the value last set in the formal parameter. If a handled exception occurs, the value of the actual parameter takes on the last value assigned to the formal parameter. If an unhandled exception occurs, the value of the actual parameter remains as it was prior to the call.

Like an `IN` parameter, an `IN OUT` formal parameter is initialized to the actual parameter with which it is called. Like an `OUT` parameter, an `IN OUT` formal parameter is modifiable by the called program and the last value in the formal parameter is passed to the calling program’s actual parameter if the called program terminates without an exception. If a handled exception occurs, the value of the actual parameter takes on the last value assigned to the formal parameter. If an unhandled exception occurs, the value of the actual parameter remains as it was prior to the call.

## Using Default Values in Parameters

You can set a default value of a formal parameter by including the `DEFAULT` clause or using the assignment operator (:=) in the `CREATE PROCEDURE` or `CREATE FUNCTION` statement.

The general form of a formal parameter declaration is:

> `(`*`name`* `[ IN|OUT|IN OUT ]` *`data_type`* `[{DEFAULT | := }` *`expr`* `])`

*`name`* is an identifier assigned to the parameter.

`IN|OUT|IN OUT` specifies the parameter mode.

*`data_type`* is the data type assigned to the variable.

*`expr`* is the default value assigned to the parameter. If you do not include a `DEFAULT` clause, the caller must provide a value for the parameter.

The default value is evaluated every time the function or procedure is invoked. For example, assigning `SYSDATE` to a parameter of type `DATE` causes the parameter to have the time of the current invocation, not the time when the procedure or function was created.

The following simple procedure demonstrates using the assignment operator to set a default value of `SYSDATE` into the parameter, `hiredate`:

```
CREATE OR REPLACE PROCEDURE hire_emp (
    p_empno         NUMBER,
    p_ename         VARCHAR2,
    p_hiredate      DATE := SYSDATE
)
IS
BEGIN
    INSERT INTO emp(empno, ename, hiredate)
                   VALUES(p_empno, p_ename, p_hiredate);

    DBMS_OUTPUT.PUT_LINE('Hired!');

END hire_emp;
```

If the parameter declaration includes a default value, you can omit the parameter from the actual parameter list when you call the procedure. Calls to the sample procedure (`hire_emp`) must include two arguments: the employee number (`p_empno`) and employee name (`p_empno`). The third parameter (`p_hiredate`) defaults to the value of `SYSDATE`:

```
 hire_emp (7575, Clark)
```

If you do include a value for the actual parameter when you call the procedure, that value takes precedence over the default value:

```
hire_emp (7575, Clark, 15-FEB-2010)
```

Adds a new employee with a `hiredate` of `February 15, 2010,` regardless of the current value of `SYSDATE`.

You can write the same procedure by substituting the `DEFAULT` keyword for the assignment operator:

```
CREATE OR REPLACE PROCEDURE hire_emp (
    p_empno         NUMBER,
    p_ename         VARCHAR2,
    p_hiredate      DATE DEFAULT SYSDATE
)
IS
BEGIN
    INSERT INTO emp(empno, ename, hiredate)
                   VALUES(p_empno, p_ename, p_hiredate);

    DBMS_OUTPUT.PUT_LINE('Hired!');

END hire_emp;
```

