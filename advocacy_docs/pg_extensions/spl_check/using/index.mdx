---
title: Using EDB SPL Check 
navTitle: Using
---

EDB SPL Check allows you to find errors in EDB Stored Procedure that a `CREATE PROCEDURE/FUNCTION` can miss. The following are some methods to check your code with EDB SPL Check. 

## Checking triggers

To check any trigger, enter a relation that is used together with the trigger function. For example: 

```sql
CREATE TABLE bar(a int, b int);

postgres=# \sf+ foo_trg
    CREATE OR REPLACE FUNCTION public.foo_trg()
         RETURNS trigger
         LANGUAGE edbspl
1       AS $function$
2       BEGIN
3         NEW.c := NEW.a + NEW.b;
4         RETURN NEW;
5       END;
6       $function$
```

The following is returned when there is no specified relation for the trigger:

```sql
postgres=# select * from spl_check_function('foo_trg()');
ERROR:  missing trigger relation
HINT:  Trigger relation oid must be valid
```

The following is returned when the trigger is checked successfully with a specified relation:

```sql
postgres=# select * from spl_check_function('foo_trg()', 'bar');
__OUTPUT__
                 spl_check_function                 
--------------------------------------------------------
 error:42703:3:assignment:record "new" has no field "c"
(1 row)
```

For triggers with transitive tables, set the `oldtable` and `newtable` parameters: 

```sql
create or replace function footab_trig_func()
returns trigger as $$
declare x int;
begin
  if false then
    -- should be ok;
    select count(*) from newtab into x; 

    -- should fail;
    select count(*) from newtab where d = 10 into x;
  end if;
  return null;
end;
$$ language edbspl;

select * from spl_check_function('footab_trig_func','footab', newtable := 'newtab');
```

## Validating compound triggers

Another way to verify a trigger function is to use `spl_check_trigger()` by providing the the trigger name and (optionally) the relation name. This method is useful for redwood-style triggers and compound triggers where there are trigger functions created internally. For example: 

```sql
create table tab(a int);
create or replace trigger tg1 before insert on tab
for each row
begin
  NEW.a := NEW.b;
end;

select * from spl_check_trigger('tg1');
__OUTPUT__
               spl_check_trigger
----------------------------------------------------
 error:42703:2:assignment:record "new" has no field "b"
 Context: PL/pgSQL assignment "NEW.a := NEW.b"
(2 rows)
```

## Validating packages

A package can have multiple functions/procedures. To validate all of your functions/procedures at once, you can use `spl_check_package()`. Similarly, use `spl_check_package_tb()` to view the output in tabular format. 

You can also validate individual package functions/procedures using `spl_check_function()`. For example:

```sql
select * from spl_check_package('<package name>');
```

## Validating object types

Object types can have one or more member functions. To validate all the functions at once, use `spl_check_objecttype()`. Similarly, use `spl_check_objecttype_tb()` to view the output in tabular format. 

You can also validate individual object type member functions using `spl_check_function()`. For example: 

```sql
select * from spl_check_objecttype('<objecttype name>');
```

## Setting in-comment options

EDB SPL Check allows persistent setting written in-comments. These options are taken from a function's source code before checking. The syntax is: 

```sql
@spl_check_option: optioname [=] value [, optname [=] value ...]
```

The settings from comment options has top priority, but generally it can be disabled by setting `use_incomment_options` to `false`. For example: 

```sql
create or replace function fx(anyelement)
returns text as $$
begin
  /*
   * rewrite default polymorphic type to text
   * @spl_check_options: anyelementtype = text
   */
  return $1;
end;
$$ language edbspl;
```

## Checking all your code

Use the `spl_check_function()` to check all of your functions/procedures and to check all your triggers. 

To check all non-trigger `edbspl` functions, do the following:

```sql
SELECT p.oid, p.proname, spl_check_function(p.oid)
   FROM pg_catalog.pg_namespace n
   JOIN pg_catalog.pg_proc p ON pronamespace = n.oid
   JOIN pg_catalog.pg_language l ON p.prolang = l.oid
  WHERE l.lanname = 'edbspl' AND p.prorettype <> 2279;
```

To check all trigger `edbspl` functions, do the following: 

```sql
SELECT p.proname, tgrelid::regclass, cf.*
   FROM pg_proc p
        JOIN pg_trigger t ON t.tgfoid = p.oid 
        JOIN pg_language l ON p.prolang = l.oid
        JOIN pg_namespace n ON p.pronamespace = n.oid,
        LATERAL spl_check_function(p.oid, t.tgrelid) cf
  WHERE n.nspname = 'public' and l.lanname = 'edbspl';
```

To check all `edbspl` functions (including functions or trigger functions with defined triggers), do the following: 

```sql
SELECT
    (pcf).functionid::regprocedure, (pcf).lineno, (pcf).statement,
    (pcf).sqlstate, (pcf).message, (pcf).detail, (pcf).hint, (pcf).level,
    (pcf)."position", (pcf).query, (pcf).context
FROM
(
    SELECT
        spl_check_function_tb(pg_proc.oid, COALESCE(pg_trigger.tgrelid, 0)) AS pcf
    FROM pg_proc
    LEFT JOIN pg_trigger
        ON (pg_trigger.tgfoid = pg_proc.oid)
    WHERE
        prolang = (SELECT lang.oid FROM pg_language lang WHERE lang.lanname = 'edbspl') AND
        pronamespace <> (SELECT nsp.oid FROM pg_namespace nsp WHERE nsp.nspname = 'pg_catalog') AND
        -- ignore unused triggers
        (pg_proc.prorettype <> (SELECT typ.oid FROM pg_type typ WHERE typ.typname = 'trigger') OR
         pg_trigger.tgfoid IS NOT NULL)
    OFFSET 0
) ss
ORDER BY (pcf).functionid::regprocedure::text, (pcf).lineno;
```

## Limitations

EDB SPL Check finds almost all errors on static code. However, when using PL/pgSQL's dynamic features like dynamic SQL or record data data type, false positives are possible. In these cases, it's recommended that the affected function be rewritten or EDB SPL Check disabled for the function. For example: 

```sql
CREATE OR REPLACE FUNCTION f1()
RETURNS void AS $$
DECLARE r record;
BEGIN
  FOR r IN EXECUTE 'SELECT * FROM t1'
  LOOP
    RAISE NOTICE '%', r.c;
  END LOOP;
END;
$$ LANGUAGE edbspl SET edbspl.enable_check TO false;
```

!!!Note
    When passive mode is enabled, usage of EDB SPL Check adds a small overhead and it is recommended that the setting's used only in development or preproduction environments. 

### Dynamic SQL

This module doesn't check queries that are assembled in runtime because it's not possible to identify the results of dynamic queries. Therefore, EDB SPL Check can't set the correct type to record variables and can't check a dependent SQLs or expressions. 

When the type of a record's variable is unknown, you can explicitly assign it with pragma `type`. For example: 

```sql
DECLARE r record;
BEGIN
  EXECUTE format('SELECT * FROM %I', _tablename) INTO r;
  PERFORM spl_check_pragma('type: r (id int, processed bool)');
  IF NOT r.processed THEN
    ...
```

!!! Warning 
    The SQL injection check can't be used for a security audit. This tool detects only some SQL injection vulnerabilities, so some issues might not be detected. It can also raise false alarms. 

### Refcursors

EDB SPL Check can't be used to detect the structure of referenced cursors. A reference on a cursor in `edbspl` is implemented as the name of a global cursor. During the check, the name is usually unknown and the global cursor doesn't exist. This issue is significant when performing any static analysis. `edbspl` is unable to set the correct type for the record variable and can't check the dependent SQL statements or expressions. The solution is the same for dynamic SQL. 

As a solution, do one of the following:

- Don't use the the record variable as a target when you use a `refcursor` type 
- Disable `spl_check` for the affected functions 

For example:

```sql
CREATE OR REPLACE FUNCTION foo(refcur_var refcursor)
RETURNS void AS $$
DECLARE
  rec_var record;
BEGIN
  FETCH refcur_var INTO rec_var; -- this is STOP for spl_check
  RAISE NOTICE '%', rec_var;     -- record rec_var is not assigned yet error
```

In the following case, don't use a record type and instead use a known `rowtype`:

```sql
CREATE OR REPLACE FUNCTION foo(refcur_var refcursor)
RETURNS void AS $$
DECLARE
  rec_var some_rowtype;
BEGIN
  FETCH refcur_var INTO rec_var;
  RAISE NOTICE '%', rec_var;
```

### Temporary tables

EDB SPL Check can't verify queries over temporary tables that are created in `edbspl`'s function runtime. 

As a solution, do one of the following:
- Create a fake temporary table
- Disable EDB SQL Check for this function

Temporary tables are stored in your own schema with higher priority than persistent tables. So, you can perform this workaround safely:

```sql
CREATE OR REPLACE FUNCTION public.disable_dml()
RETURNS trigger
LANGUAGE edbspl AS $function$
BEGIN
  RAISE EXCEPTION SQLSTATE '42P01'
     USING message = format('this instance of %I table doesn''t allow any DML operation', TG_TABLE_NAME),
           hint = format('you should use "CREATE TEMP TABLE %1$I(LIKE %1$I INCLUDING ALL);" statement',
                         TG_TABLE_NAME);
  RETURN NULL;
END;
$function$;

CREATE TABLE foo(a int, b int); -- doesn't hold data, ever
CREATE TRIGGER foo_disable_dml
   BEFORE INSERT OR UPDATE OR DELETE ON foo
   EXECUTE PROCEDURE disable_dml();

postgres=# INSERT INTO  foo VALUES(10,20);
ERROR:  this instance of foo table doesn't allow any DML operation
HINT:  you should to run "CREATE TEMP TABLE foo(LIKE foo INCLUDING ALL);" statement
postgres=# 

CREATE TABLE
postgres=# INSERT INTO  foo VALUES(10,20);
INSERT 0 1
```