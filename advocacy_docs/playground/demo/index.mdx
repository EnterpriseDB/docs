---
title: "PostgreSQL for Beginners: Benchmarking PostgreSQL"
description: "Showing the fine folks at EDB what happens behind the scenes of a Docs 2.0 tutorial."
navTitle: "Benchmarking PostgreSQL"
iconName: postgresql

# Configuration options for Katacoda
platform: ubuntu
katacodaPanel:
    scenario: ubuntu:2004
    initializeCommand: wget -q https://raw.githubusercontent.com/josh-heyer/barmantutorial/main/step01-db-setup/docker-compose.yaml ; docker-compose up -d ; clear ; docker exec -it -u postgres pg /bin/bash
    codelanguages: shell, sql, ini
---

Let say I'm working on a blog article, and I want to explain with the help of an interactive environment, just how to go about doing something like enabling timing.

When you click "Start Now," Katacoda will load a Docker Compose environment with two container images representing a
PostgreSQL 13 server with [the Pagila database](https://github.com/devrimgunduz/pagila) loaded (named `pg`).

Once you see a `postgres@pg` prompt, you can follow the steps below.

!!! ""
This tutorial is currently piggybacking another tutorial's config. This is for demo purposes only.
!!!

<KatacodaPanel />

There's a database up and running, so lets interact with it:

```shell
psql -d pagila
```

Is there anything good in here?

```sql
\dt
__OUTPUT__
                     List of relations
 Schema |       Name       |       Type        |  Owner
--------+------------------+-------------------+----------
 public | actor            | table             | postgres
 public | address          | table             | postgres
 public | category         | table             | postgres
 public | city             | table             | postgres
 public | country          | table             | postgres
 public | customer         | table             | postgres
 public | film             | table             | postgres
 public | film_actor       | table             | postgres
 public | film_category    | table             | postgres
 public | inventory        | table             | postgres
 public | language         | table             | postgres
 public | payment          | partitioned table | postgres
 public | payment_p2020_01 | table             | postgres
 public | payment_p2020_02 | table             | postgres
 public | payment_p2020_03 | table             | postgres
 public | payment_p2020_04 | table             | postgres
 public | payment_p2020_05 | table             | postgres
 public | payment_p2020_06 | table             | postgres
 public | rental           | table             | postgres
 public | staff            | table             | postgres
 public | store            | table             | postgres
(21 rows)
```

Lets see how many actors there are in our database:
```sql
select * from actor;
```


Hmm, I don't know how long that took. Also, I don't want to page all the results when I can scroll.

Lets enable `Timing` and turn off `pager`, so we can see how quickly our queries ran:

```sql
\timing on
\pset pager off
```

Now we should get a timing when we rerun our query:

```sql
select * from actor;
__OUTPUT__
(200 rows)

Time: 0.699 ms
```

Now lets see how many films are in our database and how long the query takes to execute:

```sql
select * from film;
__OUTPUT__
(1000 rows)

Time: 10.289 ms
```