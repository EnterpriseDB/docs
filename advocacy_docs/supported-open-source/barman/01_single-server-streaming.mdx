---
title: "Barman Single-Server Streaming Configuration"
description: "A quick walk-through of Barman installation, configuration, and basic backup and restore operations"
navTitle: Single-Server Streaming Tutorial
product: barman
platform: ubuntu
tags:
    - ubuntu
    - barman
    - postgresql
    - streaming-replication
    - live-demo
katacodaPanel:
    account: enterprisedb
    scenario: sandbox
    codelanguages: shell, sql, ini
iconName: tutorial
---

This provides a quick walk-through of setting up Barman *on* a PostgreSQL server. It covers:

1. Configuring the database server to allow Barman to collect data via streaming replication
2. Installing Barman on an Ubuntu system
3. Configuring Barman for streaming replication
4. Validating a Barman configuration
5. Running a full backup
6. Restoring a full backup

!!! Warning
    Normally, you would never run or store backups on the same server where you're running your database: 
    it adds extra load to the machine already taxed with running
    the database server, and provides little protection from attacks or hardware failure. This is
    intended only to demonstrate the core concepts - for more realistic scenarios, please
    refer to [the Barman Manual](http://docs.pgbarman.org/).

This example is based on a PostgreSQL 12 server running on Ubuntu with the [Pagila database](https://github.com/devrimgunduz/pagila) loaded. 

You can follow along right in your browser, using Katacoda, by clicking the button below:

<KatacodaPanel />

Before we begin, let's run a simple query against the example Pagila database:

```sql
select * from actor where last_name='KILMER';
__OUTPUT__
 actor_id | first_name | last_name |      last_update       
----------+------------+-----------+------------------------
       23 | SANDRA     | KILMER    | 2020-02-15 09:34:33+00
       45 | REESE      | KILMER    | 2020-02-15 09:34:33+00
       55 | FAY        | KILMER    | 2020-02-15 09:34:33+00
      153 | MINNIE     | KILMER    | 2020-02-15 09:34:33+00
      162 | OPRAH      | KILMER    | 2020-02-15 09:34:33+00
(5 rows)
```

We'll verify later on that this data can be restored reliably.

## Database Server Configuration

We'll start by configuring the database itself to allow streaming replication. For this, we need two things:

1. A dedicated user with the required permissions to access the server, run backups, and replication permissions
2. Free replication slots

### User provisioning

Let's call our dedicated backup user `streaming_barman`. Since we need it to connect in replication mode, we'll specify that it will have the `REPLICATION` attribute,
and create it by executing the [Create Role command](https://www.postgresql.org/docs/current/sql-createrole.html) in psql:

```sql
Create Role streaming_barman 
    Login Replication 
    Password 'example-password';
__OUTPUT__
CREATE ROLE
```

!!! Note Make note of that password
    We'll use it later on when configuring Barman

Now we can give this user access to the backup functions, settings, and stats:

```sql
GRANT EXECUTE ON FUNCTION pg_start_backup(text, boolean, boolean) to streaming_barman;
GRANT EXECUTE ON FUNCTION pg_stop_backup() to streaming_barman;
GRANT EXECUTE ON FUNCTION pg_stop_backup(boolean, boolean) to streaming_barman;
GRANT EXECUTE ON FUNCTION pg_switch_wal() to streaming_barman;
GRANT EXECUTE ON FUNCTION pg_create_restore_point(text) to streaming_barman;

GRANT pg_read_all_settings TO streaming_barman;
GRANT pg_read_all_stats TO streaming_barman;
```

We'll also need to make sure there are replication slots available, and that PostgreSQL will allow another sender to connect. The default for both of these (for PostgreSQL 10 and above) is 10:

```sql
Show max_wal_senders;
Show max_replication_slots;
__OUTPUT__
 max_wal_senders 
-----------------
 10
(1 row)

 max_replication_slots 
-----------------------
 10
(1 row)
```

...So we're fine - but if we needed more (or if they'd been previously set to 0, thus [disabling replication](https://www.postgresql.org/docs/current/runtime-config-replication.html)) then we'd need to increase them.

With that out of the way, we can quit psql, switch to root and move on to installing Barman:

```sql
\q
exit
__OUTPUT__
pagila=# \q
postgres@host01:~$ exit
logout
$
```

## Installing Barman

This walk-through uses an Ubuntu environment, so the first step is to configure the PostgreSQL repository (details are [on the PostgreSQL wiki](https://wiki.postgresql.org/wiki/Apt)):

```shell
apt-get update
apt-get install -y curl ca-certificates gnupg lsb-release
curl https://www.postgresql.org/media/keys/ACCC4CF8.asc | apt-key add -

sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list'
apt-get update
__OUTPUT__
...
done.
```

With the repository configured, we can use apt to install Barman:

```shell
apt-get -y install barman
__OUTPUT__
...
Setting up barman (2.12-1.pgdg18.04+1) ...
Processing triggers for man-db (2.8.3-2ubuntu0.1) ...
```

For more details on installation (including instructions for other supported operating systems), see: [Installation](http://docs.pgbarman.org/release/2.12/#installation) in the Barman guide.

## Configuration

All the important details for a Barman server go into a server configuration file, by default located in `/etc/barman.d`. These are in the classic INI format, with relevant settings in a section named after the server we're going to back up. We'll also use that name for the configuration file itself. Since this is an example and we're running locally, we'll call it localhost:

```ini
cat <<'EOF' >> /etc/barman.d/localhost.conf
[localhost]
description =  "Example of PostgreSQL Database (Streaming-Only)"
conninfo = host=localhost user=streaming_barman dbname=pagila
streaming_conninfo = host=localhost user=streaming_barman dbname=pagila
backup_method = postgres
streaming_archiver = on
slot_name = barman
create_slot = auto
EOF
```

Note that this references the user (`streaming_barman`) that we created earlier. Also of interest is the value for `slot_name` - this is a replication slot that will also have to be created on the server - but we can instruct Barman to do that for us by setting `create_slot` to `auto`.

In order for Barman to connect via the user specified, we'll need to add the password we specified earlier to Barman's [.pgpass file](https://www.postgresql.org/docs/current/libpq-pgpass.html):

```shell
cat <<'EOF' >>~barman/.pgpass
localhost:*:*:streaming_barman:example-password
EOF
chown barman ~barman/.pgpass
chmod 0600 ~barman/.pgpass
```

Note the change in ownership and permissions - these are necessary to protect the file, and it will not be used without them.

!!! Important Remember, this is just a brief walk-through
    You would certainly want to be a bit less cavalier about credential management on a production system!

For more details on configuration files, see: [Configuration](http://docs.pgbarman.org/release/2.12/#configuration) in the pgBarman guide.

### Verifying the configuration

Now that the configuration is done, we can use Barman's check command to verify that it works:

```shell
barman check localhost
__OUTPUT__
Server localhost:
        WAL archive: FAILED (please make sure WAL shipping is setup)
        PostgreSQL: OK
        superuser or standard user with backup privileges: OK
        PostgreSQL streaming: OK
        wal_level: OK
        replication slot: OK
        directories: OK
        retention policy settings: OK
        backup maximum age: OK (no last_backup_maximum_age provided)
        compression settings: OK
        failed backups: OK (there are 0 failed backups)
        minimum redundancy requirements: OK (have 0 backups, expected at least 0)
        pg_basebackup: OK
        pg_basebackup compatible: OK
        pg_basebackup supports tablespaces mapping: OK
        systemid coherence: OK (no system Id stored on disk)
        pg_receivexlog: OK
        pg_receivexlog compatible: OK
        receive-wal running: OK
        archiver errors: OK
```

Uh-oh! WAL archive failed? Not a problem - that just means Barman hasn't seen any new WAL archives come in yet, which isn't surprising given this is an example 
database with no writes happening! We can trigger an archive manually and verify that this works:

```shell
barman switch-wal --archive --archive-timeout 60 localhost
__OUTPUT__
The WAL file 000000010000000000000002 has been closed on server 'localhost'
Waiting for the WAL file 000000010000000000000002 from server 'localhost' (max: 60 seconds)
Processing xlog segments from streaming for localhost
        000000010000000000000002
```
This forces WAL rotation and (with the `--archive` option) waits for the WAL to arrive. We'll give it 60 seconds (with the `--archive-timeout` option) to complete; 
if it doesn't complete within that amount of time, try again. For more detail on these commands and their options, refer to [the Barman man page](https://docs.pgbarman.org/release/2.12/barman.1.html#commands).

Once switch-wal has completed successfully, run the check again and you should see all checks passing:

```shell
barman check localhost
__OUTPUT__
Server localhost:
        PostgreSQL: OK
        superuser or standard user with backup privileges: OK
        PostgreSQL streaming: OK
        wal_level: OK
        replication slot: OK
        directories: OK
        retention policy settings: OK
        backup maximum age: OK (no last_backup_maximum_age provided)
        compression settings: OK
        failed backups: OK (there are 0 failed backups)
        minimum redundancy requirements: OK (have 0 backups, expected at least 0)
        pg_basebackup: OK
        pg_basebackup compatible: OK
        pg_basebackup supports tablespaces mapping: OK
        systemid coherence: OK (no system Id stored on disk)
        pg_receivexlog: OK
        pg_receivexlog compatible: OK
        receive-wal running: OK
        archiver errors: OK
```
## Backup & verify

Now we can fire off a backup:

```shell
barman backup localhost --wait
__OUTPUT__
Starting backup using postgres method for server localhost in /var/lib/barman/localhost/base/20210223T200345
Backup start at LSN: 0/3000060 (000000010000000000000003, 00000060)
Starting backup copy via pg_basebackup for 20210223T200345
WARNING: pg_basebackup does not copy the PostgreSQL configuration files that reside outside PGDATA. Please manually backup the following files:
        /etc/postgresql/12/main/postgresql.conf
        /etc/postgresql/12/main/pg_hba.conf
        /etc/postgresql/12/main/pg_ident.conf

Copy done (time: 2 seconds)
Finalising the backup.
This is the first backup for server localhost
WAL segments preceding the current backup have been found:
        000000010000000000000002 from server localhost has been removed
Backup size: 39.7 MiB
Backup end at LSN: 0/5000000 (000000010000000000000004, 00000000)
Backup completed (start time: 2021-02-23 20:03:45.529237, elapsed time: 2 seconds)
Waiting for the WAL file 000000010000000000000004 from server 'localhost'
Processing xlog segments from streaming for localhost
        000000010000000000000003
Processing xlog segments from streaming for localhost
        000000010000000000000004
```

Verify that it completed by listing backups for the server:

```shell
barman list-backup localhost
__OUTPUT__
localhost 20210223T200345 - Tue Feb 23 20:03:48 2021 - Size: 55.7 MiB - WAL Size: 0 B
```
(well, the timestamps will be different for you)
## Restore server

It's not a real backup until you've restored it - so let's end with that. 

!!! Danger This process is for demonstration purposes, and is explicitly destructive!
    In a production scenario, you would restore to a new location and verify the data 
    Also, you wouldn't be running this on the same machine as your database!

Let's connect to the database and destroy some data, necessitating a restoration:

```shell
su - postgres -c 'psql -d pagila'
__OUTPUT__
psql (12.4 (Ubuntu 12.4-1.pgdg18.04+1))
Type "help" for help.

pagila=#
```

```sql
Drop Table actor Cascade;
select * from actor;
__OUTPUT__
NOTICE:  drop cascades to 4 other objects
DETAIL:  drop cascades to view actor_info
drop cascades to view film_list
drop cascades to view nicer_but_slower_film_list
drop cascades to constraint film_actor_actor_id_fkey on table film_actor
DROP TABLE

ERROR:  relation "actor" does not exist
LINE 1: select * from actor;
```

Oops! No worries - **we have a backup.** Back to the shell to do some repair work:

```sql
\q
```

First, we'll stop the database:

```shell
systemctl stop postgresql
```

Now we can restore the backup, running as the barman user, into a temporary directory:

```shell
su - barman -c "barman recover localhost last ~/recovered"
__OUTPUT__
Starting local restore for server localhost using backup 20210223T200345
Destination directory: /var/lib/barman/recovered
Copying the base backup.
Copying required WAL segments.
Generating archive status files
Identify dangerous settings in destination directory.

WARNING
The following configuration files have not been saved during backup, hence they have not been restored.
You need to manually restore them in order to start the recovered PostgreSQL instance:

    postgresql.conf
    pg_hba.conf
    pg_ident.conf

Recovery completed (start time: 2021-02-23 20:10:03.969282, elapsed time: less than one second)

Your PostgreSQL server has been successfully prepared for recovery!
```

At this point, you could examine the files:

```shell
ls ~barman/recovered
__OUTPUT__
backup_label  pg_commit_ts  pg_multixact  pg_serial     pg_stat_tmp  pg_twophase  pg_xact
base          pg_dynshmem   pg_notify     pg_snapshots  pg_subtrans  PG_VERSION   postgresql.auto.conf
global        pg_logical    pg_replslot   pg_stat       pg_tblspc    pg_wal       postgresql.auto.conf.origin
```

And finally, overwrite the original database, ownership to postgres and restart the server:

```shell
rm -R /var/lib/postgresql/12/main
mv ~barman/recovered /var/lib/postgresql/12/main
chown -R postgres /var/lib/postgresql/12/main
systemctl start postgresql
```

Now we should be able to reconnect to the database:

```shell
su - postgres -c 'psql -d pagila'
__OUTPUT__
psql (12.4 (Ubuntu 12.4-1.pgdg18.04+1))
Type "help" for help.

pagila=# 
```

...And re-run the query we started out with:

```sql
select * from actor where last_name='KILMER';
__OUTPUT__
 actor_id | first_name | last_name |      last_update       
----------+------------+-----------+------------------------
       23 | SANDRA     | KILMER    | 2020-02-15 09:34:33+00
       45 | REESE      | KILMER    | 2020-02-15 09:34:33+00
       55 | FAY        | KILMER    | 2020-02-15 09:34:33+00
      153 | MINNIE     | KILMER    | 2020-02-15 09:34:33+00
      162 | OPRAH      | KILMER    | 2020-02-15 09:34:33+00
(5 rows)
```

## Conclusion

This walk-through barely scratches the surface of what is possible with Barman, but hopefully it has provided you with a taste of its capabilities! For more details, visit https://pgbarman.org/
