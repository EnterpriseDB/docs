---
title: Conflict settings
indexdepth: 2
---

# Conflict detection

## bdr.alter_table_conflict_detection

Allows the table owner to change how conflict detection works for a given table.

### Synopsis

```sql
bdr.alter_table_conflict_detection(relation regclass,
                                   method text,
                                   column_name name DEFAULT NULL)
```

### Parameters

-   `relation` &mdash; Name of the relation for which to set the new conflict detection method.
-   `method` &mdash; The conflict detection method to use.
-   `column_name` &mdash; The column to use for storing the column detection data. This can be skipped, in which case the column name is chosen based on the conflict detection method. The `row_origin` method doesn't require an extra column for metadata storage.

The recognized methods for conflict detection are:

-   `row_origin` &mdash; Origin of the previous change made on the tuple (see [Origin conflict detection](#origin-conflict-detection)). This is the only method supported that doesn't require an extra column in the table.
-   `row_version` &mdash; Row version column (see [Row version conflict detection](#row-version-conflict-detection)).
-   `column_commit_timestamp` &mdash; Per-column commit timestamps (described in [CLCD](column-level-conflicts)).
-   `column_modify_timestamp` &mdash; Per-column modification timestamp (described in [CLCD](column-level-conflicts)).

### Notes

For more information about the difference between `column_commit_timestamp` and `column_modify_timestamp` conflict detection methods, see [Current versus commit timestamp](column-level-conflicts#current-versus-commit-timestamp).

This function uses the same replication mechanism as `DDL` statements. This means the replication is affected by the [ddl filters](../repsets#ddl-replication-filtering) configuration.

The function takes a `DML` global lock on the relation for which column-level conflict resolution is being enabled.

This function is transactional. You can roll back the effects with the `ROLLBACK` of the transaction, and the changes are visible to the current transaction.

Only the owner of the `relation` can execute the `bdr.alter_table_conflict_detection` function unless `bdr.backwards_compatibility` is set to 30618 or less.

!!! Warning
    When changing the conflict detection method from one that uses an extra column to store metadata, that column is dropped.

!!! Warning
    This function disables CAMO and gives a warning, as long as warnings aren't disabled with `bdr.camo_enable_client_warnings`.

## List of conflict types

PGD recognizes the following conflict types, which can be used as the `conflict_type` parameter:

-   `insert_exists` &mdash; An incoming insert conflicts with an existing row by way of a primary key or a unique key/index.
-   `update_differing` &mdash; An incoming update's key row differs from a local row. This can happen only when using [row version conflict detection](#row-version-conflict-detection).
-   `update_origin_change` &mdash; An incoming update is modifying a row that was last changed by a different node.
-   `update_missing` &mdash; An incoming update is trying to modify a row that doesn't exist.
-   `update_recently_deleted` &mdash; An incoming update is trying to modify a row that was recently deleted.
-   `update_pkey_exists` &mdash; An incoming update has modified the `PRIMARY KEY` to a value that already exists on the node that's applying the change.
-   `multiple_unique_conflicts` &mdash; The incoming row conflicts with multiple UNIQUE constraints/indexes in the target table.
-   `delete_recently_updated` &mdash; An incoming delete with an older commit timestamp than the most recent update of the row on the current node or when using [row version conflict detection](#row-version-conflict-detection).
-   `delete_missing` &mdash; An incoming delete is trying to remove a row that doesn't exist.
-   `target_column_missing` &mdash; The target table is missing one or more columns present in the incoming row.
-   `source_column_missing` &mdash; The incoming row is missing one or more columns that are present in the target table.
-   `target_table_missing` &mdash; The target table is missing.
-   `apply_error_ddl` &mdash; An error was thrown by Postgres when applying a replicated DDL command.

# Conflict resolution

Most conflicts can be resolved automatically. PGD defaults to a last-update-wins mechanism or, more accurately, the `update_if_newer` conflict resolver. This mechanism retains the most recently inserted or changed row of the two conflicting ones based on the same commit timestamps used for conflict detection. The behavior in certain corner-case scenarios depends on the settings used for `bdr.create_node_group` and
alternatively for `bdr.alter_node_group`.

PGD lets you override the default behavior of conflict resolution by using the following function.

## bdr.alter_node_set_conflict_resolver

This function sets the behavior of conflict resolution on a given node.

### Synopsis

```sql
bdr.alter_node_set_conflict_resolver(node_name text,
                                     conflict_type text,
                                     conflict_resolver text)
```

### Parameters

-   `node_name` &mdash; Name of the node that's being changed.
-   `conflict_type` &mdash; Conflict type for which to apply the setting (see [List of conflict types](#list-of-conflict-types)).
-   `conflict_resolver` &mdash; Resolver to use for the given conflict type (see [List of conflict resolvers](#list-of-conflict-resolvers)).

### Notes

Currently you can change only the local node. The function call isn't replicated. If you want to change settings on multiple nodes, you must run the function on each of them.

The configuration change made by this function overrides any default behavior of conflict resolutions specified by `bdr.create_node_group` or `bdr.alter_node_group`.

This function is transactional. You can roll back the changes, and they are visible to the current transaction.

## List of conflict resolvers

Several conflict resolvers are available in PGD, with differing coverages of the conflict types they can handle:

-   `error` &mdash; Throws error and stops replication. Can be used for any conflict type.
-   `skip` &mdash; Skips processing the remote change and continues replication with the next change. Can be used for `insert_exists`, `update_differing`, `update_origin_change`, `update_missing`, `update_recently_deleted`, `update_pkey_exists`, `delete_recently_updated`, `delete_missing`, `target_table_missing`, `target_column_missing`, and `source_column_missing` conflict types.
-   `skip_if_recently_dropped` &mdash; Skips the remote change if it's for a table that doesn't exist downstream because it was recently (within one day) dropped on the downstream. Throw an error otherwise. Can be used for the `target_table_missing` conflict type. `skip_if_recently_dropped` conflict
resolver can pose challenges if a table with the same name is re-created shortly after it's dropped. In that case, one of the nodes might see the DMLs on the re-created table before it sees the DDL to re-create the table. It then incorrectly skips the remote data, assuming that the table is recently dropped, and causes data loss. We hence recommend that you don't reuse the object names immediately after they're dropped along with this conflict resolver.
-   `skip_transaction` &mdash; Skips the whole transaction that generated the conflict. Can be used for `apply_error_ddl` conflict.
-   `update_if_newer` &mdash; Updates if the remote row was committed later (as determined by the wall clock of the originating node) than the conflicting local row. If the timestamps are same, the node id is used as a tie-breaker to ensure that same row is picked on all nodes (higher nodeid wins). Can be used for `insert_exists`, `update_differing`, `update_origin_change`, and `update_pkey_exists` conflict types.
-   `update` &mdash; Always performs the replicated action. Can be used for `insert_exists` (turns the `INSERT` into `UPDATE`), `update_differing`, `update_origin_change`, `update_pkey_exists`, and `delete_recently_updated` (performs the delete).
-   `insert_or_skip` &mdash; Tries to build a new row from available information sent by the origin and INSERT it. If there isn't enough information available to build a full row, skips the change. Can be used for `update_missing` and `update_recently_deleted` conflict types.
-   `insert_or_error` &mdash; Tries to build new row from available information sent by origin and insert it. If there isn't enough information available to build full row, throws an error and stops the replication. Can be used for `update_missing` and `update_recently_deleted` conflict types.
-   `ignore` &mdash; Ignores any missing target column and continues processing. Can be used for the `target_column_missing` conflict type.
-   `ignore_if_null` &mdash; Ignores a missing target column if the extra column in the remote row contains a NULL value. Otherwise, throws an error and stops replication. Can be used for the `target_column_missing` conflict type.
-   `use_default_value` &mdash; Fills the missing column value with the default (including NULL if that's the column default) and continues processing. Any error while processing the default or violation of constraints (that is, NULL default on NOT NULL column) stops replication. Can be used for the `source_column_missing` conflict type.

The `insert_exists`, `update_differing`, `update_origin_change`, `update_missing`, `multiple_unique_conflicts`, `update_recently_deleted`, `update_pkey_exists`, `delete_recently_updated`, and `delete_missing` conflict types can also be resolved by user-defined logic using
[Conflict triggers](../striggers).

This matrix helps you individuate the conflict types the conflict resolvers can handle.

|                          | insert_exists | update_differing | update_origin_change | update_missing | update_recently_deleted | update_pkey_exists | delete_recently_updated | delete_missing | target_column_missing | source_column_missing | target_table_missing | multiple_unique_conflicts |
| :----------------------- | ------------- | ---------------- | -------------------- | -------------- | ----------------------- | ------------------ | ----------------------- | -------------- | --------------------- | --------------------- | -------------------- | ------------------------- |
| error                    | X             | X                | X                    | X              | X                       | X                  | X                       | X              | X                     | X                     | X                    | X                         |
| skip                     | X             | X                | X                    | X              | X                       | X                  | X                       | X              | X                     | X                     | X                    | X                         |
| skip_if_recently_dropped |               |                  |                      |                |                         |                    |                         |                |                       |                       | X                    |                           |
| update_if_newer          | X             | X                | X                    |                |                         | X                  |                         |                |                       |                       |                      |                           |
| update                   | X             | X                | X                    |                |                         | X                  | X                       |                |                       |                       |                      | X                         |
| insert_or_skip           |               |                  |                      | X              | X                       |                    |                         |                |                       |                       |                      |                           |
| insert_or_error          |               |                  |                      | X              | X                       |                    |                         |                |                       |                       |                      |                           |
| ignore                   |               |                  |                      |                |                         |                    |                         |                | X                     |                       |                      |                           |
| ignore_if_null           |               |                  |                      |                |                         |                    |                         |                | X                     |                       |                      |                           |
| use_default_value        |               |                  |                      |                |                         |                    |                         |                |                       | X                     |                      |                           |
| conflict_trigger         | X             | X                | X                    | X              | X                       | X                  | X                       | X              |                       |                       |                      | X                         |

## Default conflict resolvers

| Conflict type             | Resolver                 |
| ------------------------- | ------------------------ |
| insert_exists             | update_if_newer          |
| update_differing          | update_if_newer          |
| update_origin_change      | update_if_newer          |
| update_missing            | insert_or_skip           |
| update_recently_deleted   | skip                     |
| update_pkey_exists        | update_if_newer          |
| multiple_unique_conflicts | error                    |
| delete_recently_updated   | skip                     |
| delete_missing            | skip                     |
| target_column_missing     | ignore_if_null           |
| source_column_missing     | use_default_value        |
| target_table_missing (see note)     | skip_if_recently_dropped |
| apply_error_ddl           | error                    |

<div id="target_table_note"></div>

!!! note target_table_missing
This conflict type isn't detected on community Postgresql. If the target table is missing, it causes an error and halts replication.
EDB Postgres servers detect and handle missing target tables and can invoke the resolver.
!!!

## List of conflict resolutions

The conflict resolution represents the kind of resolution chosen by the conflict resolver and corresponds to the specific action that was taken to resolve the conflict.

The following conflict resolutions are currently supported for the `conflict_resolution` parameter:

-   `apply_remote` &mdash; The remote (incoming) row was applied.
-   `skip` &mdash; Processing of the row was skipped (no change was made locally).
-   `merge` &mdash; A new row was created, merging information from remote and local row.
-   `user` &mdash; User code (a conflict trigger) produced the row that was written to the target table.

# Conflict logging

To ease diagnosing and handling multi-master conflicts, PGD, by default, logs every conflict into the `bdr.conflict_history` table. You can change this behavior with more granularity with the following functions.

## bdr.alter_node_set_log_config

Set the conflict logging configuration for a node.

### Synopsis

```sql
bdr.alter_node_set_log_config(node_name text,
                              log_to_file bool DEFAULT true,
                              log_to_table bool DEFAULT true,
                              conflict_type text[] DEFAULT NULL,
                              conflict_resolution text[] DEFAULT NULL)
```

### Parameters

-   `node_name` &mdash; Name of the node that's being changed.
-   `log_to_file` &mdash; Whether to log to the node log file.
-   `log_to_table` &mdash; Whether to log to the `bdr.conflict_history` table.
-   `conflict_type` &mdash; Conflict types to log. NULL (the default) means all.
-   `conflict_resolution` &mdash; Conflict resolutions to log. NULL (the default) means all.

### Notes

You can change only the local node. The function call isn't replicated. If you want to change settings on multiple nodes, you must run the function on each of them.

This function is transactional. You can roll back the changes, and they're visible to the current transaction.

### Listing conflict logging configurations

The view `bdr.node_log_config` shows all the logging configurations. It lists the name of the logging configuration, where it logs, and the conflict type and resolution it logs.

### Logging conflicts to a table

If `log_to_table` is set to true, conflicts are logged to a table. The target table for conflict logging is `bdr.conflict_history`.

This table is range partitioned on the column `local_time`. The table is managed by autopartition. By default, a new partition is created for every day, and conflicts of the last one month are maintained. After that, the old partitions are dropped automatically. Autopartition creates between 7 and 14 partitions in advance. bdr_superuser can change these defaults.

Since conflicts generated for all tables managed by PGD are logged to this table, it's important to ensure that only legitimate users can read the conflicted data. PGD does this by defining ROW LEVEL SECURITY policies on the `bdr.conflict_history` table. Only owners of the tables are allowed to read conflicts on the respective tables. If the underlying tables have RLS policies defined, enabled, and enforced, then even owners can't read the conflicts. RLS policies created with the FORCE option also apply to owners of the table. In that case, some or all rows in the underlying table might not be readable even to the owner. So PGD also enforces a stricter policy on the conflict log table.

The default role `bdr_read_all_conflicts` can be granted to users who need to see all conflict details logged to the `bdr.conflict_history` table without also granting them `bdr_superuser` role.

The default role `bdr_read_all_stats` has access to a catalog view called `bdr.conflict_history_summary`, which doesn't contain user data, allowing monitoring of any conflicts logged.

## Conflict reporting

You can summarize conflicts logged to tables in reports. Reports allow application owners to identify, understand, and resolve conflicts and introduce application changes to prevent them.

```sql
SELECT nspname, relname
, date_trunc('day', local_time) :: date AS date
, count(*)
FROM bdr.conflict_history
WHERE local_time > date_trunc('day', current_timestamp)
GROUP BY 1,2,3
ORDER BY 1,2;

 nspname | relname |    date    | count
---------+---------+------------+-------
 my_app  | test    | 2019-04-05 |     1
(1 row)
```