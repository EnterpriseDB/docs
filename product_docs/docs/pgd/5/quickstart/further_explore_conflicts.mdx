---
title: "Exploring conflict handling with PGD"
navTitle: "Exploring conflicts"
description: >
  An exploration of how PGD handles conflicts between data nodes
---

## Conflicts

When one database node has an update from an application to a row and another node has a different update to the same row, there will be a conflict between the two nodes. Resolving that conflict is core to how Postgres Distributed maintains consistency. To see how it works, you need to open a command line view of all the servers. You can then create and monitor conflicts to better understand them.

## Installing xpanes

You will be using xpanes, a utility which allows you to quickly create multiple terminal sessions which you can quickly switch between. It is not installed by default, so you will have to install it. Start by connecting to the "kaboom" node with ssh.

```shell
cd democluster && ssh -F ssh_config kaboom
```

If you are running the quick start on docker, you'll be using Rocky Linux, a Red Hat derivative. To perform the xpanes install run:

```shell
dnf -y install xpanes
```

If you are running the quick start on AWS, you'll be using Debian Linux. To perform the xpanes install run:

```shell
sudo apt install tmux
wget https://github.com/greymd/tmux-xpanes/releases/download/v4.1.4/tmux-xpanes_v4.1.4.deb
sudo dpkg -i tmux-xpanes*.deb
rm tmux-xpanes*.deb
```

## Connecting to four servers

You need to be logged in as the enterprisedb user to allow authentication to work:

```shell
sudo -iu enterprisedb
```

 Then run the following command to connect to three database servers and a proxy server:

```shell
xpanes -d -c "psql postgresql://enterprisedb@{}/bdrdb?sslmode=require" "kaboom:5444" "kaftan:5444" "kaolin:5444" "kaboom:6432"
```

xpanes takes the command after `-c` and substitutes in the values in the arguments that follow to create a command to run. That means that when run, there will be four panes. Three panes will be connected to kaboom, kaftan and kaolin on port 5444 - the database nodes - and one will be connected to the pgd-proxy running on kaboom on port 6432. Each one will be logged into the database as `enterprisedb`.

Typing Control-b followed by q will briefly display the numeric values for each pane.

![4 Sessions showing numbers](images/4sessions.png)

To switch the focus between the panes, type control-b followed by q and the number of the pane you want to focus on. Use control-b q 3 to move the focus to the bottom right pane.


## Preparing for conflicts

To make a conflict, we need a simple table. In the currently focussed pane enter the following:

```
drop table if exists test_conflict;
create table test_conflict(
  id integer primary key ,
  value_1 text);
```

## Monitoring conflicts

In the currently focussed pane, enter the following:

```sql
select * from bdr.conflict_history_summary ;
\watch 1
```

The `select` command displays the conflict history for the cluster. The `\watch 1` command is a psql command which re-runs the previous command every second.

You are now ready to generate a conflict.

## Creating a conflict

The most basic form of conflict is when an insert happens to a table on two different nodes and both have the same primary key. You can now create that scenario and observe it.

Move to the top left pane with control-b q 0. This is the "kaboom" node. It's here that you want to start a transaction and insert a row:

```
start transaction;
insert into test_conflict values (1, 'from kaboom');
```

Now move to the top right pane with control-b q 1. This is the "kaftan" node. You'll want to do the same here, start a transaction and insert into the same row with different data.

```
start transaction;
insert into test_conflict values (1, 'from kaftan');
```

You now have two transactions open on different servers, with an insert operation already performed successfully. You need to commit both transactions at this point. Type 

* Control-b q 0 then `commit;` 
* Control-b q 1 then `commit;`

What you'll see is both commits working, but, down in the bottom right pane you will be able to see the conflict being detected.

![4 Sessions showing conflict detected](images/4sessionsinsertconflict.png)

There is now a row in the conflict history that notes a conflict in our table where the  `insert_exists` and the resolution for this conflict is that the newer record, based on the timing of the commit, is retained. This is called an INSERT/INSERT conflict and you can read more about this in the [INSERT/INSERT Conflicts](../consistency/conflicts/#insertinsert-conflicts).

## Creating an update conflict

When different updates take place to the same records on different nodes, a conflict occurs. You can create that scenario with our current configuration too. Leave the `\watch 1` running in the bottom right pane.

Move to the top left pane with control-b q 0. This is the "kaboom" node. It's here that you want to start a transaction and update a row:

```
start transaction;
update test_conflict set value_1 = 'update from kaboom' where id = 1;
```

Now move to the top right pane with control-b q 1. This is the "kaftan" node. You'll want to do the same here, start a transaction and update the same row with different data.

```
start transaction;
update test_conflict set value_1 = 'update from kaftan' where id = 1;
```

You now have two transactions open on different servers, with an update operation already performed successfully. You need to commit both transactions at this point. Type 

* Control-b q 0 then `commit;` 
* Control-b q 1 then `commit;`

Again What you'll see is both commits working, but, down in the bottom right pane you will be able to see the update conflict being detected.

![4 Sessions showing update conflict detected](images/4sessionsupdateconflict.png)

Now there is an additional row in the conflict history showing an `update_origin_change` conflict had occured and that the resolution was the `apply_remote`. This means that the remote change was applied, updating the record. This is called an UPDATE/UPDATE conflict and is explained in more detail in [UPDATE/UPDATE Conflicts](../consistency/conflicts/#updateupdate-conflicts). 

## Other conflicts

You are now equipped to explore all the possible conflict scenarios and resolutions that could occur. For full details of how conflicts are managed see [Conflicts](../consistency/conflicts/), a full description of conflicts in the documentation. The important thing to know about conflicts is that you should ideally avoid them, but when they do happen they are recorded and managed by Postgres Distributed's integrated and configurable conflict resolver.


