---
title: EDB Postgres Distributed 6.0.0 release notes
navTitle: Version 6.0.0
originalFilePath: product_docs/docs/pgd/6/rel_notes/src/relnote_6.0.0.yml
editTarget: originalFilePath
---

Released: 22 May 2025

EDB Postgres Distributed 6.0.0 is a major update to PGD and sees the introduction on Essential and Extended editions.

## Highlights

- Connection Manager replaces PGD Proxy.

## Features

<table class="table w-100"><thead><tr><th>Description</th><th width="10%">Addresses</th></tr></thead><tbody>
<tr><td><details><summary>Builtin connection manager</summary><hr/><p>New built-in connection manager which handles routing of connections automatically and allows enforcing of read-only connections to non-leader.</p>
</details></td><td></td></tr>
<tr><td><details><summary>CLI cluster setup</summary><hr/><p>The PGD CLI now allows initial cluster setup as well as adding nodes from command-line using <code>pgd node setup</code> command.</p>
</details></td><td></td></tr>
<tr><td><details><summary>Connection Manager replaces PGD Proxy</summary><hr/><p>The connection manager is a new component that replaces the PGD Proxy. It is responsible for managing connections to the database and routing them to the appropriate nodes in the cluster. The connection manager provides improved performance, scalability, and reliability compared to the previous PGD Proxy.</p>
</details></td><td></td></tr>
<tr><td><details><summary>Set sequence kind on group create/join</summary><hr/><p>Transform the sequences in distributed based on the <code>bdr.default_sequence_kind</code> GUC when creating/joining a bdr group instead of when creating the node as done in older versions.</p>
</details></td><td></td></tr>
<tr><td><details><summary>Set startvalue for distributed sequences automatically</summary><hr/><p>Set the startvalue for galloc sequences to the following valid number after the last used by the local sequence. With this change, when creating distributed sequences and specifically galloc, there is no need to adjust the startvalue based on what might be already used.</p>
</details></td><td></td></tr>
<tr><td><details><summary>Enabling of automatic sync and reconciliation</summary><hr/><p>Link to a detailed google doc is provided below</p>
</details></td><td></td></tr>
<tr><td><details><summary>Add node_uuid column to bdr.node and bdr.local_node</summary><hr/><p>The node_uuid uniquely identifies instance of a node of a given name. Random node_uuid is generated when node is created and remains constant for the lifetime of the node. The node_id column is now derived from node_uuid instead of node name.</p>
<p>For the time being a node needs to be fully parted before before node of the same name can be rejoined, this may be relaxed in future releases to permit rejoin as soon as part_node process for the old instance has commenced and before it completed.</p>
<p>For the time being upgrades from older PGD versions and mixed-version operation in clusters with older PGD nodes are not supported. This limitation will be addressed in future releases.</p>
</details></td><td></td></tr>
<tr><td><details><summary>Change replication origin and slot naming scheme</summary><hr/><p>Replication origin and slot names now use node uuid and thus correspond to particular incarnation of a node of a given name. Similarly node group uuid is used instead of group name. Hash of database name is used in lieu of database name.</p>
<p>Please note that origin and node names should be treated as opaque identifiers from user's perspective, one shouldn't rely on the structure of these names nor expect these to be particularly meaningful to a human operator.</p>
<p>The new naming scheme is as follows:</p>
<h1>Slots Naming Convention</h1>
<p>| normal slot to a node | <code>bdr_node_&lt;targetuuid&gt;_&lt;dbhash&gt;</code> |
| join slot for node | <code>bdr_node_&lt;targetuuid&gt;_&lt;dbhash&gt;_tmp</code> |
| group slot for a topgroup | <code>bdr_group_&lt;topgroupuuid&gt;_&lt;dbhash&gt;</code> |
| slot for any forwading + lead to lead | <code>bdr_node_&lt;targetuuid&gt;_&lt;originidhex&gt;_&lt;dbhash&gt;</code> |
| analytics slot | <code>bdr_analytics_&lt;groupuuid&gt;_&lt;dbhash&gt;</code> |
| decoding slot | <code>bdr_decoder_&lt;topgroupuuid&gt;_&lt;dbhash&gt;</code> |</p>
<h1>Origins Naming Convention:</h1>
<p>| normal origin to a node | <code>bdr_&lt;originuuid&gt;_&lt;dbhash&gt;</code> |
| fwd origin to a source node | <code>bdr_&lt;originuuid&gt;_&lt;sourceoidhex&gt;_&lt;dbhash&gt;</code> |</p>
</details></td><td></td></tr>
<tr><td><details><summary>Limit on the number of node groups allowed in the system for PGD Essential.</summary><hr/><p>Ensure that no more than three node groups (one top group and two subgroups) can exist at any given time. If the limit is exceeded, an error is raised.</p>
</details></td><td></td></tr>
<tr><td><details><summary>Enforce essential limits - data node count</summary><hr/><p>Don't allow Essential builds to join more than 4 data nodes.</p>
</details></td><td></td></tr>
<tr><td><details><summary>Added bdr.wait_node_confirm_lsn() function which waits until a given reaches a given LSN</summary><hr/><p>bdr.wait_node_confirm_lsn() will look at the confirmed_flush_lsn of the given node when available, otherwise it will query pg_replication_origin_progress() of that node, and wait for the specified LSN to be reached by said node.</p>
</details></td><td></td></tr>
<tr><td><details><summary>Subscriber-only nodes can now be added to data node groups</summary><hr/><p>So far subscriber-only nodes could only be added to node groups of type &quot;subscriber-only&quot;. But now a subscriber-only node can be added to a data node group too. Only node_kind='subscriber_only' needs to be specified while doing a create_node as before. the join_node_group can be done on a data node group.</p>
</details></td><td></td></tr>
<tr><td><details><summary>Add bdr.local_analytics_slot_name() SQL function.</summary><hr/><p>Returns name of analytics slot. This merely produces the correct name irrespective of whether analytics feature is in use.</p>
</details></td><td></td></tr>
<tr><td><details><summary>Add node_uuid column to bdr.node_summary view.</summary><hr/><p>Added to complement the addition of the node_uuid column to bdr.node and bdr.local_node</p>
</details></td><td></td></tr>
</tbody></table>


## Enhancements

<table class="table w-100"><thead><tr><th>Description</th><th width="10%">Addresses</th></tr></thead><tbody>
<tr><td><details><summary>Multiple conflicting rows resolution</summary><hr/><p>Both <code>pk_exists</code> and <code>multiple_unique_conflicts</code> conflict types can now resolve more than one conflicting row by removing any old rows that are part of the conflict. The <code>multiple_unique_conflicts</code> now defaults to <code>update_if_newer</code> resolver, so it does not throw error by default anymore.</p>
</details></td><td></td></tr>
<tr><td><details><summary>Improved <code>bdr.stat_activity</code> view</summary><hr/><p>The <code>backend_type</code> now shows consistent worker type for PGD workers without the extra process identification. The <code>wait_event_type</code> and <code>wait_event</code> include more wait events now, instead of showing &quot;extension&quot; for some events. Also, connection management related columns are added to show real client address/port and whether the session is read-only.</p>
</details></td><td></td></tr>
<tr><td><details><summary>The PARTED node is removed  automatically from all nodes in the cluster.</summary><hr/><p>From PGD 6.0.0, bdr.part_node functionality is enhanced to remove the parted node’s  metadata automatically from all nodes in the cluster.</p>
<ul>
<li>For local node, it will remove all the node metadata, including information about remote nodes.</li>
<li>For remote node, it removes only metadata for that specific node.
Hence with this release</li>
<li>A node will remain in PART_CLEANUP state till group slots of all nodes are caught up to all the transactions originating from the PARTED node</li>
<li>A node will not remain in PARTED state as the node is removed as soon as it moves to PARTED state.</li>
</ul>
</details></td><td></td></tr>
<tr><td><details><summary>Table rewriting <code>ALTER TABLE... ALTER COLUMN</code> calls are now supported.</summary><hr/><p>Changing a column's type command which causes the whole table to be rewritten and the change isn't binary coercible is now supported:</p>
<pre><code class="language-sql">CREATE TABLE foo (c1 int,c2 int, c3 int, c4 box, UNIQUE(c1, c2) INCLUDE(c3,c4));
ALTER TABLE foo ALTER c1 TYPE bigint; – results into table rewrite
</code></pre>
<p>This also includes support for <code>ALTER TYPE</code> when using the <code>USING</code> clause:</p>
<pre><code class="language-sql">CREATE TABLE foo (id serial primary key,data text);
ALTER TABLE foo ALTER data TYPE BYTEA USING data::bytea;
</code></pre>
<p>Table rewrites can hold an AccessExclusiveLock for extended periods on larger tables.</p>
</details></td><td></td></tr>
<tr><td><details><summary>Restrictions on non-immutable <code>ALTER TABLE... ADD COLUMN</code> calls have been removed.</summary><hr/><p>The restrictions on non-immutable <code>ALTER TABLE... ADD COLUMN</code> calls have been removed.</p>
</details></td><td></td></tr>
<tr><td><details><summary>Introduce <code>bdr.node_group_config_summary</code> view</summary><hr/><p>The new <code>bdr.node_group_config_summary</code> view contains detailed information about group options, including effective value, source of the effective value, default value, whether the value can be inherited, etc. This is in similar spirit to <code>pg_settings</code></p>
</details></td><td></td></tr>
<tr><td><details><summary>Leader DML lock</summary><hr/><p>New lock type leader DML lock is used by default for locking DDL statements that need to block DML. This lock locks on write-leaders only, no requiring all nodes to participate in the locking operation. Old behavior can be restored by adjusting <code>bdr.ddl_locking</code> configuration parameter.</p>
</details></td><td></td></tr>
<tr><td><details><summary>Disabling bdr.xact_replication in run_on_* functions</summary><hr/><p>Functions <code>run_on_nodes</code>, <code>run_on_all_nodes</code> and <code>run_on_group</code> now sets <code>bdr.xact_replication</code> to <code>off</code> by default.</p>
</details></td><td></td></tr>
<tr><td><details><summary>Replica Identity full by default</summary><hr/><p>The <code>auto</code> value for <code>bdr.default_replica_identity</code> changed to
REPLICA IDENTITY FULL. This setting prevents some edge cases in
conflict detection between inserts, updates and deletes across node
crashes and recovery.</p>
<p>When the PGD group is created and the database of the initial PGD node is not empty (i.e. has some tables with data) the REPLICA IDENTITY of all tables will be set according to <code>bdr.default_replica_identity</code>.</p>
</details></td><td></td></tr>
</tbody></table>


## Changes

<table class="table w-100"><thead><tr><th>Description</th><th width="10%">Addresses</th></tr></thead><tbody>
<tr><td><details><summary>Routing is now enabled by default on subgroups</summary><hr/><p>Routing (and by extension raft) is now enabled by default on data-groups (subgroups with data nodes).</p>
</details></td><td></td></tr>
</tbody></table>


## Bug Fixes

<table class="table w-100"><thead><tr><th>Description</th><th width="10%">Addresses</th></tr></thead><tbody>
<tr><td><details><summary>Fixed issue where parting node may belong to a non-existing group</summary><hr/><p>When parting a given node, that same node may have subscriptions whose
origin was already parted and the group dropped. Previously this would break PGD, and has since been fixed.</p>
</details></td><td></td></tr>
<tr><td><details><summary>num_writers should be positive or -1</summary><hr/><p>The num_writers option, used in bdr.alter_node_group_option() and bdr.alter_node_group_config() should be positive or -1.</p>
</details></td><td></td></tr>
</tbody></table>


