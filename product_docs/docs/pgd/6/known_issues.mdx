---
title: 'Known issues and limitations'
nav_title: 'Known issues and limitations'
description: 'Known issues and limitations in EDB Postgres Distributed 6'
---

## Known issues

These are currently known issues in EDB Postgres Distributed 6.
These known issues are tracked in PGD's ticketing system and are expected to be resolved in a future release.

- If the resolver for the `update_origin_change` conflict
    is set to `skip`, `synchronous_commit=remote_apply` is used, and
    concurrent updates of the same row are repeatedly applied on two
    different nodes, then one of the update statements might hang due
    to a deadlock with the PGD writer. As mentioned in
    [Conflicts](/pgd/advanced/conflict-management/conflicts/), `skip` isn't the default
    resolver for the `update_origin_change` conflict, and this
    combination isn't intended to be used in production. It discards
    one of the two conflicting updates based on the order of arrival
    on that node, which is likely to cause a divergent cluster.
    In the rare situation that you do choose to use the `skip`
    conflict resolver, note the issue with the use of the
    `remote_apply` mode.

- The Decoding Worker feature doesn't work with CAMO/Eager/Group Commit.
Installations using CAMO/Eager/Group Commit must keep `enable_wal_decoder` disabled.

- Lag Control doesn't adjust commit delay in any way on a fully isolated node, that's in case all other nodes are unreachable or not operational. 
As soon as at least one node connects, replication Lag Control picks up its work and adjusts the PGD commit delay again.

- For time-based Lag Control, PGD currently uses the lag time, measured by commit timestamps, rather than the estimated catch up time that's based on historic apply rates.

- Changing the CAMO partners in a CAMO pair isn't currently possible.
It's possible only to add or remove a pair.
Adding or removing a pair doesn't require a restart of Postgres or even a reload of the configuration.

- Group Commit can't be combined with [CAMO](/pgd/latest/reference/commit-scopes/camo/). 

- Transactions using Eager Replication can't yet execute DDL. The TRUNCATE command is allowed.

- Parallel Apply isn't currently supported in combination with Group Commit. Make sure to disable it when using Group Commit by either (a) Setting `num_writers` to 1 for the node group using [`bdr.alter_node_group_option`](/pgd/latest/reference/tables-views-functions/nodes-management-interfaces/#bdralter_node_group_option) or (b) using the GUC [`bdr.writers_per_subscription`](/pgd/latest/reference/tables-views-functions/pgd-settings#bdrwriters_per_subscription). See [Configuration of generic replication](/pgd/latest/reference/tables-views-functions/pgd-settings#generic-replication).

- There currently is no protection against altering or removing a commit scope. 
Running transactions in a commit scope that's concurrently being altered or removed can lead to the transaction blocking or replication stalling completely due to an error on the downstream node attempting to apply the transaction.
Make sure that any transactions using a specific commit scope have finished before altering or removing it.

- The [PGD CLI](/pgd/latest/reference/cli) can return stale data on the state of the cluster if it's still connecting to nodes that were previously parted from the cluster. 
Edit the [`pgd-cli-config.yml`](/pgd/latest/reference/cli/configuring_cli/#using-a-configuration-file) file, or change your [`--dsn`](/pgd/latest/reference/cli/configuring_cli/#using-database-connection-strings-in-the-command-line) settings to ensure only active nodes in the cluster are listed for connection.

To modify a commit scope safely, use [`bdr.alter_commit_scope`](/pgd/latest/reference/tables-views-functions/functions#bdralter_commit_scope).

- DDL run in serializable transactions can face the error: `ERROR: could not serialize access due to read/write dependencies among transactions`. A workaround is to run the DDL outside serializable transactions.

- The EBD Postgres Advanced Server 17 data type [`BFILE`](/epas/latest/reference/sql_reference/02_data_types/03a_bfiles/) is not currently supported. This is due to `BFILE` being a file reference that is stored in the database, and the file itself is stored outside the database and not replicated.

- EDB Postgres Advanced Server's native autopartioning is not supported in PGD. See [Restrictions on EDB Postgres Advanced Server-native automatic partitioning](/pgd/latest/reference/autopartition#restrictions-on-edb-postgres-advanced-server-native-automatic-partitioning) for more information.

## Limitations

Take these EDB Postgres Distributed (PGD) design limitations
into account when planning your deployment.

### Nodes

-   PGD can run hundreds of nodes, assuming adequate hardware and network. However,
    for mesh-based deployments, we generally don’t recommend running more than 48
    nodes in one cluster. If you need extra read scalability beyond the 48-node
    limit, you can add subscriber-only nodes without adding connections to the
    mesh network.

-   The minimum recommended number of nodes in a group is three to provide fault
    tolerance for PGD's consensus mechanism. With just two nodes, consensus would
    fail if one of the nodes were unresponsive. Consensus is required for some PGD
    operations, such as distributed sequence generation. For more information about
    the consensus mechanism used by EDB Postgres Distributed, see [Architectural
    details](/pgd/latest/reference/architectures/).

### Multiple databases on single instances

Support for using PGD for multiple databases on the same Postgres instance is
**deprecated** beginning with PGD 5 and will no longer be supported with PGD 6. As
we extend the capabilities of the product, the added complexity introduced
operationally and functionally is no longer viable in a multi-database design.

It's best practice and we recommend that you configure only one database per PGD instance. 

The deployment automation with TPA and the tooling such as the CLI
and Connection Manager already codify that recommendation. 

While it's still possible to host up to 10 databases in a single instance,
doing so incurs many immediate risks and current limitations:

-   If PGD configuration changes are needed, you must execute administrative commands 
    for each database. Doing so increases the risk for potential
    inconsistencies and errors.

-   You must monitor each database separately, adding overhead.

-   TPAexec assumes one database. Additional coding is needed by customers or by the EDB Professional Services team
    in a post-deploy hook to set up replication for more databases.

-   Connection Manager works at the Postgres instance level, not at the database level,
    meaning the leader node is the same for all databases.

-   Each additional database increases the resource requirements on the server.
    Each one needs its own set of worker processes maintaining replication, for example,
    logical workers, WAL senders, and WAL receivers. Each one also needs its own
    set of connections to other instances in the replication cluster. These needs might
    severely impact performance of all databases.

-   Synchronous replication methods, for example, CAMO and Group Commit, won’t work as
    expected. Since the Postgres WAL is shared between the databases, a
    synchronous commit confirmation can come from any database, not necessarily in
    the right order of commits.

-   CLI and OTEL integration assumes one database. 

### Durability options (Group Commit/CAMO)

There are various limits on how the PGD durability options work. 
These limitations are a product of the interactions between Group Commit and CAMO, and how they interact with PGD features such as the [WAL decoder](/pgd/latest/reference/decoding_worker/) and  [transaction streaming](/pgd/latest/reference/transaction-streaming/).

Also, there are limitations on interoperability with legacy synchronous replication,
interoperability with explicit two-phase commit, and unsupported combinations
within commit scope rules. 

See [Durability limitations](/pgd/latest/reference/commit-scopes/limitations/) for a full
and current listing.

### Mixed PGD versions

PGD was developed to [enable rolling upgrades of PGD](/pgd/latest/upgrades) by allowing mixed versions of PGD to operate during the upgrade process. 
We expect users to run mixed versions only during upgrades and, once an upgrade starts, that they complete that upgrade.
We don't support running mixed versions of PGD except during an upgrade.

### Other limitations

This noncomprehensive list includes other limitations that are expected and
are by design. We don't expect to resolve them in the future. 
Consider these limitations when planning your deployment:

-   A `galloc` sequence might skip some chunks if you create the sequence in a
    rolled back transaction and then create it again with the same name. Skipping chunks can
    also occur if you create and drop the sequence when DDL replication isn't active
    and then you create it again when DDL replication is active. The impact of
    the problem is mild because the sequence guarantees aren't violated. The
    sequence skips only some initial chunks. Also, as a workaround, you can
    specify the starting value for the sequence as an argument to the
    `bdr.alter_sequence_set_kind()` function.
