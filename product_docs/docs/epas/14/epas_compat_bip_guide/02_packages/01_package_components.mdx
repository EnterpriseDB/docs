---
title: "Package components"
legacyRedirectsGenerated:
  # This list is generated by a script. If you need add entries, use the `legacyRedirects` key.
  - "/edb-docs/d/edb-postgres-advanced-server/user-guides/database-compatibility-for-oracle-developers-built-in-package-guide/9.6/Database_Compatibility_for_Oracle_Developers_Built-in_Package_Guide.1.06.html"
  - "/edb-docs/d/edb-postgres-advanced-server/user-guides/database-compatibility-for-oracle-developers-guide/9.5/Database_Compatibility_for_Oracle_Developers_Guide.1.184.html"
---

Packages consist of two main components:

-   The *package specification*: This is the public interface, (these are the elements which can be referenced outside the package). We declare all database objects that are to be a part of our package within the specification.
-   The *package body*: This contains the actual implementation of all the database objects declared within the package specification.

The package body implements the specifications in the package specification. It contains implementation details and private declarations which are invisible to the application. You can debug, enhance or replace a package body without changing the specifications. Similarly, you can change the body without recompiling the calling programs because the implementation details are invisible to the application.

## Package specification syntax

The package specification defines the user interface for a package (the API). The specification lists the functions, procedures, types, exceptions and cursors that are visible to a user of the package.

The syntax used to define the interface for a package is:

```text
CREATE [ OR REPLACE ] PACKAGE <package_name>
  [ <authorization_clause> ]
  { IS | AS }
  [ <declaration>; ] ...
  [ <procedure_or_function_declaration> ] ...
END [ <package_name> ] ;
```

Where `authorization_clause` :=

```text
{ AUTHID DEFINER } | { AUTHID CURRENT_USER }
```

Where `procedure_or_function_declaration` :=

```text
procedure_declaration | function_declaration
```

Where `procedure_declaration` :=

```text
PROCEDURE proc_name [ argument_list ];
[ restriction_pragma; ]
```

Where `function_declaration` :=

```text
FUNCTION func_name [ argument_list ]
  RETURN rettype [ DETERMINISTIC ];
[ restriction_pragma; ]
```

Where `argument_list` :=

```text
( argument_declaration [, ...] )
```

Where `argument_declaration` :=

```text
argname [ IN | IN OUT | OUT ] argtype [ DEFAULT value ]
```

Where `restriction_pragma` :=

```text
PRAGMA RESTRICT_REFERENCES(name, restrictions)
```

Where `restrictions` :=

```text
restriction [, ... ]
```

### Parameters

`package_name`

 `package_name` is an identifier assigned to the package - each package must have a name unique within the schema.

`AUTHID DEFINER`

 If you omit the `AUTHID` clause or specify `AUTHID DEFINER`, the privileges of the package owner are used to determine access privileges to database objects.

`AUTHID CURRENT_USER`

 If you specify `AUTHID CURRENT_USER`, the privileges of the current user executing a program in the package are used to determine access privileges.

`declaration`

 `declaration` is an identifier of a public variable. A public variable can be accessed from outside of the package using the syntax `package_name.variable`. There can be zero, one, or more public variables. Public variable definitions must come before procedure or function declarations.

 `declaration` can be any of the following:

-   Variable Declaration
-   Record Declaration
-   Collection Declaration
-   `REF CURSOR` and Cursor Variable Declaration
-   `TYPE` Definitions for Records, Collections, and `REF CURSORs`
-   Exception
-   Object Variable Declaration

`proc_name`

 The name of a public procedure.

`argname`

 The name of an argument. The argument is referenced by this name within the function or procedure body.

`IN | IN OUT | OUT`

 The argument mode. `IN` declares the argument for input only. This is the default. `IN OUT` allows the argument to receive a value as well as return a value. `OUT` specifies the argument is for output only.

`argtype`

 The data type(s) of an argument. An argument type may be a base data type, a copy of the type of an existing column using `%TYPE`, or a user-defined type such as a nested table or an object type. A length must not be specified for any base type - for example, specify `VARCHAR2`, not `VARCHAR2(10`).

 The type of a column is referenced by writing `tablename.columnname` `%TYPE`; using this can sometimes help make a procedure independent from changes to the definition of a table.

`DEFAULT value`

 The `DEFAULT` clause supplies a default value for an input argument if one is not supplied in the invocation. `DEFAULT` may not be specified for arguments with modes `IN OUT` or `OUT`.

`func_name`

 The name of a public function.

`rettype`

 The return data type.

`DETERMINISTIC`

 `DETERMINISTIC` is a synonym for `IMMUTABLE`. A `DETERMINISTIC` function cannot modify the database and always reaches the same result when given the same argument values; it does not do database lookups or otherwise use information not directly present in its argument list. If you include this clause, any call of the function with all-constant arguments can be immediately replaced with the function value.

`restriction`

 The following keywords are accepted for compatibility and ignored:

 `RNDS`

 `RNPS`

 `TRUST`

 `WNDS`

 `WNPS`

## Package body syntax

Package implementation details reside in the package body; the package body may contain objects that are not visible to the package user. Advanced Server supports the following syntax for the package body:

```text
CREATE [ OR REPLACE ] PACKAGE BODY <package_name>
  { IS | AS }
  [ <private_declaration>; ] ...
  [ <procedure_or_function_definition> ] ...
  [ <package_initializer> ]
END [ <package_name> ] ;
```

Where `procedure_or_function_definition` :=

```text
procedure_definition | function_definition
```

Where `procedure_definition` :=

```text
PROCEDURE proc_name[ argument_list ]
  [ options_list ]
  { IS | AS }
    procedure_body
  END [ proc_name ] ;
```

Where `procedure_body` :=

```text
[ PRAGMA AUTONOMOUS_TRANSACTION; ]
[ declaration; ] [, ...]
BEGIN
  statement; [...]
[ EXCEPTION
   { WHEN exception [OR exception] [...]] THEN statement; }
   [...]
]
```

Where `function_definition` :=

```text
FUNCTION func_name [ argument_list ]
  RETURN rettype [ DETERMINISTIC ]
  [ options_list ]
  { IS | AS }
    function_body
  END [ func_name ] ;
```

Where `function_body` :=

```text
[ PRAGMA AUTONOMOUS_TRANSACTION; ]
[ declaration; ] [, ...]
BEGIN
  statement; [...]
[ EXCEPTION
  { WHEN exception [ OR exception ] [...] THEN statement; }
  [...]
]
```

Where `argument_list` :=

```text
( argument_declaration [, ...] )
```

Where `argument_declaration` :=

```text
argname [ IN | IN OUT | OUT ] argtype [ DEFAULT value ]
```

Where `options_list` :=

```text
option [ ... ]
```

Where `option` :=

```text
STRICT
LEAKPROOF
PARALLEL { UNSAFE | RESTRICTED | SAFE }
COST execution_cost
ROWS result_rows
SET config_param { TO value | = value | FROM CURRENT }
```

Where `package_initializer` :=

```text
BEGIN
 statement; [...]
END;
```

### Parameters

`package_name`

 `package_name` is the name of the package for which this is the package body. There must be an existing package specification with this name.

`private_declaration`

 `private_declaration` is an identifier of a private variable that can be accessed by any procedure or function within the package. There can be zero, one, or more private variables. `private_declaration` can be any of the following:

-   Variable Declaration
-   Record Declaration
-   Collection Declaration
-   `REF CURSOR` and Cursor Variable Declaration
-   `TYPE` Definitions for Records, Collections, and `REF CURSORs`
-   Exception
-   Object Variable Declaration

`proc_name`

 The name of the procedure being created.

`PRAGMA AUTONOMOUS_TRANSACTION`

 `PRAGMA AUTONOMOUS_TRANSACTION` is the directive that sets the procedure as an autonomous transaction.

`declaration`

 A variable, type, `REF CURSOR`, or subprogram declaration. If subprogram declarations are included, they must be declared after all other variable, type, and `REF CURSOR` declarations.

`statement`

 An SPL program statement. Note that a `DECLARE - BEGIN - END` block is considered an SPL statement unto itself. Thus, the function body may contain nested blocks.

`exception`

 An exception condition name such as `NO_DATA_FOUND, OTHERS`, etc.

`func_name`

 The name of the function being created.

`rettype`

 The return data type, which may be any of the types listed for `argtype`. As for `argtype`, a length must not be specified for `rettype`.

`DETERMINISTIC`

 Include `DETERMINISTIC` to specify that the function will always return the same result when given the same argument values. A `DETERMINISTIC` function must not modify the database.

 **Note**: The `DETERMINISTIC` keyword is equivalent to the PostgreSQL `IMMUTABLE` option.

 **Note**: If `DETERMINISTIC` is specified for a public function in the package body, it must also be specified for the function declaration in the package specification. (For private functions, there is no function declaration in the package specification.)

`PRAGMA AUTONOMOUS_TRANSACTION`

 `PRAGMA AUTONOMOUS_TRANSACTION` is the directive that sets the function as an autonomous transaction.

`argname`

 The name of a formal argument. The argument is referenced by this name within the procedure body.

`IN | IN OUT | OUT`

 The argument mode. `IN` declares the argument for input only. This is the default. `IN OUT` allows the argument to receive a value as well as return a value. `OUT` specifies the argument is for output only.

`argtype`

 The data type(s) of an argument. An argument type may be a base data type, a copy of the type of an existing column using `%TYPE`, or a user-defined type such as a nested table or an object type. A length must not be specified for any base type - for example, specify `VARCHAR2`, not `VARCHAR2(10)`.

 The type of a column is referenced by writing `tablename.columnname%TYPE`; using this can sometimes help make a procedure independent from changes to the definition of a table.

`DEFAULT value`

 The `DEFAULT` clause supplies a default value for an input argument if one is not supplied in the procedure call. `DEFAULT` may not be specified for arguments with modes `IN OUT` or `OUT`.

 Please note: The following options are not compatible with Oracle databases; they are extensions to Oracle package syntax provided by Advanced Server only.

`STRICT`

 The `STRICT` keyword specifies that the function will not be executed if called with a `NULL` argument; instead the function will return `NULL`.

`LEAKPROOF`

 The `LEAKPROOF` keyword specifies that the function will not reveal any information about arguments, other than through a return value.

`PARALLEL { UNSAFE | RESTRICTED | SAFE }`

 The `PARALLEL` clause enables the use of parallel sequential scans (parallel mode). A parallel sequential scan uses multiple workers to scan a relation in parallel during a query in contrast to a serial sequential scan.

 When set to `UNSAFE`, the procedure or function cannot be executed in parallel mode. The presence of such a procedure or function forces a serial execution plan. This is the default setting if the `PARALLEL` clause is omitted.

 When set to `RESTRICTED`, the procedure or function can be executed in parallel mode, but the execution is restricted to the parallel group leader. If the qualification for any particular relation has anything that is parallel restricted, that relation won't be chosen for parallelism.

 When set to `SAFE`, the procedure or function can be executed in parallel mode with no restriction.

`execution_cost`

 `execution_cost` specifies a positive number giving the estimated execution cost for the function, in units of `cpu_operator_cost`. If the function returns a set, this is the cost per returned row. The default is `0.0025`.

`result_rows`

 `result_rows` is the estimated number of rows that the query planner should expect the function to return. The default is `1000`.

`SET`

 Use the `SET` clause to specify a parameter value for the duration of the function:

 `config_param` specifies the parameter name.

 `value` specifies the parameter value.

 `FROM CURRENT` guarantees that the parameter value is restored when the function ends.

`package_initializer`

 The statements in the `package_initializer` are executed once per userâ€™s session when the package is first referenced.

!!! Note
    The `STRICT, LEAKPROOF, PARALLEL, COST, ROWS` and `SET` keywords provide extended functionality for Advanced Server and are not supported by Oracle.
