---
title: "XML type"
legacyRedirectsGenerated:
  # This list is generated by a script. If you need add entries, use the `legacyRedirects` key.
  - "/edb-docs/d/edb-postgres-advanced-server/reference/database-compatibility-for-oracle-developers-reference-guide/9.6/Database_Compatibility_for_Oracle_Developers_Reference_Guide.1.016.html"
  - "/edb-docs/d/edb-postgres-advanced-server/user-guides/database-compatibility-for-oracle-developers-guide/9.5/Database_Compatibility_for_Oracle_Developers_Guide.1.048.html"
redirects:
  - /epas/latest/epas_compat_reference/02_the_sql_language/02_data_types/06_xml_type/ #generated for docs/epas/reorg-role-use-case-mode
source:
   url: https://www.postgresql.org/docs/current/datatype-xml.html
   timestamp: 2023-09-20
---

<div id="xml_type" class="registered_link"></div>

| Name           | Native | Alias | Description                                   |
| -------------- | ------ | ----- | --------------------------------------------- |
| `XMLTYPE`      | ✅     |       | Data type used to store XML data.             |

## Overview

The `XMLTYPE` data type is used to store XML data. Its advantage over storing XML data in a character field is that it checks the input values for how well they're formed. Also, support functions perform type-safe operations on it.

The XML type can store well-formed "documents", as defined by the XML standard, as well as "content" fragments, which are defined by the production `XMLDoc content` in the XML standard. Roughly, this means that content fragments can have more than one top-level element or character node.

This example shows creating and inserting a row into a table with an `XMLTYPE` column:

```sql
CREATE TABLE books (
    content         XMLTYPE
);

INSERT INTO books VALUES (XMLPARSE (DOCUMENT '<?xml
version="1.0"?><book><title>Manual</title><chapter>...</chapter></book>'));

SELECT * FROM books;
__OUTPUT__
                         content
----------------------------------------------------------
 <book><title>Manual</title><chapter>...</chapter></book>
(1 row)
```

## Creating XML Values 

To produce a value of type XML from character data, use the function `XMLPARSE`:

```
XMLPARSE ( { DOCUMENT | CONTENT } value)
```

Examples:

```
XMLPARSE (DOCUMENT '<?xml version="1.0"?><book><title>Manual</title><chapter>...</chapter></book>')
XMLPARSE (CONTENT 'abc<foo>bar</foo><bar>foo</bar>')
```

While this is the only way to convert character strings into XML values according to the SQL standard, the PostgreSQL-specific syntaxes:

```
xml '<foo>bar</foo>'
'<foo>bar</foo>'::xml
```

can also be used.

The XML type does not validate input values against a document type declaration (DTD), even when the input value specifies a DTD. There is also currently no built-in support for validating against other XML schema languages such as XML Schema.

The inverse operation, producing a character string value from XML, uses the function `XMLSERIALIZE`:

```
XMLSERIALIZE ( { DOCUMENT | CONTENT } value AS type [ [ NO ] INDENT ] )
```

`type` can be `character`, `character varying`, or `text` (or an alias for one of those). Again, according to the SQL standard, this is the only way to convert between type XML and character types, but PostgreSQL also allows you to simply cast the value.

The `INDENT` option causes the result to be pretty-printed, while `NO INDENT` (which is the default) just emits the original input string. Casting to a character type likewise produces the original string.

When a character string value is cast to or from type XML without going through `XMLPARSE` or `XMLSERIALIZE`, respectively, the choice of `DOCUMENT` versus `CONTENT` is determined by the “XML option” session configuration parameter, which can be set using the standard command:

```
SET XML OPTION { DOCUMENT | CONTENT };
```

or the more PostgreSQL-like syntax

```
SET xmloption TO { DOCUMENT | CONTENT };
```

The default is `CONTENT`, so all forms of XML data are allowed.

## XMLType subprograms

From version 17, XMLType can be called as an object type and has predefined member functions and constructors on it.

This table summarizes member functions and constructors of XMLType.

| Method                            | Type                 | Description                                                                                                                                                                                          |
|-----------------------------------|----------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [`EXISTSNODE`](#existsnode)       | Member function      | It takes a `XMLType` instance and a `XPath`, returning 1 or 0 to indicate whether applying the `XPath` results in a non-empty set of nodes.                                                          |
| [`EXTRACT_XML`](#extract_xml)     | Member function      | It takes a `XMLType` instance and a `XPath`, applies the `XPath` expression and returns the results as an `XMLType`.                                                                                 |
| [`GETCLOBVAL()`](#getclobval)     | Member function      | It returns the value of the `XMLType` instance as a CLOB.                                                                                                                                            |
| [`GETNUMBERVAL()`](#getnumberval) | Member function      | The value of the `XMLType` instance is returned as a NUMBER. This operation is valid only if the input `XMLType` instance contains a simple text node and can be successfully converted to a number. |
| [`GETSTRINGVAL()`](#getstringval) | Member function      | It returns the value of the `XMLType` instance as a string.                                                                                                                                          |
| [`XMLTYPE`](#xmltype)             | Constructor function | It constructs an instance of the `XMLType` datatype. The constructor accepts the XML as a CLOB, TEXT, or an object type.                                                                             |

### EXISTSNODE

This member function verifies the existence of its associated node.

**Syntax:**

```text
MEMBER FUNCTION EXISTSNODE(ip_xpath TEXT, ip_nsp TEXT[] DEFAULT '{}'::TEXT[]) RETURN INTEGER
```

Where,

`ip_xpath` is an expression to test.

`ip_nsp` is an optional namespace mapping.

### EXTRACT_XML

**Syntax:**

```text
MEMBER FUNCTION EXTRACT_XML(ip_xpath TEXT, ip_nsp TEXT[] DEFAULT '{}'::TEXT[]) RETURN SET OF XMLTYPE
```

Where,

`ip_xpath` is an expression to be applied.

`ip_nsp` is an optional prefix to namespace mapping information.

### GETCLOBVAL()

**Syntax:**

```text
MEMBER FUNCTION GETCLOBVAL() RETURN CLOB
```

### GETNUMBERVAL()

**Syntax:**

```text
MEMBER FUNCTION GETNUMBERVAL() RETURN NUMERIC
```

### GETSTRINGVAL()

**Syntax:**

```text
MEMBER FUNCTION GETSTRINGVAL() RETURN VARCHAR2
```

### XMLTYPE constructor function

**Syntax:**

```text
CONSTRUCTOR FUNCTION XMLTYPE(xml_node XML) RETURN SELF AS RESULT,
CONSTRUCTOR FUNCTION XMLTYPE(clob_data CLOB) RETURN SELF AS RESULT,
CONSTRUCTOR FUNCTION XMLTYPE(cur SYS_REFCURSOR) RETURN SELF AS RESULT,
CONSTRUCTOR FUNCTION XMLTYPE(text_data TEXT) RETURN SELF AS RESULT
```

### Examples - Member functions

This example shows how to create a table with XMLTYPE data type and insert data into it.

```sql
CREATE TABLE person_xmltype (person_id integer,person_data xmltype);
INSERT INTO person_xmltype(person_id, person_data)
VALUES (1, xmltype('<PDRecord><PDName>test_user1</PDName><PDID>1</PDID><PDEmail>test_user1@testmail.com</PDEmail></PDRecord>'::xml)),
       (2, xmltype('<PDRecord><PDName>test_user2</PDName><PDID>2</PDID><PDEmail>test_user2@testmail.com</PDEmail></PDRecord>'::xml)),
       (3, xmltype('<PDRecord><PDName>test_user3</PDName><PDID>3</PDID><PDEmail>test_user3@testmail.com</PDEmail></PDRecord>'::xml)),
       (4, xmltype('<PDRecord><PDName>test_user4</PDName><PDID>4</PDID><PDEmail>test_user4@testmail.com</PDEmail></PDRecord>'::TEXT)),
       (5, xmltype('<PDRecord><PDName>test_user5</PDName><PDID>5</PDID><PDEmail>test_user5@testmail.com</PDEmail></PDRecord>'::CLOB)) ;
```

These examples shows how to use EXTRACT_XML member function to view the XMLTYPE data stored in the tables.

```sql
-- Extract_xml()
SELECT person_data.EXTRACT_XML('/PDRecord/PDName') FROM person_xmltype;
__OUTPUT__
extract_xml
-----------------------------
<PDName>test_user1</PDName>
<PDName>test_user2</PDName>
<PDName>test_user3</PDName>
<PDName>test_user4</PDName>
<PDName>test_user5</PDName>
(5 rows)
```

```sql
SELECT EXTRACT_XML(person_data, '/PDRecord/PDName') FROM person_xmltype;
__OUTPUT__
extract_xml
-----------------------------
<PDName>test_user1</PDName>
<PDName>test_user2</PDName>
<PDName>test_user3</PDName>
<PDName>test_user4</PDName>
<PDName>test_user5</PDName>
(5 rows)
```

```sql
SELECT EXTRACT_XML(xmltype('<a
xmlns="http://example.com"><b>test</b><b>test1</b></a>'), '//mydefns:b',
ARRAY[ARRAY['mydefns', 'http://example.com']]);
__OUTPUT__
extract_xml
-----------------------------------------
<b xmlns="http://example.com">test</b>
<b xmlns="http://example.com">test1</b>
(2 rows)
```

```sql
-- Extractvalue()
SELECT EXTRACTVALUE(person_data, '/PDRecord/PDName') FROM person_xmltype;
__OUTPUT__
extractvalue
--------------
test_user1
test_user2
test_user3
test_user4
test_user5
(5 rows)
```

```sql
SELECT EXTRACTVALUE(xmltype('<a
xmlns="http://example.com"><b>test</b><b>test1</b></a>'),'//mydefns:b[position()
=1]/text()',ARRAY[ARRAY['mydefns', 'http://example.com']]);
__OUTPUT__
extractvalue
--------------
test
(1 row)
```

This example shows how to use GETNUMBERVAL(), GETSTRINGVAL(), and GETCLOBVAL() member functions.

```sql
-- GetNumberVal(), GetStringVal(), GetClobVal()
DECLARE
xmltype_data XMLTYPE;
BEGIN
SELECT person_data.EXTRACT_XML('/PDRecord/PDID/text()') INTO xmltype_data
FROM person_xmltype LIMIT 1;
DBMS_OUTPUT.PUT_LINE(xmltype_data.getNumberval());
SELECT person_data.EXTRACT_XML('/PDRecord/PDEmail/text()') INTO xmltype_data
FROM person_xmltype LIMIT 1;
DBMS_OUTPUT.PUT_LINE(xmltype_data.getStringVal());
DBMS_OUTPUT.PUT_LINE(xmltype_data.getClobVal());
END;
__OUTPUT__
1
test_user1@testmail.com
test_user1@testmail.com
```

These examples shows how to use EXISTSNODE member function to check the node existence.

```sql
-- ExistsNode()
SELECT person_data.EXISTSNODE('/PDRecord/PDName') FROM person_xmltype;
__OUTPUT__
existsnode
------------
1
1
1
1
1
(5 rows)
```

```sql
SELECT EXISTSNODE(person_data, '/PDRecord/PDName') FROM person_xmltype;
existsnode
------------
1
1
1
1
1
(5 rows)
```

```sql
SELECT EXISTSNODE(xmltype('<a
xmlns="http://example.com"><b>test</b><b>test1</b></a>'),'//mydefns:b',ARRAY[ARR
AY['mydefns', 'http://example.com']]);
existsnode
------------
1
(1 row)
```

## Encoding Handling 

Take care when dealing with multiple character encodings on the client, server, and in the XML data passed through them. When using the text mode to pass queries to the server and query results to the client, which is the normal mode, PostgreSQL converts all character data passed between the client and the server and vice versa to the character encoding of the respective end. This includes string representations of XML values. This would ordinarily mean that encoding declarations contained in XML data can become invalid as the character data is converted to other encodings while traveling between client and server, because the embedded encoding declaration is not changed. To cope with this behavior, encoding declarations contained in character strings presented for input to the XML type are ignored, and content is assumed to be in the current server encoding. Consequently, for correct processing, character strings of XML data must be sent from the client in the current client encoding. It is the responsibility of the client to either convert documents to the current client encoding before sending them to the server, or to adjust the client encoding appropriately. On output, values of type XML will not have an encoding declaration, and clients should assume all data is in the current client encoding.

When using binary mode to pass query parameters to the server and query results back to the client, no encoding conversion is performed, so the situation is different. In this case, an encoding declaration in the XML data will be observed, and if it is absent, the data will be assumed to be in UTF-8 (as required by the XML standard; note that PostgreSQL does not support UTF-16). On output, data will have an encoding declaration specifying the client encoding, unless the client encoding is UTF-8, in which case it will be omitted.

Processing XML data with PostgreSQL will be less error-prone and more efficient if the XML data encoding, client encoding, and server encoding are the same. Since XML data is internally processed in UTF-8, computations will be most efficient if the server encoding is also UTF-8.

!!!Note
Some XML-related functions may not work at all on non-ASCII data when the server encoding is not UTF-8. This is known to be an issue for `xmltable()` and `xpath()` in particular.
!!!

## Accessing XML Values 

The XML data type is unusual because it does not provide any comparison operators. This is because there is no well-defined and universally useful comparison algorithm for XML data. One consequence of this is that you cannot retrieve rows by comparing an XML column against a search value. XML values should therefore typically be accompanied by a separate key field such as an ID. An alternative solution for comparing XML values is to convert them to character strings first, but note that character string comparison has little to do with a useful XML comparison method.

Because there are no comparison operators for the XML data type, it is not possible to create an index directly on a column of this type. If speedy searches in XML data are desired, possible workarounds include casting the expression to a character string type and indexing that, or indexing an XPath expression. Of course, the actual query would have to be adjusted to search by the indexed expression.

The text-search functionality in PostgreSQL can also be used to speed up full-document searches of XML data. The necessary preprocessing support is, however, not yet available in the PostgreSQL distribution.