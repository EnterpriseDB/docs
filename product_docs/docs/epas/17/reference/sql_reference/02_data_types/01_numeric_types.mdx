---
title: "Numeric types"
legacyRedirectsGenerated:
  # This list is generated by a script. If you need add entries, use the `legacyRedirects` key.
  - "/edb-docs/d/edb-postgres-advanced-server/reference/database-compatibility-for-oracle-developers-reference-guide/9.6/Database_Compatibility_for_Oracle_Developers_Reference_Guide.1.012.html"
  - "/edb-docs/d/edb-postgres-advanced-server/user-guides/database-compatibility-for-oracle-developers-guide/9.5/Database_Compatibility_for_Oracle_Developers_Guide.1.044.html"
redirects:
  - /epas/latest/epas_compat_reference/02_the_sql_language/02_data_types/01_numeric_types/ #generated for docs/epas/reorg-role-use-case-mode
source:
   url: https://www.postgresql.org/docs/current/datatype-numeric.html
   timestamp: 2023-08-30
---

<div id="numeric_types" class="registered_link"></div>

|      Data type      | Native | Alias |                                                                                                             Description                                                                                                             |
| ------------------- | ------ | ----- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `SMALLINT`          | ✅      |       | Small-range integer, 2 bytes storage, -32768 to +32767 range                                                                                                                                                                        |
| `INTEGER`           | ✅      |       | Usual choice for integer, 4 bytes storage, -2147483648 to +2147483647 range                                                                                                                                                         |
| `BINARY_INTEGER`    |        | ✅     | Alias for `INTEGER`                                                                                                                                                                                                                 |
| `BIGINT`            | ✅      |       | Large-range integer, 8 bytes storage, 	-9223372036854775808 to +9223372036854775807 range |                                                                                                                                                                                                                                     |
| `PLS_INTEGER`       |        | ✅     | Alias for `INTEGER`                                                                                                                                                                                                                 |
| `DECIMAL`           | ✅      |       | User-specified precision, exact; variable storage;	up to 131072 digits before the decimal point up to 16383 digits after the decimal point range                                                                                     |
| `NUMERIC`           | ✅      |       | User-specified precision, exact; variable storage, up to 131072 digits before the decimal point; up to 16383 digits after the decimal point range                                                                                   |
| `NUMBER`            |        | ✅     | Alias for native numeric                                                                                                                                                                                                            |
| `NUMBER(p [, s ] )` |        | ✅     | Alias of native numeric with exact numeric of maximum precision, `p`, and optional scale, `s`; variable storage, p to 1000 digits of precision                                                                                      |
| `REAL`              | ✅      |       | Variable-precision, inexact; 4 bytes	storage;	6 decimal digits precision range                                                                                                                                                        |
| `DOUBLE PRECISION`  | ✅      |       | Variable-precision, inexact; 8 bytes storage; 15 decimal digits precision range                                                                                                                                                     |
| `BINARY FLOAT`      |        | ✅     | Alias for native `DOUBLE PRECISION`                                                                                                                                                                                                 |
| `SMALLSERIAL`       | ✅      |       | Small autoincrementing integer,  2 bytes storage,	1 to 32767 range                                                                                                                                                                   |
| `SERIAL`            | ✅      |       | Autoincrementing integer, 4 bytes	storage,	1 to 2147483647 range                                                                                                                                                                      |
| `BIGSERIAL`         | ✅      |       | Large autoincrementing integer, 8 bytes	storage,	1 to 9223372036854775807 range                                                                                                                                                       |
| `ROWID`             |        |       | Custom type for emulating Oracle ROWID, signed 8 bit integer; 8 bytes storage; -9223372036854775808 to 9223372036854775807 range (see [Migration Handbook](/migrating/oracle/oracle_epas_comparison/database_features/#data-types)) |

## Overview 

Numeric types consist of four-byte integers, four-byte and eight-byte floating-point numbers, and fixed-precision decimals. 

The syntax of constants for the numeric types is described in [Constants](https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS) in the PostgreSQL documentation. The numeric types have a full set of corresponding arithmetic operators and functions. Refer to [Functions and Operators](../03_functions_and_operators) for more information. The following sections describe the types in detail.

## Integer types

The `BIGINT`, `BINARY_INTEGER`, `INTEGER`, `PLS_INTEGER`, `SMALLINT` and `ROWID` types store whole numbers (without fractional components) as specified in the numeric types table. Attempts to store values outside of the allowed range result in an error.

The type `INTEGER` is the common choice, as it offers the best balance between range, storage size, and performance. The `SMALLINT` type is generally only used if disk space is at a premium. The `BIGINT` type is designed to be used when the range of the `INTEGER` type is insufficient.

## Arbitrary precision numbers

The type `NUMBER` can store an almost unlimited number of digits of precision and perform calculations exactly. We especially recommend it for storing monetary amounts and other quantities where exactness is required. However, the `NUMBER` type is very slow compared to the floating-point types described in [Floating point types](#floating-point-types).

The `scale` of a `NUMBER` is the count of decimal digits in the fractional part, to the right of the decimal point. The `precision` of a `NUMBER` is the total count of significant digits in the whole number, that is, the number of digits to both sides of the decimal point. So the number 23.5141 has a precision of 6 and a scale of 4. Integers have a scale of zero.

You can configure both the precision and the scale of the `NUMBER` type. To declare a column of type `NUMBER`, use the syntax:

```sql
NUMBER(precision, scale)
```

The precision must be positive, and the scale must be zero or positive. Alternatively, this syntax selects a scale of 0:

```sql
NUMBER(precision)
```

Specifying `NUMBER` without any precision or scale creates a column in which you can store numeric values of any precision and scale, up to the implementation limit on precision. A column of this kind doesn't coerce input values to any particular scale, whereas `NUMBER` columns with a declared scale coerce input values to that scale. (The SQL standard requires a default scale of 0, that is, coercion to integer precision. For maximum portability, it's best to specify the precision and scale explicitly.)

If the precision or scale of a value is greater than the declared precision or scale of a column, the system attempts to round the value. If the value can't be rounded to satisfy the declared limits, an error occurs.

Numeric values are physically stored without any extra leading or trailing zeroes. Thus, the declared precision and scale of a column are maximums, not fixed allocations. (In this sense the `NUMBER` type is more akin to `VARCHAR(N)` than to `CHAR(N)`.) The actual storage requirement is two bytes for each group of four decimal digits, plus three to eight bytes overhead.

In addition to ordinary numeric values, the `NUMBER` type allows the special value NaN, meaning “not-a-number”. Any operation on NaN yields another NaN. When writing this value as a constant in an SQL command, you must put quotes around it, for example U`PDATE table SET x = 'NaN'`. On input, the string `NaN` is recognized in a case-insensitive manner.

!!!Note
In most implementations of the “not-a-number” concept, `NaN` is not considered equal to any other numeric value (including `NaN`). In order to allow numeric values to be sorted and used in tree-based indexes, PostgreS treats `NaN` values as equal, and greater than all non-`NaN` values.
!!!

The types `DECIMAL` and `NUMBER` are equivalent. Both types are part of the SQL standard.

When rounding values, the `NUMBER` type rounds ties away from zero, while (on most machines) the `REAL` and `DOUBLE PRECISION` types round ties to the nearest even number. For example:

```SQL
SELECT x,
  round(x::numeric) AS num_round,
  round(x::double precision) AS dbl_round
FROM generate_series(-3.5, 3.5, 1) as x;
  x   | num_round | dbl_round
------+-----------+-----------
 -3.5 |        -4 |        -4
 -2.5 |        -3 |        -2
 -1.5 |        -2 |        -2
 -0.5 |        -1 |        -0
  0.5 |         1 |         0
  1.5 |         2 |         2
  2.5 |         3 |         2
  3.5 |         4 |         4
(8 rows)
```

## Floating-point types

The data types `REAL` and `DOUBLE PRECISION` are *inexact*, variable-precision numeric types. In practice, these types are usually implementations of IEEE Standard 754 for Binary Floating-Point Arithmetic (single and double precision, respectively), to the extent that the underlying processor, operating system, and compiler support it.

Inexact means that some values can't be converted exactly to the internal format and are stored as approximations, so that storing and printing back out a value might show slight discrepancies. Managing these errors and how they propagate through calculations is the subject of an entire branch of mathematics and computer science and isn't discussed further here, except for the following points:

-  If you require exact storage and calculations (such as for monetary amounts), use the `NUMBER` type instead.

-  If you want to do complicated calculations with these types for anything important, especially if you rely on certain behavior in boundary cases (infinity, underflow), evaluate the implementation carefully.

-  Comparing two floating-point values for equality might not work as expected.

On most platforms, the `REAL` type has a range of at least `1E-37` to `1E+37` with a precision of at least six decimal digits. The `DOUBLE PRECISION` type typically has a range of around `1E-307` to `1E+308` with a precision of at least 15 digits. Values that are too large or too small cause an error. Rounding might occur if the precision of an input number is too high. Numbers too close to zero that you can't represent as distinct from zero cause an underflow error.

In addition to ordinary numeric values, the floating-point types have several special values:


- `Infinity`
- `-Infinity`
- `NaN`

These represent the IEEE 754 special values “infinity”, “negative infinity”, and “not-a-number”, respectively. (On a machine whose floating-point arithmetic does not follow IEEE 754, these values will probably not work as expected.) When writing these values as constants in an SQL command, you must put quotes around them, for example `UPDATE table SET x = '-Infinity'`. On input, these strings are recognized in a case-insensitive manner.

!!!Note
IEEE754 specifies that NaN should not compare equal to any other floating-point value (including `NaN`). In order to allow floating-point values to be sorted and used in tree-based indexes, Postgres treats `NaN` values as equal, and greater than all non-`NaN` values.
!!!

EDB Postgres Advanced Server also supports the SQL standard notations `FLOAT` and `FLOAT(p)` for specifying inexact numeric types. Here, `p` specifies the minimum acceptable precision in binary digits. EDB Postgres Advanced Server accepts `FLOAT(1)` to `FLOAT(24)` as selecting the `REAL` type and `FLOAT(25)` to `FLOAT(53)` as selecting `DOUBLE PRECISION`. Values of `p` outside the allowed range draw an error. `FLOAT` with no precision specified is taken to mean `DOUBLE PRECISION`.


!!!Note
The assumption that real and double precision have exactly 24 and 53 bits in the mantissa respectively is correct for IEEE-standard floating point implementations. On non-IEEE platforms it might be off a little, but for simplicity the same ranges of `p` are used on all platforms.
!!!

## Serial types

!!!Note
This section describes a PostgreSQL-specific way to create an autoincrementing column. Another way is to use the SQL-standard identity column feature, described in [CREATE TABLE](https://www.postgresql.org/docs/11/sql-createtable.html).
!!!

The data types `SMALLSERIAL`, `SERIAL` and `BIGSERIAL` are not true types, but merely a notational convenience for creating unique identifier columns (similar to the `AUTO_INCREMENT` property supported by some other databases). In the current implementation, specifying:

```sql
CREATE TABLE tablename (
    colname SERIAL
);
```

is equivalent to specifying:

```
CREATE SEQUENCE tablename_colname_seq AS integer;
CREATE TABLE tablename (
    colname integer NOT NULL DEFAULT nextval('tablename_colname_seq')
);
ALTER SEQUENCE tablename_colname_seq OWNED BY tablename.colname;
```

Thus, we have created an integer column and arranged for its default values to be assigned from a sequence generator. A `NOT NULL` constraint is applied to ensure that a null value cannot be inserted. (In most cases you would also want to attach a `UNIQUE` or `PRIMARY KEY` constraint to prevent duplicate values from being inserted by accident, but this is not automatic.) Lastly, the sequence is marked as “owned by” the column, so that it will be dropped if the column or table is dropped.

!!!Note
Because `SMALLSERIAL`, `SERIAL` and `BIGSERIAL` are implemented using sequences, there may be "holes" or gaps in the sequence of values which appears in the column, even if no rows are ever deleted. A value allocated from the sequence is still "used up" even if a row containing that value is never successfully inserted into the table column. This may happen, for example, if the inserting transaction rolls back. See [`nextval()`](https://www.postgresql.org/docs/11/functions-sequence.html) for details.
!!!

To insert the next value of the sequence into the serial column, specify that the serial column should be assigned its default value. This can be done either by excluding the column from the list of columns in the INSERT statement, or through the use of the `DEFAULT` key word.

The type names `SERIAL` and `SERIAL4` are equivalent: both create integer columns. The type names `BIGSERIAL` and `SERIAL8` work the same way, except that they create a bigint column. `BIGSERIAL` should be used if you anticipate the use of more than 2147483648 identifiers (2 to the 31st power)over the lifetime of the table. The type names `SMALLSERIAL` and `SERIAL2` also work the same way, except that they create a `SMALLINT` column.

The sequence created for a `SERIAL` column is automatically dropped when the owning column is dropped. You can drop the sequence without dropping the column, but this will force removal of the column default expression.