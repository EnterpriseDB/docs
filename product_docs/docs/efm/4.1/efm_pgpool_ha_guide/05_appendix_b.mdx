---
title: "Configuration for Number of Connections and Pooling"
---

Pgpool has some configuration to tune the pooling and connection processing. Depending on this configuration, also the Postgres configuration for max\_connections should be set to make sure all connections can be accepted as required. Furthermore, note that the Cloud Architecture works with active/active instances, which requires to spread num\_init\_children over all Pgpool instances (divide the normally used value by the number of active instances). The below text describes the effect of changing the configuration, and advises values for both the on-premise and the Cloud architecture.

**max\_pool**: Generally, it is advised to set max\_pool to 1. Alternatively, for applications with a lot of reconnects, max\_pool can be set to the number of distinct combinations of users, databases and connection options for the application connections. All but one connection in the pool would be stale connections, which consumes a connection slot from Postgres, without adding to performance. It is therefore advised not to configure max\_pool beyond 4 to preserve a healthy ratio between active and stale connections. As an example, for an application which constantly reconnects and uses 2 distinct users both connecting to their own database, set it to 2. If both users would be able to connect to both databases set it to 4. Note that increasing max\_pool requires to tune down num\_init\_children in Pgpool, or tune up max\_connections in Postgres.

**num\_init\_children**: It is advised to set num\_init\_children to the number of connections that could be running active in parallel, but the value should be divided by the number of active Pgpool-II instances (one with the on-premise architecture, and all instances for the cloud architecture). As an example: In an architecture with 3 Pgpool instances, to allow the application to have 100 active connections in parallel, set num\_init\_children to 100 for the on-premise architecture, and set num\_init\_children to 33 for the cloud architecture. Note that increasing num\_init\_children generally requires to tune up max\_connections in Postgres.

**listen\_backlog\_multiplier**: Can be set to multiply the number of open connections (as perceived by the application) with the number of active connections (num\_init\_children). As an example, when the application might open 500 connections of which 100 should be active in parallel, with the on-premise architecture, num\_init\_children should be set to 100, and listen\_backlog\_multiplier should be set to 4. This setup can process 100 connections active in parallel, and another 400 (listen\_backlog\_multiplier\*num\_init\_children) connections will be queued before connections will be blocked. The application would perceive a total of 500 open connections, and Postgres would process the load of 100 connections maximum at all times. Note that increasing listen\_backlog\_multiplier only causes the application to perceive more connections, but will not increase the number of parallel active connections (which is determined by num\_init\_children).

**max\_connections**: It is advised to set max\_connections in Postgres higher then \[number of active pgpool instances\]*\[max\_pool\]*\[num\_init\_children\] + \[superuser\_reserved\_connections\] (Postgres). As an example: in the on-premise setup with 3 instances active/passive, max\_pool set to 2, num\_init\_children set to 100, and superuser\_reserved\_connections (Postgres) set to 5, Postgres max\_connections should be set equal or higher then \[1\*2\*100+5\] which is 205 connections or higher. A similar setup in the cloud setup would run with 3 active instances, max\_pool set to 2, num\_init\_children set to 33, and superuser\_reserved\_connections (Postgres) set to 5, in which case Postgres max\_connections should be set equal or higher then \[3\*2\*33+5\] which is 203 or higher. Note that configuring below the advised setting can cause issues opening new connections, and in a combination with max\_pool can cause unexpected behaviour (low or no active connections but still connection issues due to stale pooled connections using connection slots from Postgres. For more information on the relation between num\_init\_children, max\_pool and max\_connections, see this background information.
